## 前言

>前几天，前端发版在线上出现了问题。前端发版后过了一个小时，微信群反映极少部分用户出现了在购课车点击结算时原地刷新的效果，没有出现任何课程数据。但是在这操作之后，后续操作却回归正常

## 原因分析
1. 第一时间我首先出现脑海的是不是上线的js代码出问题了，但是马上被否决了，因为看视频以及反馈。除了进入某个页面的原地刷新之后，后续的操作都可以正常进行。

2. 经过一时间的排除，发现是**缓存问题**。猜测应该是部署过后，微信浏览器缓存了入口文件html, 造成部署完成之后旧的一些静态文件css,js被新部署的css，js文件替换，因为微信浏览器缓存了旧的html。旧的html文件拉取的依旧是旧的一些css,js文件。但是部分旧的css，js文件已被删除。浏览器拉取不到旧的文件被nginx重定向到新的index.html首页。之后的操作因为拉取了新的html，后续拉取的css，js文件回归线上最新的版本。</br>

3. **总结就是：用户浏览器缓存了旧的html，部署过后使用的仍旧是就的html缓存导致异步加载的仍旧是旧的js，css文件。但是服务器旧的js文件已被删除，拉取不到被nginx重定向回html文件**

![alt](http://pzxbfjvwp.bkt.clouddn.com/FvQb0re3cRQ9JWY5h1jvdj6gsSts)
## 问题查找
知道了问题所在，那么接下来就是查找问题发生的条件。

![alt](http://pzxbfjvwp.bkt.clouddn.com/FvA8bzbsYMQZfTJmTmDO8KzRdaND)

查看html的response header发现cache-control被设置成了private e-tag被设置了，但是因为微信浏览器的尿性除非你明确的告诉微信走协商缓存（304）和禁止缓存，有时候会自己从本地拉取缓存使用而不是向服务器比对etag走协商缓存。只要入口文件html更新了，后续引入的js，css也会自动更新。所以说关键所在就是禁止入口文件缓存。

## 问题解决
因为打包后的静态文件是托管在nginx上的，所以可以再nginx配置上禁止入口文件html缓存，确保发版后用户重新进入页面拉取到html是最新的文件。

```nginx
    location ~ /(?<app>[^/]+) {
        index index.html;
        try_files $uri $uri/ /$app/index.html?$args;
        # 对于html文件添加Cache-Control的响应头
        # 强制客户端每次在加载html文件时都需要从服务器拉取入口文件html 不允许使用缓存
        # add_header Last-Modified $date_gmt;
        add_header Cache-Control 'no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0';
    }
```
nginx设置之后客户端相应的报文

![alt](http://pzxbfjvwp.bkt.clouddn.com/FkxcIoXPe3r5r5RNmL_58SIXA49z)

重新部署发现，每次刷新，html都是从服务器重新拉取而不是走协商缓存304或者memory cache直接拉取本地缓存，问题得到解决
![alt](http://pzxbfjvwp.bkt.clouddn.com/FpGPtW8UD_enK_dvtIf4AzzTk3Cl)
## 一些额外的思考
其实缓存只能解决部署部署前用户登陆过后续在登录拉取缓存的这么一种情况。试想这么一种情况：用户使用的过程中，我们进行了部署。那么只要当前用户不刷新，那么当前用户使用的人就是旧的html入口文件，依然会出问题</br>

回到现实，其实生产会出现回滚也不一定能够解决的情况，假设问题在之前的版本就已经出现了，所以这时候我们会出现可能在用户使用高峰的情况下进行部署的情况，最终达成结果是前端如何做到用户无感知的部署。</br>

从上面的分析可以得出，在部署前后的时间点会出现使用两种文件的用户。
1. 部署后重新登录拉取最新的html文件的用户


2. 部署前任然使用旧的html文件的用户

对于第1类的用户，从http缓存机制确保用户拉取的必须是最新的html文件，就能够解决。

但是对于第2类的用户，我们可以大概分析出，使用量大的时候总会出现仍处于旧入口html文件的用户，这些用户会因为出现加载不到旧的js文件而出现问题。因此只要旧的或者说上一版本的静态文件和最新的静态文件同时存在服务器的话，自然而然就可以兼容这两种状态的用户。这种情况我大概想到有两种解决办法。

### 灰度部署以及新旧文件合并发版

1. **新旧文件合并发版**: 我们必须至少保留上一个版本的旧文件，也就是新版本的文件和旧版本的文件共存（至少保留一个版本）。**在打包的时候用新版本的文件合并覆盖旧版本的文件而不是把旧版本的文件删除**。即使处于用的是旧版本的html的用户依然能够拉取旧版本文件而不会报错，这个方案对于后端而言接口必须向前兼容。</br>

优点：简单方便，不用借助任何工具。 缺点：人肉合并覆盖代码，随着时间代码版本越来越多提交会越来越大。

2. **蓝绿部署**: 蓝绿部署技术是指同时维护两套相同的生产环境，我们可以称之为蓝色环境和绿色环境，而只有一个颜色的环境负责提供完整的服务，另一个环境则完全空闲。当我们需要部署新版本的服务时，我们先在空闲的环境进行部署和验证，当验证完毕后，通过操作路由将客户端流量切换至新版本的环境，而原先的环境则变为空闲环境，依次循环交替。

关于灰度部署和蓝绿部署等业界已有很多文章，这里不再赘述。
