
小程序的跨端方案可以分为三种： 

1. 编译时方案
2. 运行时方案
3. 编译时和运行时的结合方案

目前主流的是使用第三种方案（都是采用ast语法树）


对于vue dsl类似的跨域框架来说。

在编译的时候，可以通过把template模板或者css通过babel转换成相对应的ast语法树，在经过修改再转换成相对应的小程序代码即可。

### 编译时方案（旧版taro以及mpvue）
在编译的时候通过ast语法树分析template以及js语法结构，把template或者render函数转化为小程序使用的wxml语法模板

### 运行时方案（新版taro以及mpvue）
运行时方案，mpvue对于js会实例化一个vue实例并且去除掉patch（dom diff）的阶段函数。数据变化的时候进行setData来触发视图层的渲染。

对于taro来说也很相似。

### 最佳方案 运行时+编译时

不管是运行时还有编译时都无法很好的解决问题所在，所以市面上的跨端都是两者一起。

对于mpvue来说
1. 编译时。把模板以及css编译成对应的wxml以及wxss
2. 运行时。实例化一个vue实例以及page实例，删除vue的patch方法（dom diff操作），在data修改的时候触发setData

对于taro来说。新版3.0基本完全运行时了。
 
自己写了一套react-dom类似的domapi库。运行时通过babel编译成虚拟dom的ast语法树结构。这样子能在运行时直接映射递归渲染为小程序的模板。

因为生成了虚拟dom的数节点。 类似于react的方式把渲染抽里程多个库，这样子就能不依托于某个react或者vue的类库。

如何理解双线程（浏览器也是双线程啊 渲染 以及js引擎）

浏览器中的渲染引擎与js线程是互斥的，两者只能唯一在执行。 这就会出现js执行时间过长导致页面卡顿的原因。  

在react层面通过时间分片以及优先级调度来解决这个问题。

在小程序中一样是两个线程，其中逻辑层的js逻辑更像是放在一个web worker中。两这宣城是可以同时执行的（这就是为什么逻辑层不提供直接操作dom的方法）。  

渲染层和逻辑层的交互通过 event模式来进行交互通信
## 跨端技术的比较以及原理

### hybird混合开发

原生以及webview的混合开发注意一下两者之间的通信

#### js调用原生两种方法
1 url schema
通过创建一个iframe的形式，让原生进行拦截。其中传递的参数以及calback方法可以放到链接上

2. 原生注入方法，js端调用（兼容性有问题）

#### 原生调用js方法

1. 获取window上注册的方法直接调用
2. 通过弹窗进行拦截

### 微信小程序

本质上就是hybird 混合开发，微信小程序本质上就是一个webview。
通过双线程的技术实现来渲染：其中渲染层用webview进行渲染。逻辑层使用jscore来运行js代码。逻辑层与图层层的交互使用事件模型来通信
涉及到原生的一些方法就用到jsBridge来进行交互通信。



### electron
把nodejs环境以及chrome开源的浏览器内核一起进行打包，于是拥有了nodejs与h5的混合能力 
https://segmentfault.com/a/1190000019426512

### react-native 
通过react映射出虚拟dom数放在内存中，通过javascriptcore映射出原生控件树。一些原生的交互能力需要通过jsbridge来交互通信。 一些原生的交互操作本质上
就是通过c++代码的 MessageQueue 来进行通信 告诉原生渲染 请求等操作

缺点： 交互都是异步的，导致通信成本很高有延迟
其中jscore与原生之间还有一层影子线程进行通信，原生获取到虚拟dom的schema进行渲染

新版react-native 使用jsI来替代旧的bridge方案 大大的减少了通信的成本，同时通过jsi可以获取hostObject上的c++方法，允许原生与js直接进行感知通信
### fluter
语法 dart， 通过子集的高新更渲染引擎来渲染页面。也就是直接通过渲染引擎来渲染，不需要在中间加一层jsBridge层来进行通信。

flutter把安卓的整套渲染引擎搬过来自己做渲染，其中这个绘图引擎支持跨端渲染。原生只需要听canvas画布能力，flutter就能通过自己的渲染引擎进行画布渲染