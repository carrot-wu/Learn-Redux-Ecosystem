react的合成事件与原生事件

众所周知，react的事件其实是经过一层封装的 这些事件都是经过封装委托在document上，并且支持异步访问事件的属性（属性不支持）
SyntheticEvent是共享的。那就意味着在调用事件回调之后，SyntheticEvent对象将会被重用，并且所有属性会被置空。这是出于性能因素考虑的。 因此，您无法以异步方式访问事件
function onClick(event) {
  console.log(event); // => nullified object.
  console.log(event.type); // => "click"
  const eventType = event.type; // => "click"

  setTimeout(function() {
    console.log(event.type); // => null
    console.log(eventType); // => "click"
  }, 0);

  // Won't work. this.state.clickEvent will only contain null values.
  this.setState({clickEvent: event});

  // You can still export event properties.
  this.setState({eventType: event.type});
}
以及还有一个很特许的问题 就是涉及到原生以及合成事件的同时绑定
同时绑定原生事件以及合成事件 原生事件先执行再冒泡到合成事件
并且只要原生事件阻止冒泡那么合成事件方法并不会执行 因为合成事件是绑定到document上的

合成事件的阻止冒泡只会影响合成事件 原生事件并不会受到影响 因为原生事件的执行实在document上 除非你绑定在window上 因为window在document之上

合成事件的实现机制
在 React 底层，主要对合成事件做了两件事：事件委派和自动绑定。 1. 事件委派 在使用 React 事件前，一定要熟悉它的事件代理机制。它并不会把事件处理函数直接绑定到 真实的节点上，而是把所有事件绑定到结构的外层，使用一个统一的事件监听器，这个事件监 听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。当组件挂载或卸载时，只是 在这个统一的事件监听器上插入或删除一些对象；当事件发生时，首先被这个统一的事件监听器 处理，然后在映射里找到真正的事件处理函数并调用。这样做简化了事件处理和回收机制，效率 也有很大提升。
 2. 自动绑定 在 React 组件中，每个方法的上下文都会指向该组件的实例，即自动绑定 this 为当前组件。 而且 React 还会对这种引用进行缓存，以达到 CPU 和内存的优化。在使用 ES6 classes 或者纯 函数时，这种自动绑定就不复存在了，我们需要手动实现 this 的绑定


// 步骤
1. 触发 document注册原生事件的回调 dispatchEvent
2. 获取到触发这个事件最深一级的元素
3. 遍历这个元素的所有父元素，依次对每一级元素进行处理。
4. 构造合成事件。
5. 将每一级的合成事件存储在 eventQueue事件队列中。
6. 遍历 eventQueue。
7. 通过 isPropagationStopped判断当前事件是否执行了阻止冒泡方法。
8. 如果阻止了冒泡，停止遍历，否则通过 executeDispatch执行合成事件。
9. 释放处理完成的事件。

// 因为在当前task中 合成事件处理完了之后，合成事件对象会被释放掉。所以异步的方法并不能获取event对象

1. 触发document的dispatchEvent对象
2. 获取真正触发的event对象
3. 从当前元素开发向上遍历所有父元素，依次对每一集元素做处理
4. 构造合成事件
5. 从eventPlugin从根据事件类型获取响应的事件池，如果事件池是空的那么重新创建一个新的事件池。
6. 从listnerBank（eventPluginHub）中获取响应的回调函数（根据元素的nodeId 唯一标识key）
7. 合成事件其实就是返回带有合成事件参数的回调函数
8. 讲每一个元素构造的合成事件放进事件队列eventQueue中
9. 遍历事件队列eventQueue，判断当前事件是否禁止了冒泡行为 isPoStoppped 是的话退出循环
10. 释放合成事件对象（所以异步的方法并不能获取到合成事件对象上的属性, 如果需要获取的话需要在回调函数内部手动调用event.persist()）

https://juejin.cn/post/6909271104440205326

关键点主要分为两个阶段

1 事件注册
在初始化dom属性也就是props属性的阶段，编译props上的属性查找相关的事件函数，查找到相对应的原生事件函数。
判断当前的原生事件是否已经注册，注册直接返回没注册的话然后委托注册到document上，17之后是注册到container上。
document上原生事件注册的回调函数都是dispatchEvent回调。

总结
1.我们将所有事件类型都注册到 document 上。
2. 所有原生事件的 listener 都是dispatchEvent函数。
3. 同一个类型的事件 React 只会绑定一次原生事件，例如无论我们写了多少个onClick， 最终反应在 DOM 事件上只会有一个listener。

2. 事件触发
触发dispatchEvent函数,打开批量渲染函数开关，接下来主要做两件事

## 生成合成事件对象
1. 根据dispatchevent获取真正的时间对象
2. 根据真正的事件对象构造合成事件对象(这一步涉及到eventPlugin， 本质就是构造合成事件的方法)
（在react17之前还会判断当前事件池中是否有事件实例了有的话直接复用，因此17之前的合成事件对象在使用之后就会直接删除，只能用e.preseit）
3. 从当前组件实例开始冒泡，获取所有的相关事件的对象也进行合成事件的合并（click全部生成），之后就是捕获。

## 构建事件队列
1. 通过fiber对象取出注册的回调函数生成队列，合成事件对象也生成队列
2. 通过循环的方式进行触发执行传入合成事件对象，判断是否还要冒泡还要捕获。没有的话循环退出

