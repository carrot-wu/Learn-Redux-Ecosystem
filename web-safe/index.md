# XSS

## 什么是xss
Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。
> XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。

## xss的分类
根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种。

### 存储型 XSS
1. 攻击者将恶意代码提交到目标网站的数据库中。
2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等

### 反射性Xss
1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

### DOM 型 XSS
1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. 用户打开带有恶意代码的 URL。
3. 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

### 总结
简单说就是，存储型是通过输入（评论，私信）等形式把恶意代码保存在服务端，反射性和dom型是通过拼接恶意代码到url上进行攻击。

## xss的预防
从上面可以得到的是xss的攻击需要两个步骤：
1. 攻击者提交恶意代码。
2. 浏览器执行恶意代码。

### 输入过滤
首先确认的是服务端需要对客户端提交的数据进行转义，客户端对输入转义并没有用因为可以直接伪造请求。客户端能做的是，对服务端的内容做转义然后进行执行,同时对html进行转义。

### Content Security Policy
严格的 CSP 在 XSS 的防范中可以起到以下的作用：

1. 禁止加载外域代码，防止复杂的攻击逻辑。
2. 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。
3. 禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。
4. 禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。
5. 合理使用上报可以及时发现 XSS，利于尽快修复问题。

### 输入内容长度控制
对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度

### 对于一些敏感的内容以及操作做一些额外的安全处理
1. HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。
2. 验证码：防止脚本冒充用户提交危险操作。

# CSRF

## 什么是CSRF
CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。
一个典型的CSRF攻击有着如下的流程：

1. 受害者登录a.com，并保留了登录凭证（Cookie）。
2. 攻击者引诱受害者访问了b.com。
3. b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会…
4. a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。
5. a.com以受害者的名义执行了act=xx。
6. 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。

###  CSRF的特点
攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。
攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。
整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。
跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。

简单说就是XSS是通过注入恶意代码的形式执行一些代码，可以做任何操作，是在受害者的网站上进行。CSRF是在第三方网站，通过已经验证过的信息（只能使用，并不能获取）进行冒充请求。

## 防护策略
CSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性。
上文中讲了CSRF的两个特点：

1. CSRF（通常）发生在第三方域名。
2. CSRF攻击者不能获取到Cookie等信息，只是使用。

针对这两点，我们可以专门制定防护策略，如下：

1. 阻止不明外域的访问
 1. 同源检测 （通过refer禁止外域的请求，不靠谱，因为客户端可以伪造请求头）
 2. Samesite Cookie（敏感信息登录凭证，禁止不明域的访问）


2. 提交时要求附加本域才能获取的信息（因为CSRF不能获取本域的信息，所以可以再请求上添加只有本域才可以获取的信息比如token）
  1. CSRF Token
  2. 双重Cookie验证


### 同源检测
在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：
1. Origin Header
2. Referer Header
我们可以通过拒绝一些不是本域的域名进行拒绝请求，但是很重的一个问题是：**请求头是可以伪造的，所以对于被伪造的请求头并没有什么用**

### SameSite: cookie
防止CSRF攻击的办法已经有上面的预防措施。为了从源头上解决这个问题，Google起草了一份草案来改进HTTP协议，那就是为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax，下面分别讲解：

#### SameSite=strict
只能允许页面域名一模一样的情况下才能使用cookie，其他第三方都不能使用。连子域都不支持，只能域名一模一样的。

#### Samesite=Lax
可以设置一些域名带上cookie，默认的页面跳转也可以带上cookie，相比strict会送一些，但是post提交的表单还是不行。

### CSRF Token
前面讲到CSRF的另一个特征是，攻击者无法直接窃取到用户的信息（Cookie，Header，网站内容等），仅仅是冒用Cookie中的信息。

而CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，也可以防范CSRF的攻击。

一些常见的例子是token，验证码，以及密码操作。

#### 原理
CSRF Token的防护策略分为三个步骤：

1. 将CSRF Token输出到页面中(可以是接口返回，也可是验证码也可以是用户的密码)
2. 页面提交的请求携带这个Token
3. 服务器验证Token是否正确
