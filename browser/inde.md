>在阅读极客时间《浏览器工作原理与实践》中的学习笔记，好记性不如烂笔头。

## 进程与线程
现代浏览器以chrome为例都是多线程甚至是多进程的。⼀个进程就是⼀个程序的运⾏实例，一个进程中可以有多个线程同时存在。
1. 进程中的任意⼀线程执⾏出错，都会导致整个进程的崩溃。
2. 线程之间共享进程中的数据。
3. 当⼀个进程关闭之后，操作系统会回收进程所占⽤的内存。
4. 进程之间的内容相互隔离。
![alt](http://img.carrotwu.com/FtXbqYDnjMIvqMUnJ9zWUmJgBOjY)  

从图中可以看出，最新的Chrome浏览器包括：1个浏览器（Browser）主进程、1个 GPU 进程、1个⽹络（NetWork）进程、多个渲染进程和多个插件进程。  
1. 浏览器进程。主要负责界⾯显⽰、⽤⼾交互、⼦进程管理，同时提供存储等功能。
2. 渲染进程。核⼼任务是将 HTML、CSS 和 JavaScript 转换为⽤⼾可以与之交互的⽹⻚，排版引擎Blink和JavaScript引擎V8都是运⾏在该进程中，默认情况下，Chrome会为每个Tab标签创建⼀个渲染进程。出于安全考虑，渲染进程都是运⾏在沙箱模式下。
3. GPU进程。其实，Chrome刚开始发布的时候是没有GPU进程的。⽽GPU的使⽤初衷是为了实现3D CSS的效果，只是随后⽹⻚、Chrome的UI界⾯都选择采⽤GPU来绘制，这使得GPU成为浏览器普遍的需求。最后，Chrome在其多进程架构上也引⼊了GPU进程。
4. ⽹络进程。主要负责⻚⾯的⽹络资源加载，之前是作为⼀个模块运⾏在浏览器进程⾥⾯的，直⾄最近才独⽴出来，成为⼀个单独的进程。
5. 插件进程。主要是负责插件的运⾏，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和⻚⾯造成影响。

## 输入url之后发生的过程
1. 用户输入url，浏览器会进行判断是进行请求还是搜索内容，如果是搜索内容就会拼接上合理的协议http或者https把url请求丢给网络请求进程。
2. 网络进程接收到url，判断是否有缓存,如果有的话判断是强缓存还是写上缓存。如果是强缓存直接使用本地缓存，返回200状态码链接结束。如果是协商缓存或者没有缓存就要向服务器请求。（协商缓存头`cache-control` 属性值`no-store`禁止缓存, `no-cache`允许缓存但必须走协商缓存）
3. dns解析。判断是否有dns缓存，从浏览器缓存->本机host缓存->代理商缓存->根域名->顶级域名->二级域名开始直到找到服务器的ip地址。
4. 获取到服务器ip地址，发起http请求，如果是https的话还会建立ssl/tsl链接。在经过三次握手，交换syn，seq等三次数据包之后建立起http连接。
5. 客户端拼接请求头和请求体传输给客户端，其中是协商缓存的话客户端还会拼接`etag last-modified`等请求头。
6. 服务端接受到数据进行相应，拼接相应的响应头和响应状态码给服务端（其中304写上缓存允许使用缓存， 301永久重定向等等）。
7. 服务端根据需要可以选择返回`connection: close`经过四次挥手关闭http链接，或者使用`connection: keep-alive`保持长链接进行复用http。
8. 客户端根据返回的`content-type`相关类型进行相应的操作。
9. 接受到是html或者css文件会交给渲染进程进行渲染操作，开始下载相应的html或者css文件。
10. 边下载边解析，其中把html转化为`DomTree`，把css转化为`styleSheet`。两者解析完成会合并成`RenderTree`,其中遇到js文件时会进行堵塞dom节点的渲染执行。
11. 生成的`RenderTree`经过layout计算出每个节点的位置，不断进行回流重绘最终形成我们看到的页面。

## 减少回流重绘的方法
1. 通过style来一次性控制样式。
2. 批量合并多次修改style的操作为一次，减少回流。
3. 通过`createDocumentFragment`进行修改样式操作，之后一次性替换。
4. 使用`transfrom`等css属性进行样式修改。


### 使用transform能够优化的原因
![alt](http://img.carrotwu.com/Fp27Ux7CveG1KLc_oPfL6KxMcZMa)  

在上图中，我们使⽤了CSS的transform来实现动画效果，这可以避开重排和重绘阶段，直接在⾮主线程上执⾏合成动画操作。这样的效率是最⾼的，因为是在⾮主线程上合成，并没有占⽤主线程的资源，另外也避开了布局和绘制两个⼦阶段，所以相对于重绘和重排，合成能⼤⼤提升绘制效率。

## js的内存机制

### js是一门动态类型语言
![alt](http://img.carrotwu.com/FvMBL49C3nkr9vby3mL_5wCYDRVM)  

在声明变量之前需要先定义变量类型，我们把这种在使⽤之前就需要确认其变量数据类型的称为**静态语⾔**，相反地，我们把在运⾏过程中需要检查数据类型的语⾔称为**动态语⾔**。因此js其实是一门动态类型语言，所以在运行过程中，变量类型是可以发生变化的。另外，⽀持隐式类型转换的语⾔称为**弱类型语⾔**，不⽀持隐式类型转换的语⾔称为**强类型语⾔**，因为隐形转换的存在js也是一门弱类型语言。

### js的数据类型
![alt](http://img.carrotwu.com/Fr1FhjZa1z12jvaB44nKtJP64CVV)  

JavaScript中的数据类型⼀种有8种，它们分别是：  
其中，我们把除了object意外的其中类型称为原始类型，object对象称为引用类型，之所以把它们区分为两种不同的类型，是因为它们在内存中存放的位置不⼀样。

### 内存空间
![alt](http://img.carrotwu.com/FqQ0h1Xp1pc6Sl2rwlaKbwgM-53i)  

在`JavaScript`的执⾏过程中， 主要有三种类型内存空间，分别是代码空间、栈空间和堆空间。

### 栈空间和堆空间
原始类型的数据值都是直接保存在“栈”中的，引⽤类型的值是存放在“堆”中的，在栈空间中变量值只是保留了对象的引⽤地址而已。  
所以通常情况下，栈空间都不会设置太⼤，主要⽤来存放⼀些原始类型的⼩数据。⽽引⽤类型的数据占⽤的空间都⽐较⼤，所以这⼀类数据会被存放到堆中，堆空间很⼤，能存放很多⼤的数据，不过缺点是分配内存和回收内存都会占⽤⼀定的时间。  
在`JavaScript`中，赋值操作和其他语⾔有很⼤的不同，原始类型的赋值会完整复制变量值，⽽引⽤类型的赋值是复制引⽤地址。在`JavaScript`中将⼀个原始类型的变量a赋值给b，那么a和b会相互独⽴、互不影响；但
![alt](http://img.carrotwu.com/FssI3loGfd7AJ3vL6DjYMO3Ccl5D)  

是将引⽤类型的变量a赋值给变量b，那会导致a、b两个变量都同时指向了堆中的同⼀块数据。


## 垃圾回收策略
通常情况下，垃圾数据回收分为⼿动回收和⾃动回收两种策略。
1. 如`C/C++`就是使⽤⼿动回收策略，何时分配内存、何时销毁内存都是由代码控制的。
2. `JavaScript`、`Java`、`Python`等语⾔，产⽣的垃圾数据是由垃圾回收器来释放的，并不需要⼿动通过代码来释放。

### 调⽤栈中的数据是如何回收的
我们都知道，执行上下文是保存在栈中的，当⼀个函数可执行代码执⾏结束之后，`JavaScript`引擎会通过向下移动ESP来销毁该函数保存在栈中的执⾏上下⽂。

### 堆中的数据是如何回收的  
要回收堆中的垃圾数据，就需要⽤到`JavaScript`中的垃圾回收器

#### 代际假说和分代收集
代际假说有以下两个特点：  

1. 第⼀个是⼤部分对象在内存中存在的时间很短，简单来说，就是很多对象⼀经分配内存，很快就变得不可访问；
2. 第⼆个是不死的对象，会活得更久。  
所以，在V8中会把堆分为**新⽣代**和**⽼⽣代**两个区域，新⽣代中存放的是⽣存时间短的对象，⽼⽣代中存放的⽣存时间久的对象。  
1. 副垃圾回收器，主要负责新⽣代的垃圾回收。
2. 主垃圾回收器，主要负责⽼⽣代的垃圾回收。

### 垃圾回收器的⼯作流程
现在你知道了V8把堆分成两个区域⸺新⽣代和⽼⽣代，并分别使⽤两个不同的垃圾回收器。其实不论什么类型的垃圾回收器，它们都有⼀套共同的执⾏流程。  
1. 第⼀步是标记空间中活动对象和⾮活动对象。所谓活动对象就是还在使⽤的对象，⾮活动对象就是可以进⾏垃圾回收的对象。
2. 第⼆步是回收⾮活动对象所占据的内存。其实就是在所有的标记完成之后，统⼀清理内存中所有被标记为可回收的对象。
3. 第三步是做内存整理。⼀般来说，频繁回收对象后，内存中就会存在⼤量不连续空间，我们把这些不连续的内存空间称为内存碎⽚。当内存中出现了⼤量的内存碎⽚之后，如果需要分配较⼤连续内存的时候，就有可能出现内存不⾜的情况。

## 编译器和解释器：V8是如何执⾏⼀段JavaScript代码的？
要深⼊理解V8的⼯作原理，你需要搞清楚⼀些概念和原理，⽐如接下来我们要详细讲解的**编译器（Compiler）、解释器（Interpreter）、抽象语法树（AST）、字节码（Bytecode）、即时编译器（JIT）**等概念，都是你需要重点关注的。

### 编译器和解释器
编译型语⾔在程序执⾏之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的⼆进制⽂件，这样每次运⾏程序时，都可以直接运⾏该⼆进制⽂件，⽽不需要再次重新编译了。⽐如C/C++、GO等
都是编译型语⾔。  

⽽由解释型语⾔编写的程序，在每次运⾏时都需要通过解释器对程序进⾏动态解释和执⾏。⽐如`Python、JavaScript`等都属于解释型语⾔。
那编译器和解释器是如何“翻译”代码的呢？具体流程你可以参考下图：
![alt](http://img.carrotwu.com/FqiDl5rRNxPW9h4ibQ3QBtS9nzht)  


## V8是如何执⾏⼀段JavaScript代码的
![alt](http://img.carrotwu.com/FkSNKAfFh1V88-a8Xyqx8RFKtNiS)  

从图中可以清楚地看到，V8在执⾏过程中既有解释器`Ignition`，⼜有编译器`TurboFan`，那么它们是如何配合去执⾏⼀段`JavaScript`代码的呢? 下⾯我们就按照上图来⼀⼀分解其执⾏流程。
### ⽣成抽象语法树（AST）和执⾏上下⽂  
1. 第⼀阶段是分词（`tokenize`），⼜称为词法分析，其作⽤是将⼀⾏⾏的源码拆解成⼀个个`token`。所谓token，指的是语法上不可能再分的、最⼩的单个字符或字符串。你可以参考下图来更好地理解什么token。
![alt](http://img.carrotwu.com/FkmsIrXx6yGdyZ3fqSHOU3mie2uC)  

2. 第⼆阶段是解析（`parse`），⼜称为语法分析，其作⽤是将上⼀步⽣成的token数据，根据语法规则转为AST。

### 生成字节码
字节码就是介于AST和机器码之间的⼀种代码。但是与特定类型的机器码⽆关，字节码需要通过解释器将其转换为机器码后才能执⾏。v8最开始是没有生成字节码而是直接生成机器码的，但是因为手机内存太小执行效率不高的原因就转为了先编译成字节码。
![alt](http://img.carrotwu.com/FiAg3rbUP1AMxgwNPS7IsuYqwVvT)  

从图中可以看出，机器码所占⽤的空间远远超过了字节码，所以使⽤字节码可以减少系统的内存使⽤。

### 执行代码
问题： “V8执⾏时间越久，执⾏效率越⾼“  
通常，如果有⼀段第⼀次执⾏的字节码，解释器`Ignition`会逐条解释执⾏。在执⾏字节码的过程中，如果发现有热点代码`（HotSpot）`，⽐如⼀段代码被重复执⾏多次，这种就称为热点代码，那么后台的编译器`TurboFan`就会把该段热点的字节码编译为⾼效的机器码，然后当再次执⾏这段被优化的代码时，只需要执⾏编译后的机器码就可以了，这样就⼤⼤提升了代码的执⾏效率。
简单说就是随着执行时间越长，重复的代码（热点代码）就会直接北编译成机器码，跳过了字节码这个阶段。这个其实就是**即时编译（JIT）**技术的由来。
![alt](http://img.carrotwu.com/FkpZIFlPBJomkzumk1-sKHge7BOV)  

1. 解释器-分词解析成ast-是否为热点代码不是的话通过解析器解释器转化为字节码。
2. 编译器-如果是热点代码直接通过编译器转回为机器码。

## 消息队列和事件循环
浏览器⻚⾯是由消息队列和事件循环系统来驱动的。  

渲染主线程会频繁接收到来⾃于IO线程的⼀些任务，接收到这些任务之后，渲染进程就需要着⼿处理，⽐如接收到资源加载完成的消息后，渲染进程就要着⼿进⾏DOM解析了；接收到⿏标点击的消息后，渲染主线程就要开始执⾏相应的JavaScript脚本来处理该点击事件。  
### 事件循环
要想在线程运⾏过程中，能接收并执⾏新的任务，就需要采⽤事件循环机制。浏览器会在每次渲染完成之后，从消息队列中拿取所有任务依次执行。
### 消息队列
⼀个通⽤模式是使⽤消息队列。在解释如何实现之前，我们先说说什么是消息队列，可以参考下图：
![alt](http://img.carrotwu.com/Fkq2mTvPvZLj9wneEOLabDGZyatB)  

从图中可以看出，消息队列是⼀种数据结构，可以存放要执⾏的任务。它符合队列“**先进先出**”的特点，也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。

### 完整的渲染进程
![alt](http://img.carrotwu.com/Fm2sijKXQIuOM1k0Xyx_5rH2O6Tg)  

1. 消息队列用于保存需要执行的任务。
2. 渲染进程存在一个定时任务（时间循环），发现只有消息队列有任务就拿过来执行。
3. 另外的事件处理线程或者计时器线程在完成之后通过**IO线程**把回调插入消息队列中
4. 对于其他进程比如浏览器进程的点击或者网络进程，渲染进程专⻔有⼀个IO线程⽤来接收其他进程传进来的消息。

## 宏任务和微任务

### 宏任务
宏任务包括
1. 渲染事件（如解析DOM、计算布局、绘制）；
2. ⽤⼾交互事件（如⿏标点击、滚动⻚⾯、放⼤缩⼩等）；
3. JavaScript脚本执⾏事件；
4. ⽹络请求完成、⽂件读写完成事件。
5. 定时器setTimeout和setInterval
6. IO事件

### 微任务
**微任务就是⼀个需要异步执⾏的函数，执⾏时机是在主函数执⾏结束之后、当前宏任务结束之前。每次宏任务结束前都会去查询微任务队列，直到微任务队列为空，这时候会进行浏览器的渲染。**  
我们知道当JavaScript执⾏⼀段脚本的时候，V8会为其创建⼀个全局执⾏上下⽂，在创建全局执⾏上下⽂的同时，V8引擎也会在内部创建⼀个微任务队列。顾名思义，这个微任务队列就是⽤来存放微任务的，所以在浏览器把可执行代码推入栈的时候都会创建一个微任务队列。在现代浏览器⾥⾯，产⽣微任务有两种⽅式。  
1. 第⼀种⽅式是使⽤`MutationObserver`监控某个DOM节点，然后再通过JavaScript来修改这个节点，或者为这个节点添加、删除部分⼦节点，当DOM节点发⽣变化时，就会产⽣DOM变化记录的微任务。
2. 第⼆种⽅式是使⽤Promise，当调⽤`Promise.resolve()`或者`Promise.reject()`的时候，也会产⽣微任务。  
通常情况下，在当前宏任务中的JavaScript快执⾏完成时，也就在JavaScript引擎准备退出全局执⾏上下⽂并清空调⽤栈的时候，JavaScript引擎会检查全局执⾏上下⽂中的微任务队列，然后按照顺序执⾏队列中的
微任务。WHATWG把执⾏微任务的时间点称为**检查点**。当然除了在退出全局执⾏上下⽂式这个检查点之外，还有其他的检查点，不过不是太重要，这⾥就不做介绍了。  

如果在执⾏微任务的过程中，产⽣了新的微任务，同样会将该微任务添加到微任务队列中，**V8引擎⼀直循环执⾏微任务队列中的任务，直到队列为空才算执⾏结束。也就是说在执⾏微任务过程中产⽣的新的微任务并不会推迟到下个宏任务中执⾏，⽽是在当前的宏任务中继续执⾏**。
![alt](http://img.carrotwu.com/FrKYgE3Y1yu_gVnCpqd1OtsmIS0u)  

以上就是微任务的⼯作流程，从上⾯分析我们可以得出如下⼏个结论： 

1. 微任务和宏任务是绑定的，每个宏任务在执⾏时，会创建⾃⼰的微任务队列。
2. 微任务的执⾏时⻓会影响到当前宏任务的时⻓。
3. 在⼀个宏任务中，分别创建⼀个⽤于回调的宏任务和微任务，⽆论什么情况下，微任务都早于宏任务执⾏。

### 监听DOM变化⽅法演变MutationObserve
`MutationObserve`用来检测dom节点的变化，一旦dom节点发生变化就会触发相应的回调。相比于之前的发布观察者模式`Mutation Event`。`MutationObserver`将响应函数改成异步调⽤，可以不⽤在每次DOM变化都触发异步调⽤，⽽是等多次DOM变化后，⼀次触发异步调⽤，并且还会使⽤⼀个数据结构来记录这期间所有的DOM变化。这样即使频繁地操纵DOM，也不会对性能造成太⼤的影响。

## DOM树：JavaScript是如何影响DOM树构建的

### DOM树如何⽣成
在渲染引擎内部，有⼀个叫HTML解析器`（HTMLParser）`的模块，它的职责就是负责将HTML字节流转换为DOM结构。在浏览器边下载的时候，html解析器也会进行dom树的构建
![alt](http://img.carrotwu.com/FpaNPSO7Y89mdlH9NtwJWGtSiQXr)  

1. 通过分词器将字节流转换为`Token`。
2. ⾄于后续的第⼆个和第三个阶段是同步进⾏的，需要将Token解析为DOM节点，并将DOM节点添加到DOM树中。  

async和defer虽然都是异步的，不过还有⼀些差异，使⽤async标志的脚本⽂件⼀旦加载完成，会⽴即执⾏；⽽使⽤了defer标记的脚本⽂件，需要等到DOMContentLoaded事件之后执⾏。

>截取了一段精彩评论  
1. CSS不阻塞dom的生成。
2. CSS不阻塞js的加载，但是会阻塞js的执行。
3. js会阻塞dom的生成，也就是会阻塞页面的渲染，那么css也有可能会阻塞页面的渲染。
4. 如果把CSS放在文档的最后面加载执行，CSS不会阻塞DOM的生成，也不会阻塞JS，但是浏览器在解析完DOM后，要花费额外时间来解析CSS，而不是在解析DOM的时候，并行解析CSS。并且浏览器会先渲染出一个没有样式的页面，等CSS加载完后会再渲染成一个有样式的页面，页面会出现明显的闪动的现象。所以应该把CSS放在文档的头部，尽可能的提前加载CSS；把JS放在文档的尾部，这样JS也不会阻塞页面的渲染。CSS会和JS并行解析，CSS解析也尽可能的不去阻塞JS的执行，从而使页面尽快的渲染完成。

## 分层和合成机制：为什么CSS动画⽐JavaScript⾼效？

### 如何⽣成⼀帧图像
任意⼀帧的⽣成⽅式，有**回流、重绘和合成**三种⽅式。  
这三种⽅式的渲染路径是不同的，通常**渲染路径越⻓，⽣成图像花费的时间就越多**。⽐如重排，它需要重新根据`CSSOM`和`DOM`来计算布局树，这样⽣成⼀幅图⽚时，会让整个渲染流⽔线的每个阶段都执⾏⼀遍，如果布局复杂的话，就很难保证渲染的效率了。⽽重绘因为没有了重新布局的阶段，操作效率稍微⾼点，但是依然需要重新计算绘制信息，并触发绘制操作之后的⼀系列操作。  
相较于重排和重绘，合成操作的路径就显得⾮常短了，**并不需要触发布局和绘制两个阶段**，如果采⽤了`GPU`，那么合成的效率会⾮常⾼。

### 如何实现合成
为了提升每帧的渲染效率，Chrome引⼊了分层和合成的机制。那该怎么来理解分层和合成机制呢？  
将**素材分解为多个图层的操作就称为分层**，最后将这些图层**合并到⼀起**的操作就称为合成。所以，分层和合成通常是⼀起使⽤的。  
在Chrome的渲染流⽔线中，分层体现在⽣成布局树之后，渲染引擎会根据布局树的特点将其转换为层树`（Layer Tree）`，层树是渲染流⽔线后续流程的基础结构,所以合成是在回流和重绘后面，路径更加短。  
需要重点关注的是，合成操作是在合成线程上完成的，这也就意味着在执⾏合成操作时，是不会影响到主线程执⾏的。这就是为什么经常主线程卡住了，但是CSS动画依然能执⾏的原因。

### 为什么高效
1. 使用`css`动画时，浏览器会把当前元素单独设置为一个图层，该元素进行动画时，只会在当前图层进行修改。
2. 图层的渲染是在另外一个合成线程上进行的，并不会影响主线程。
3. 合成的操作是在回流和重绘之后（布局和绘制），渲染路径较短，不用重新生成布局树。

## PWA

### Web应⽤ VS 本地应⽤

那相对于本地应⽤，Web⻚⾯到底缺少了什么？  
1. ⾸先，Web应⽤缺少离线使⽤能⼒，在离线或者在弱⽹环境下基本上是⽆法使⽤的。⽽⽤⼾需要的是沉浸式的体验，在离线或者弱⽹环境下能够流畅地使⽤是⽤⼾对⼀个应⽤的基本要求。
2. 其次，Web应⽤还缺少了消息推送的能⼒，因为作为⼀个App⼚商，需要有将消息送达到应⽤的能⼒。
3. 最后，Web应⽤缺少⼀级⼊⼝，也就是将Web应⽤安装到桌⾯，在需要的时候直接从桌⾯打开Web应⽤，⽽不是每次都需要通过浏览器来打开。  
针对以上Web缺陷，`PWA`提出了两种解决⽅案：通过引⼊`Service Worker`来试着解决离线存储和消息推送的问题，通过引⼊`manifest.json`来解决⼀级⼊⼝的问题。

### Service Worker

`Service Worker`的主要思想是在**⻚⾯和⽹络之间增加⼀个拦截器，⽤来缓存和拦截请求**。整体结构如下图所⽰：
![alt](http://img.carrotwu.com/Fi1eaCrrZ9Ts7oXdztQrp53ANoDY)  

在没有安装`Service Worker`之前，WebApp都是直接通过⽹络模块来请求资源的。安装了`Service Worker`模块之后，`WebApp`请求资源时，会先通过`Service Worker`，让它判断是返回`Service Worker` 缓存的资源还是重新去⽹络请求资源。⼀切的控制权都交由`Service Worker`来处理。


## Web Components
`WebComponent`是⼀套技术的组合，具体涉及到了`Custom elements`（⾃定义元素）、`Shadow DOM`（影⼦DOM）和`HTML templates`（HTML模板）。  
1. ⾸先，**使⽤template属性来创建模板**。利⽤DOM可以查找到模板的内容，但是模板元素是不会被渲染到⻚⾯上的，也就是说DOM树中的template节点不会出现在布局树中，所以我们可以使⽤template来⾃定义⼀些基础的元素结构，这些基础的元素结构是可以被重复使⽤的。
2. 其次，我们需要创建⼀个GeekBang的类。查找模板内容；创建影⼦DOM；再将模板添加到影⼦DOM上。  
总之，通过影⼦DOM，我们就实现了CSS和元素的封装，在创建好封装影⼦DOM的类之后，我们就可以使⽤`customElements.define`来⾃定义元素了
```html
<!DOCTYPE html>
<html>
  <body>
    <!--
⼀：定义模板
⼆：定义内部CSS样式
三：定义JavaScript⾏为
-->
    <template id="geekbang-t">
      <style>
        p {
          background-color: brown;
          color: cornsilk;
        }
        div {
          width: 200px;
          background-color: bisque;
          border: 3px solid chocolate;
          border-radius: 10px;
        }
      </style>
      <div>
        <p>time.geekbang.org</p>
        <p>time1.geekbang.org</p>
      </div>
      <script>
        function foo() {
          console.log("inner log");
        }
      </script>
    </template>
    <script>
      class GeekBang extends HTMLElement {
        constructor() {
          super();
          //获取组件模板
          const content = document.querySelector("#geekbang-t").content;
          //创建影⼦DOM节点
          const shadowDOM = this.attachShadow({ mode: "open" });
          //将模板添加到影⼦DOM上
          shadowDOM.appendChild(content.cloneNode(true));
        }
      }
      customElements.define("geek-bang", GeekBang);
    </script>
    <geek-bang></geek-bang>
    <div>
      <p>time.geekbang.org</p>
      <p>time1.geekbang.org</p>
    </div>
    <geek-bang></geek-bang>
  </body>
</html>

```

## 同源策略
如果两个URL的**协议、域名和端⼝**都相同，我们就称这两个URL同源,因此只要三者中的一个不相同，我们就称为跨域。同源策略主要表现在DOM、Web数据和⽹络这三个层⾯。  
1. 第⼀个，DOM层⾯。同源策略限制了来⾃不同源的JavaScript脚本对当前DOM对象读和写的操作。
2. 第⼆个，数据层⾯。同源策略限制了不同源的站点读取当前站点的`Cookie、IndexDB、LocalStorage`等数据。
3. 第三个，⽹络层⾯。同源策略限制了通过`XMLHttpRequest`等⽅式将站点的数据发送给不同源的站点。

## 跨站脚本攻击（XSS）
`XSS`攻击是指⿊客往`HTML`⽂件中或者`DOM`中注⼊恶意脚本，从⽽在⽤⼾浏览⻚⾯时利⽤注⼊的恶意脚本对⽤⼾实施攻击的⼀种⼿段。
1. 存储型XSS攻击。⿊客利⽤站点漏洞将⼀段恶意`JavaScript`代码提交到⽹站的数据库中；然后⽤⼾向⽹站请求包含了恶意`JavaScript`脚本的⻚⾯；当⽤⼾浏览该⻚⾯的时候，恶意脚本就会将⽤⼾的`Cookie`信息等数据上传到服务器。
2. 反射型XSS攻击。在⼀个反射型`XSS`攻击过程中，恶意`JavaScript`脚本属于⽤⼾发送给⽹站请求中的⼀部分，随后⽹站⼜把恶意`JavaScript`脚本返回给⽤⼾。
3. 基于DOM的XSS攻击。基于DOM的XSS攻击是不牵涉到⻚⾯Web服务器的。具体来讲，⿊客通过各种⼿段将恶意脚本注⼊⽤⼾的⻚⾯中，⽐如通过⽹络劫持在⻚⾯传输过程中修改HTML⻚⾯的内容。

### 如何阻⽌XSS攻击
1. 服务器对输⼊脚本进⾏过滤或转码。  
不管是反射型还是存储型XSS攻击，我们都可以在服务器端将⼀些关键的字符进⾏转码,比如`<script>`。
2. 充分利⽤CSP。（同源策略）
3. 使⽤HttpOnly属性

## CSRF攻击：跨站请求伪造
简单来讲，`CSRF`攻击就是⿊客利⽤了⽤⼾的登录状态，并通过第三⽅的站点来做⼀些坏事。例如在浏览其他网站时，有个img标签，因为图片是没有同源策略的所以可以调用已经登陆过网站的接口，例如调用支付宝的转账接口。  
到这⾥，相信你已经知道什么是CSRF攻击了。和XSS不同的是，CSRF攻击不需要将恶意代码注⼊⽤⼾的⻚⾯，仅仅是利⽤服务器的漏洞和⽤⼾的登录状态来实施攻击。

### 如何防⽌CSRF攻击

#### 充分利⽤好Cookie 的 SameSite 属性
如果是从第三⽅站点发起的请求，那么需要浏览器禁⽌发送某些关键Cookie数据到服务器；如果是同⼀个站点发起的请求，那么就需要保证Cookie数据正常发送。  

**SameSite选项通常有Strict、Lax和None三个值**。
1. Strict最为严格。如果SameSite的值是Strict，那么浏览器会完全禁⽌第三⽅ Cookie。简⾔之，如果你从极客时间的⻚⾯中访问InfoQ的资源，⽽InfoQ的某些Cookie设置了SameSite = Strict的话，那么这些Cookie是不会被发送到InfoQ的服务器上的。只有你从InfoQ的站点去请求InfoQ的资源时，才会带上这些Cookie。
2. Lax相对宽松⼀点。在跨站点的情况下，从第三⽅站点的链接打开和从第三⽅站点提交Get⽅式的表单这两种⽅式都会携带Cookie。但如果在第三⽅站点中使⽤Post⽅法，或者通过img、iframe等标签加载的URL，这些场景都不会携带Cookie。
3. ⽽如果使⽤None的话，在任何情况下都会发送Cookie数据。

#### 验证请求的来源站点
`Referer`是HTTP请求头中的⼀个字段，记录了该HTTP请求的来源地址。但在服务器端验证请求头中的`Referer`并不是太可靠，因此标准委员会⼜制定了`Origin`属性，在⼀些重要的场合，⽐如通过`XMLHttpRequest、Fecth`发起跨站请求或者通过Post⽅法发送请求时，都会带上`Origin`属性
![alt](http://img.carrotwu.com/Fn1LnBcSti4O7H4BPYc0RoVxyelX)  

因此，服务器的策略是优先判断Origin，如果请求头中没有包含Origin属性，再根据实际情况判断是否使⽤Referer值。

#### CSRF Token
1. 在进行调用接口前，通过某种方法获取一串字符串，我们这里称为`token`。
2. 在进行调用接口时，必须带上`token`，后台进行检验。

