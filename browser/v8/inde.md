>在阅读极客时间《图解 Google V8》中的学习笔记，好记性不如烂笔头。

## V8 是怎么执行 JavaScript 代码的？
V8 并没有采用某种单一的技术，而是混合编译执行和解释执行这两种手段，我们把这种混合使用编译器和解释器的技术称为 JIT（Just In Time）技术。  

两种方法都各自有各自的优缺点，解释执行的启动速度快，但是执行时的速度慢，而编译执行的启动速度慢，但是执行时的速度快。V8 采用了一种权衡策略，在启动过程中采用了解释执行的策略，但是如果某段代码的执行频率超过一个值，那么 V8 就会采用优化编译器将其编译成执行效率更加高效的机器代码。你可以参考下面完整的 V8 执行 JavaScript 的流程图：  

---------------1-----------------------

### 主要流程
1. 初始化基础环境；
2. 解析源码生成 AST 和作用域；
3. 依据 AST 和作用域生成字节码；
4. 解释执行字节码；监听热点代码；
5. 优化热点代码为二进制的机器代码；
6. 反优化生成的二进制机器代码。

注意的是JavaScript 是一门动态语言，在运行过程中，某些被优化的结构可能会被 V8 动态修改了，这会导致之前被优化的代码失效，如果某块优化之后的代码失效了，那么编译器需要执行反优化操作。一般来说一些反优化的操作集中于类似：

1. 频繁修改或者删除新增类的属性（隐藏类）
2. 函数参数的不确定性（函数重载）

具体的优化措施可以见![文章][https://juejin.im/post/5dc4ccba6fb9a04a746f0ed3]


## js中对象的那些事

### 何为对象

js中的对象就是一对对属性与属性值的集合，从 JavaScript 语言的角度来看，JavaScript 对象像一个字典，字符串作为键名，任意对象可以作为键值，可以通过键名读写键值。  

而在 V8 实现对象存储时，并没有完全采用字典的存储方式，这主要是出于性能的考量。因为字典是非线性的数据结构，查询效率会低于线性的数据结构。

### 常规属性 (properties) 和排序属性 (element)

js中一直流传着这么一句话：js中对象属性的遍历并不会按顺序进行遍历。本质上就是因为js中对象的两个内置属性**常规属性 (properties) 和排序属性 (element)**
在声明定义时，我们先执行下面这么一段代码:

```js

function Foo() {
    this[100] = 'test-100'
    this[1] = 'test-1'
    this["B"] = 'bar-B'
    this[50] = 'test-50'
    this[9] =  'test-9'
    this[8] = 'test-8'
    this[3] = 'test-3'
    this[5] = 'test-5'
    this["A"] = 'bar-A'
    this["C"] = 'bar-C'
}
var bar = new Foo()

for(key in bar){
    console.log(`index:${key}  value:${bar[key]}`)
}
/*

index:1  value:test-1
index:3  value:test-3
index:5  value:test-5
index:8  value:test-8
index:9  value:test-9
index:50  value:test-50
index:100  value:test-100
index:B  value:bar-B
index:A  value:bar-A
index:C  value:bar-C
*/
```

可以看出的是对象的遍历并不会以变量添加的顺序进行遍历，但是有两点发现的是：
1. 设置的数字属性被最先打印出来了，并且是按照数字大小的顺序打印的；
2. 设置的字符串属性依然是按照之前的设置顺序打印的，比如我们是按照 B、A、C 的顺序设置的，打印出来依然是这个顺序。

之所以出现这样的结果，是因为在 ECMAScript 规范中定义了**数字属性应该按照索引值大小升序排列，字符串属性根据创建时的顺序升序排列**。

在这里我们把对象中的数字属性称为**排序属性**，在 V8 中被称为 elements，字符串属性就被称为**常规属性**，在 V8 中被称为 properties。在v8中每个对象内置了两个属性:elements保存的是排序属性；properties保存的是常规属性

---------2-------------------
如果执行索引操作，那么 V8 会先从 elements 属性中按照顺序读取所有的元素，然后再在 properties 属性中读取所有的元素，这样就完成一次索引操作。

### 对象内属性，快属性和慢属性

#### 对象内属性
对于需要频繁的获取对象属性，那么久需要先查询对应的常规属性（properties），再在对应的对象中获取到具体的属性，这样子每次查询都需要两步操作。  

V8 采取了一个权衡的策略以加快查找属性的效率，这个策略是将部分常规属性直接存储到对象本身（一般是十个之内），在获取这些属性的时候直接从对象上获取即可。**保存在对象本身上的常规属性我们称之为对象内属性**

#### 快属性
前面说的对于常规属性或者排序属性，如果这些属性是保存在线性结构中的我们就称之为快属性。因为在线性结构中我们只需要通过索引即可获取属性。

#### 慢属性

如果一个对象的属性过多时，就会转为话慢属性结构。慢属性的对象内部会有独立的非线性数据结构 (词典) 作为属性存储容器。所有的属性元信息不再是线性存储的，而是直接保存在属性字典中。因此对于频繁的创建或者删除元素时，慢属性的效率会比快属性高（快属性的创建或者删除都要移动相关属性的位置）

## 继承的那些事
不同的语言实现继承的方式是不同的，其中最典型的两种方式是**基于类的设计**和基于**原型继承**的设计，javascript是基于原型链的设计。要明白原型链必须先明白两个概念：

1. 每个对象都有一个内置的**原型属性__proto__**,__proto__指向的是该对象的**原型属性**
2. 每个函数都有一个原型属性**prototype**，prototype指向的是该函数的**原型对象**

## 延迟解析（惰性解析）

v8对js的执行分为两个阶段：
1. 编译：V8 将 JavaScript 代码转换为字节码或者二进制机器代码的阶段
2. 执行：执行阶段则是指解释器解释执行字节码，或者是 CPU 直接执行二进制机器代码的阶段  

在编译js的过程中，v8并不会一次性的把js转为字节码或者是机器码，主要是基于下面两点。
1. 有些js文件十分大，甚至达到10m。一次性的编译js代码会造成卡顿。增加用户的卡顿时间。
2. 编译完成的字节码或者机器码都会存于内存之中，一次性解析会占用大量内存。  

基于上面两个点，v8提出了**惰性解析**的编译方法:**解析器在解析的过程中，如果遇到函数声明，那么会跳过函数内部的代码，并不会为其生成 AST 和字节码，而仅仅生成顶层代码的 AST 和字节码。**

### 闭包中惰性解析的过程

在讲解前先前置化函数的三个特性：

1. 可以在 JavaScript 函数内部定义新的函数；
2. 内部函数中访问父函数中定义的变量；
3. 因为 JavaScript 中的函数是一等公民，所以函数可以作为另外一个函数的返回值。

假设有这么一段景点的闭包代码：
```js
function foo() {
    var d = 20
    return function inner(a, b) {
        const c = a + b + d
        return c
    }
}
const f = foo()
```
1. 当调用 foo 函数时，foo 函数会将它的内部函数 inner 返回给全局变量 f；
2. 然后 foo 函数执行结束，执行上下文被 V8 销毁；
3. 虽然 foo 函数的执行上下文被销毁了，但是依然存活的 inner 函数引用了 foo 函数作用域中的变量 d。

foo函数执行完成之后，foo函数的执行上下文就出栈了但是返回的inner函数内部使用到了变量d，因此这时候v8u的垃圾回收器并不能直接回收d变量。  

在执行 foo 函数的阶段，虽然采取了惰性解析，不会解析和执行 foo 函数中的 inner 函数，但是 V8 还是需要判断 inner 函数是否引用了 foo 函数中的变量，负责处理这个任务的模块叫做预解析器。

预解析器的作用：

1. 语法错误的判断，如果函数内部存在语法错误那么直接抛出错误；
2. 