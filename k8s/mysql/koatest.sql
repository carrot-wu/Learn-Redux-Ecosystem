/*
 Navicat Premium Data Transfer

 Source Server         : database
 Source Server Type    : MySQL
 Source Server Version : 80020
 Source Host           : 118.89.155.41:3306
 Source Schema         : koatest

 Target Server Type    : MySQL
 Target Server Version : 80020
 File Encoding         : 65001

 Date: 05/02/2021 17:52:51
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `abstract` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `access` int(0) NOT NULL DEFAULT 0,
  `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `isNature` int(0) NOT NULL DEFAULT 1,
  `tag` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `type` tinyint(0) NULL DEFAULT NULL,
  `createdStamp` datetime(0) NOT NULL,
  `updatedStamp` datetime(0) NOT NULL,
  `deletedStamp` datetime(0) NULL DEFAULT NULL,
  `imgSrc` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `author` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 41 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES (1, '在阅读源码的过程中我也翻阅了大量的资料。一般是先去看别人的源码分析完完整镇过的读一遍之后，看完了之后自己再把官网的clone下来自己再慢慢的阅读添加注释。希望大家在阅读完有感想之后也把官网源码clone下来不照着任何的资料边写注释边阅读完全部源码，这样子更有利于深刻理解。', 70, '## 前言\n\n>在阅读源码的过程中我也翻阅了大量的资料。一般是先去看别人的源码分析完完整镇过的读一遍之后，看完了之后自己再把官网的clone下来自己再慢慢的阅读添加注释。希望大家在阅读完有感想之后也把官网源码clone下来不照着任何的资料边写注释边阅读完全部源码，这样子更有利于深刻理解。\n\n**在工作中其实会经常使用到 redux 数据状态处理库，在一开始的使用中就一直听到说 reducer 必须是一个纯函数，不能有副作用!state 需要有一个默认值等等的约束。当然也踩过含有副作用修改了 state 造成视图层不更新的 bug(state 嵌套过深的锅。。。) 。一直停留在知其然不知其所以然的层次。想到彻底的掌握以及明白 redux 的原理的办法当然就是直接阅读源码啦。而且 redux 非常简洁才 2kb 而已= = 非常值得一读()**\n\n> 为了好方便理解 我会先从 redux 提供的 api 入手 一步一步的深入解读\n\n## redux 的基本使用\n\n```javascript\n//常用的三个api\nimport { createStore, combineReducers, applyMiddleware } from \"redux\";\n//中间件\nimport thunk from \"redux-thunk\";\nimport logger from \"redux-logger\";\nimport { userReducer } from \"./user/reducer\";\nimport { todoReducer } from \"./todo/reducer\";\n//combineReducers用于合并多个子reducer生成一个总的reducer\nconst reducers = combineReducers({\n  userStore: userReducer,\n  todoStore: todoReducer\n});\n//applyMiddleware使用中间件增强dispatch\nconst enhancer = applyMiddleware(thunk, logger);\n//createStore 创建一个 Redux store 来以存放应用中所有的 state\n// 应用中应有且仅有一个 store(react-redux有兼容多个store的写法，后面解读react-redux再说啦)\nconst store = createStore(reducers, null, enhancer);\n//返回的store其实是一个对象，上面提供了一些常用的方法\n// store.getState()用于获取store的state对象\nconsole.log(store.getState());\n// store.subscribe接受一个函数用于dispatch时执行\n// 注意 subscribe() 返回一个函数用来注销监听器\nconst unsubscribe = store.subscribe(() => console.log(store.getState()));\n// 发起一系列 action\nstore.dispatch(addTodo(\"Learn about actions\"));\n// 停止监听 state 更新\nunsubscribe();\nexport default store;\n```\n\n> 明白了 redux 的基本用法之后我们就可以深入源码啦\n\n上源码，为了减小篇幅，我删减了很多没用的代码（包括一些错误边界处理，其实很多错误边界处理都很有意思），如果想看完整的redux代码注释的话可以点击[**这里**](https://github.com/carrot-wu/Learn-Redux-Ecosystem \"Markdown\")。\n\n## createStore\n\n首先要明白的就是 redux 本质就是一个具有增强功能(中间件)的发布订阅函数 subscribe 就是订阅 dispatch 就是发布通知订阅者执行相应的回调</br>\ncreateStore 一开始会进行一系列的判断 判断是否传入了中间件（applyMiddleware（...）） 如果有的话直接返回 enhancer(createStore)(reducer, preloadedState) 没有的话继续执行下面的代码 声明了 dispatch subscribe getState replaceReudcer 这几个函数后直接进行返回\n\n```javascript\nexport default function createStore(reducer, preloadedState, enhancer) {\n  //首先createStore接受三个参数第一个是必须的reducer函数，第二个为state默认值（可传） 第三个enhancer为增强的中间件（可传，redux如此牛逼的原因）\n  if (typeof preloadedState === \'function\' && typeof enhancer === \'undefined\') {\n    //redux允许第二个参数直接传入中间件  判断第二个参数是否为函数 并且第三个参数为undefined（证明用户省略了state默认值，传入了第二个参数是中间件）\n    enhancer = preloadedState\n    preloadedState = undefined\n  }\n\n  if (typeof enhancer !== \'undefined\') {\n    //enhancer 必须是一个函数\n    if (typeof enhancer !== \'function\') {\n      throw new Error(\'Expected the enhancer to be a function.\')\n    }\n    //如果传入了中间件的话 那么就直接执行这个中间件函数 可查看applyMiddleware函数（为了方便理解我们先不看有中间件传入的createStore方法 跳过这里）\n    return enhancer(createStore)(reducer, preloadedState)\n  }\n    //reducer必须是函数\n  if (typeof reducer !== \'function\') {\n    throw new Error(\'Expected the reducer to be a function.\')\n  }\n ---------------------分隔符 下面都是不传入中间件执行的代码------------------------------------------\n  let currentReducer = reducer\n  let currentState = preloadedState\n  //订阅监听器的函数组\n  let currentListeners = []\n\n  //拷贝之前的监听器函数组\n  let nextListeners = currentListeners\n  //是否处于dispatch的标识符\n  let isDispatching = false\n\n  function ensureCanMutateNextListeners() {\n    //同步最新的监听器函数组  下面在订阅的时候会使用到\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice()\n    }\n  }\n  ...省略了dispatch subscribe getState replaceReudcer\n  return {\n    dispatch,\n    subscribe,\n    getState,\n    replaceReducer,\n  }\n}\n```\n\n## 获取 getState\n\n我们知道执行 store.getState()会把当前的存在 store state 对象返回出来 看源码 惊喜吧没错就是这么简单\n\n```javascript\nfunction getState() {\n  //直接了当的返回当前的state\n  return currentState;\n}\n```\n\n## 派发 dispatch\n\ndispatch 的作用就是传入一个 action 对象 根据传入的 action 对象之后执行相应的 reducer 函数重新计算新的 state 出来 计算完成之后执行 listeners 里面的订阅函数（也就是 subscribe 啦）\n**其中要注意的就是一些边界处理 比如 action 默认要有一个 type 属性 以及为什么 reducer 内部不能还有 dispatch 的操作 dispatch 触发 reducer reducer 又触发 dispatch ...堆栈溢出啦 大哥**\n\n```javascript\nfunction dispatch(action) {\n  //action必须是对象\n  if (!isPlainObject(action)) {\n    throw new Error(\n      \"Actions must be plain objects. \" +\n        \"Use custom middleware for async actions.\"\n    );\n  }\n  //action必须有一个type属性\n  if (typeof action.type === \"undefined\") {\n    throw new Error(\n      \'Actions may not have an undefined \"type\" property. \' +\n        \"Have you misspelled a constant?\"\n    );\n  }\n\n  //reducer内部不能有dispatch的操作 不然的话会进行循环调用\n  // 相当于 dispatch（） - reducer() - dispatch（）......\n  if (isDispatching) {\n    throw new Error(\"Reducers may not dispatch actions.\");\n  }\n\n  try {\n    //isDispatching置为true 说明已经处于dispatch状态了\n    isDispatching = true;\n    //执行reducer 获取state\n    currentState = currentReducer(currentState, action);\n  } finally {\n    //结束后置为false\n    isDispatching = false;\n  }\n  //这里的作用还是用于更新同步监听器\n  const listeners = (currentListeners = nextListeners);\n  //执行listeners里面的订阅函数\n  for (let i = 0; i < listeners.length; i++) {\n    const listener = listeners[i];\n    listener();\n  }\n\n  return action;\n}\n```\n\n## 订阅 subscribe\n\nsubscribe 就是添加订阅者的一个方法 执行完成之后返回的函数是解绑的方法 其中要注意的一点就是 ensureCanMutateNextListeners 方法的作用 至于为什么要使用两个监听器数组 nextListeners 和 currentListeners 就是为了同步循环中当前监听器数组和真实监听器数组的长度（防止绑定过程冲解绑造成索引值发生变化）\n\n```javascript\n// const unsubscribe = store.subscribe(() =>\n//   console.log(store.getState())\n// )\n//其中 执行后的返回值是注销监听器\nfunction subscribe(listener) {\n  //再推入新的订阅者前  先更新拷贝的监听器数组nextListeners\n  ensureCanMutateNextListeners();\n  nextListeners.push(listener);\n\n  return function unsubscribe() {\n    //删除之前再次更新拷贝的监听器数组nextListeners 确保当前的监听器函数是最新的\n    ensureCanMutateNextListeners();\n    /*ensureCanMutateNextListeners函数的作用就是更新同步当前最新的订阅器和当前的订阅器\n      * 使用currentListeners作为删除和添加的数组\n      * 就是比如我在订阅的函数中进行注销另外的监听器 类似于\n      * const unsubscribe1 = store.subscribe(() =>{})\n      * const unsubscribe2 = store.subscribe(() =>{ unsubscribe1() })\n      * const unsubscribe3 = store.subscribe(() =>{})\n      *  执行dispatch(action) 在循环的过程中\n      *for (let i = 0; i < listeners.length; i++) {\n      *  const listener = listeners[i];\n      *  listener(); 执行到unsubscribe2的过程中 listener的长度发生了变化减少了1 那么就会造成跳过下一个订阅\n      *}\n      * 所以需要拷贝一个真正的监听器函数组 每次进行解绑时  都把当前的监听器函数与最新的监听器函数进行同步\n      * 因为在订阅第二个函数的过程中 我进行了unsubscribe1的解绑操作\n      * 那么currentListeners数组的索引值也发生了改变 所以需要一个拷贝来真正同步真正的订阅器数组\n      * */\n    const index = nextListeners.indexOf(listener);\n    nextListeners.splice(index, 1);\n  };\n}\n//replaceReducer一般用于开发环境下的热更新\nfunction replaceReducer(nextReducer) {\n  if (typeof nextReducer !== \"function\") {\n    throw new Error(\"Expected the nextReducer to be a function.\");\n  }\n\n  currentReducer = nextReducer;\n  dispatch({ type: ActionTypes.REPLACE });\n}\n```\n\n## 总结\n总而言之 createStore 就是一个简单的发布订阅函数（applyMiddleware 用于增强这个函数）,接下来分析一波合成子 reducer 的 combineReducer 函数\n', 1, 'redux', 'redux源码浅析(1)', 1, '2019-10-21 10:16:50', '2020-11-05 20:34:20', NULL, 'http://img.carrotwu.com/Fm1y8yqF7WvHoRn-6PhDtmvT8vq-', NULL);
INSERT INTO `article` VALUES (2, '最开始我们分析 createStore 函数的源码，接下来还有一个 api 我们会经常使用到就是 combineReducer，用于把多个分模块的子 reducer 生成一个总的 reducer', 58, '# 前言\n\n>在阅读源码的过程中我也翻阅了大量的资料。一般是先去看别人的源码分析完完整镇过的读一遍之后，看完了之后自己再把官网的clone下来自己再慢慢的阅读添加注释。希望大家在阅读完有感想之后也把官网源码clone下来不照着任何的资料边写注释边阅读完全部源码，这样子更有利于深刻理解。\n\n\n**在工作中其实会经常使用到 redux 数据状态处理库，在一开始的使用中就一直听到说 reducer 必须是一个纯函数，不能有副作用!state 需要有一个默认值!等等的约束。当然也踩过含有副作用修改了 state 造成视图层不更新的 bug(state 嵌套过深的锅。。。) 一直停留在知其然不知其所以然的层次 想到彻底的掌握以及明白 redux 的原理的办法当然就是直接阅读源码啦 而且 redux 非常简洁才 2kb 而已= = 非常值得一读**\n\n> 最开始我们分析 createStore 函数的源码，接下来还有一个 api 我们会经常使用到就是 combineReducer，用于把多个分模块的子 reducer 生成一个总的 reducer\n\n# combineReducers 的基本使用\n\n```javascript\n//常用的三个api\nimport { createStore, combineReducers, applyMiddleware } from \"redux\";\n\nimport { userReducer } from \"./user/reducer\";\nimport { todoReducer } from \"./todo/reducer\";\n//combineReducers用于合并多个子reducer生成一个总的reducer\nconst reducers = combineReducers({\n  userStore: userReducer,\n  todoStore: todoReducer\n});\n```\n\n> 明白了 combineReducers 的基本用法之后我们就可以深入源码啦\n\n上源码，为了减小篇幅，我删减了很多没用的代码（包括一些错误边界处理，其实很多错误边界处理都很有意思），如果想看完整的redux代码注释的话可以点击[**这里**](https://github.com/carrot-wu/Learn-Redux-Ecosystem \"Markdown\")。\n\n# combineReducers\n\n通过源码 我们可以看到 combineReducers 其实接受要合并的 reducer 对象 返回 combination 函数 其实 combination 还是一个 reducer dispatch（action）的时候 会依次调用子 reducer 计算出子 reducer 的 state 值再而合并成对象。\n\n- **combineReducers 一开始会循环所有的子 reducer 筛选出可用的 reducer(state 不能为 underfined 子 reducer 在 redux 内部自定义 action 的时候必须返回默认值 state)并且生成真正可用的 finalReducers**\n- **dispatch（action）的时候 会循环所有的子 reducer 传入 action 依次生成新的子 state 值 之后浅比较之前的 state 和新生成的 state 如果浅比较不相同就把 hasChanged 赋值为 true 证明子 state 改变了自然而然总 state 也改变了**\n- **combination 在返回 state 值时会进行判断 判断当前的 hasChanged 是否为 true 是的话证明 state 发生了变化返回新的 state 不然 state 没有变化返回旧的 state 值**\n\n```javascript\nexport default function combineReducers(reducers) {\n  //获取所有子reducers的key值\n  const reducerKeys = Object.keys(reducers);\n  //筛选后可用的reducers\n  const finalReducers = {};\n  for (let i = 0; i < reducerKeys.length; i++) {\n    const key = reducerKeys[i];\n    /*\n    * 开发环境下下遍历所有子reducers的value值\n    * 如果value为undefined 抛出警告\n    * 即 combineReducers({a:aReducer,b:bReducer}) 中的aReducer 不能为underfined\n    * */\n    if (process.env.NODE_ENV !== \"production\") {\n      if (typeof reducers[key] === \"undefined\") {\n        warning(`No reducer provided for key \"${key}\"`);\n      }\n    }\n\n    //进行筛选 筛选出函数类型的reducer\n    if (typeof reducers[key] === \"function\") {\n      finalReducers[key] = reducers[key];\n    }\n  }\n  const finalReducerKeys = Object.keys(finalReducers);\n\n  let shapeAssertionError;\n  try {\n    //assertReducerShape是一个错误处理函数判断子reducer在传入一个非预定好的action时 是否会返回默认的state\n    assertReducerShape(finalReducers);\n  } catch (e) {\n    shapeAssertionError = e;\n  }\n\n  return function combination(state = {}, action) {\n    //state是否改变 这里判断state是否改变是通过浅比较的 所以才要求每次返回的state都是一个全新的对象\n    let hasChanged = false;\n    //新的state值 这里的state是根rootReducer的state\n    const nextState = {};\n    for (let i = 0; i < finalReducerKeys.length; i++) {\n      const key = finalReducerKeys[i];\n      //根据key值获取相当应的子reducer\n      const reducer = finalReducers[key];\n      //获取上一次当前key值所对应的state值 下面要进行浅比较\n      const previousStateForKey = state[key];\n      //获取传入action之后新生成的state值\n      const nextStateForKey = reducer(previousStateForKey, action);\n      if (typeof nextStateForKey === \"undefined\") {\n        const errorMessage = getUndefinedStateErrorMessage(key, action);\n        throw new Error(errorMessage);\n      }\n      //循环执行reducer 把新的值进行存储\n      nextState[key] = nextStateForKey;\n      //浅比较  这里把旧的子reducer state值 与传入action之后生成的state值进行浅比较 判断state是否改变了\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n    //根据判断赶回state   只要有一个子reducer hasChanged为true那么就重新返回新的nextState  所以这里揭示了为什么reducer必须是纯函数而且如果state改变了必须返回一个新的对象\n    //如果返回的是依然的state对象（有副作用的push，pop方法）如果state是对象 因为nextStateForKey !== previousStateForKey比较的是引用 那么 hasChanged认为是false没有发生改变 自然而然下面返回的state依然是旧的state\n    return hasChanged ? nextState : state;\n  };\n}\n\nfunction assertReducerShape(reducers) {\n  Object.keys(reducers).forEach(key => {\n    //遍历reducer\n    const reducer = reducers[key];\n    //先依次执行reducer 看是否有默认返回值state 其中ActionTypes.INIT为内部自定义的action 自然而然的执行到default 如果返回undefined 抛出错误 state要有默认值\n    const initialState = reducer(undefined, { type: ActionTypes.INIT });\n\n    if (typeof initialState === \"undefined\") {\n      throw new Error(\n        `Reducer \"${key}\" returned undefined during initialization. ` +\n          `If the state passed to the reducer is undefined, you must ` +\n          `explicitly return the initial state. The initial state may ` +\n          `not be undefined. If you don\'t want to set a value for this reducer, ` +\n          `you can use null instead of undefined.`\n      );\n    }\n    if (\n      typeof reducer(undefined, {\n        type: ActionTypes.PROBE_UNKNOWN_ACTION()\n      }) === \"undefined\"\n    ) {\n      throw new Error(\n        `Reducer \"${key}\" returned undefined when probed with a random type. ` +\n          `Don\'t try to handle ${\n            ActionTypes.INIT\n          } or other actions in \"redux/*\" ` +\n          `namespace. They are considered private. Instead, you must return the ` +\n          `current state for any unknown actions, unless it is undefined, ` +\n          `in which case you must return the initial state, regardless of the ` +\n          `action type. The initial state may not be undefined, but can be null.`\n      );\n    }\n  });\n}\n```\n# 总结\ncombineReducers的返回值实质上就是一个reducer函数，这个返回的reducer函数会把action传入各个子reducer中获取子state然后进行合并。', 1, 'redux', 'redux源码浅析（2）', 1, '2019-10-21 10:19:32', '2020-04-03 14:27:16', NULL, 'http://img.carrotwu.com/Fm1y8yqF7WvHoRn-6PhDtmvT8vq-', NULL);
INSERT INTO `article` VALUES (3, 'redux 本质就是一个具有增强功能(中间件)的发布订阅函数 而 applyMiddleware 实质上就承担了增强 redux 的作用', 97, '# 前言\n\n>在阅读源码的过程中我也翻阅了大量的资料。一般是先去看别人的源码分析完完整镇过的读一遍之后，看完了之后自己再把官网的clone下来自己再慢慢的阅读添加注释。希望大家在阅读完有感想之后也把官网源码clone下来不照着任何的资料边写注释边阅读完全部源码，这样子更有利于深刻理解。\n\n\n**在工作中其实会经常使用到 redux 数据状态处理库，在一开始的使用中就一直听到说 reducer 必须是一个纯函数，不能有副作用!state 需要有一个默认值!等等的约束。当然也踩过含有副作用修改了 state 造成视图层不更新的 bug(state 嵌套过深的锅。。。) 一直停留在知其然不知其所以然的层次 想到彻底的掌握以及明白 redux 的原理的办法当然就是直接阅读源码啦 而且 redux 非常简洁才 2kb 而已= = 非常值得一读**\n\n> redux 本质就是一个具有增强功能(中间件)的发布订阅函数 而 applyMiddleware 实质上就承担了增强 redux 的作用。\n\n# applyMiddleware 的基本使用\n\n```javascript\n//常用的三个api\nimport { createStore, combineReducers, applyMiddleware } from \"redux\";\n//中间件\nimport thunk from \"redux-thunk\";\nimport logger from \"redux-logger\";\n\n//applyMiddleware使用中间件增强dispatch\nconst enhancer = applyMiddleware(thunk, logger);\n//createStore 创建一个 Redux store 来以存放应用中所有的 state，应用中应有且仅有一个 store(react-redux有兼容多个store的写法，后面解读react-redux再说啦)\nconst store = createStore(reducers, null, enhancer);\nexport default store;\n```\n\n> 在讲解 applyMiddleware 函数之前有必要先理解 compose 的作用\n\n上源码，为了减小篇幅，我删减了很多没用的代码（包括一些错误边界处理，其实很多错误边界处理都很有意思），如果想看完整的 redux 代码注释的话可以点击[**这里**](https://github.com/carrot-wu/Learn-Redux-Ecosystem \"Markdown\")。\n\n# compose\n\n```javascript\nexport default function compose(...funcs) {\n  //如果没有传入中间件 直接把原始的store.dispatch函数返回出去\n  if (funcs.length === 0) {\n    return arg => arg;\n  }\n  //传入一个中间件 直接返回这个中间件函数\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n  //传入两个或两个以上的中间件时\n  //返回一个把传入的中间件数组从右到左依次执行的函数\n  return funcs.reduce((a, b) => (...args) => a(b(...args)));\n}\n```\n\ncompose 一开始会对传入的中间件数量进行判断 在两个或以上的中间件传入时会调用这么一个函数 funcs.reduce((a, b) => (...args) => a(b(...args))) 这就是 redux 中洋葱模型的具体实现啦 为了方便理解我们展开一下\n\n```javascript\n//b为循环中的当前中间件 a为循环中上一个中间件\nfuncs.reduce(function(a, b) {\n  return function(...args) {\n    //依次从右到左调用中间件 把右边的中间件的执行返回值作为参数传入下一个中间件中\n    const rightFunResult = b(...args);\n    return a(rightFunResult);\n  };\n});\n```\n\n这条展开的表达式其实就是一个高阶函数 返回值还是一个函数 这个函数接受的参数就是我们传入的中间件 从右到左依次调用中间件函数 并且把调用上一个中间件执行后的返回值当做参数传给下一个中间件 记住这个函数的作用之后我们接下来就可以看 applyMiddleware 函数了\n\n## applyMiddleware\n\n我们都知道要给 redux 添加中间件就必须传入 enhancer 这个参数 在复习一下用法把\n\n```javascript\nconst enhancer = applyMiddleware(thunk, logger);\nconst store = createStore(reducers, null, enhancer);\n```\n\n在传入了中间件的过程中 createStore 内部会进行判断 如果传入了 applyMiddleware 函数 redux 会调用 return enhancer(createStore)(reducer, preloadedState)这个函数 也就是 applyMiddleware(...中间件)(createStore)(reducer, preloadedState)\n\n```javascript\n//createStore源码\nexport default function createStore(reducer, preloadedState, enhancer) {\n  //首先createStore接受三个参数第一个是必须的reducer函数，第二个为state默认值（可传） 第三个enhancer为增强的中间件\n  if (typeof preloadedState === \'function\' && typeof enhancer === \'undefined\') {\n    //redux允许第二个参数直接传入中间件  判断第二个参数是否为函数 并且第三个参数为undefined（证明用户省略了state默认值，传入了第二个参数是中间件）\n    enhancer = preloadedState\n    preloadedState = undefined\n  }\n\n  if (typeof enhancer !== \'undefined\') {\n    //enhancer 必须是一个函数\n    if (typeof enhancer !== \'function\') {\n      throw new Error(\'Expected the enhancer to be a function.\')\n    }\n    //如果传入了中间件的话 那么就直接执行这个中间件函数\n    return enhancer(createStore)(reducer, preloadedState)\n  }\n  ...略\n```\n\n接下来直接看 applyMiddleware 的源码 其实源码行数不多\n\n```javascript\nexport default function applyMiddleware(...middlewares) {\n  return createStore => (...args) => {\n    //根据传入的reducer, preloadedState生成一个原始的store\n    const store = createStore(...args);\n    const middlewareAPI = {\n      getState: store.getState,\n      //这里的dispatch是原始的store dispatch 至于包多一层函数 是因为dispatch会传入每一个中间件中 要是不用函数包着的话 要是有一个中间件人为的修改了dispatch方法的引用 那么全部的中间件传入的dispatch也被修改了\n      dispatch: (...args) => dispatch(...args)\n    };\n    //执行每个中间件 生成闭包 传入middlewareAPI参数  这样子每个中间件都可以使用getState 和 dispatch方法\n    const chain = middlewares.map(middleware => middleware(middlewareAPI));\n    //compose方法 从右到左依次执行中间件的函数\n    /*\n    *  const chainFn = compose(...chain) 返回一个从右到左依次执行中间件的函数\n    *   dispatch = chainFn(store.dispatch) 执行这个返回的函数 传入store.dispatch函数\n    * */\n    dispatch = compose(...chain)(store.dispatch);\n\n    //这样子的dispatch就是增强过后的dispatch方法\n    return {\n      ...store,\n      dispatch\n    };\n  };\n}\n```\n\napplyMiddleware 一开始会通过原始的 createStore 方法生成一个没有改造过的 store 对象 然后对外暴露的 dispatch 方法其实是经过中间件改造的 dispatch。\n\n为了更好的理解 **const chain = middlewares.map(middleware => middleware(middlewareAPI))** 这里以及之后的代码 我先贴上 redux-thunk 中间件的源码(展开过后的)\n\n```javascript\nfunction reduxThunk(extraArgument) {\n  //applyMiddleware(reduxThunk()) 我们传入的中间件的其实是执行函数后下面返回的函数 在这里我把返回的函数直接当做中间件\n  return function({ dispatch, getState }) {\n    //{ dispatch, getState }为传入的middlewareAPI 再次返回一个函数\n    return function(next) {\n      //next参数为compose方法中 上一次传入的中间件经过改造后的 (next) => action =>{} 函数\n      return function(action) {\n        //最终返回的函数就是经过中间件改造的dispatch\n        if (typeof action === \"function\") {\n          return action(dispatch, getState, extraArgument);\n        }\n        return next(action);\n      };\n    };\n  };\n}\n```\n\n- reduxThunk 中间件接受一个对象，还记得上面的 **constchain = middlewares.map(middleware => middleware(middlewareAPI))** 吗，这里的{ dispatch, getState }就是传入执行的 middlewareAPI。\n- applyMiddleware 内部执行了一次传入的中间件并且传入了这个 middlewareAPI 对象，又返回了一个高阶函数 **const hoc = (next) => action =>{}** 。\n- **dispatch = compose(...chain)(store.dispatch)** 中的 store.disptch 就是最开始传入的 next 回调函数，执行完之后又返回一个函数 **(action) =>{ next(action) }** 。其中的 **next** 就是 store.dispatch。\n- 这个 **(action) =>{ next(action) }** 会当做回调函数再次传给左边的中间件的 next 参数，这个回调函数就变成左边中间件的 next。 就这样依次嵌套形成了洋葱模型。\n- 最终 export 出去 dispatch 就是经过中间件增强过后的 dispatch。在调用 dispatch 的过程中，传入的 action 会经过第一个中间件的 **(action) =>{ next(action) }** 方法，执行到 **next(action)** 的时候就会调用第二个中间件的回调函数，以此类推。reduxThunk 之所以能处理函数就是英文在 **next(action)** 前先判断了 action 的类型。如果是函数的话先调用传入的 action 函数并且把 **{dispatch, getState}** api 传入到了函数中。\n\n# 洋葱模型\n\n为了更好地理解 redux 中的洋葱模型，我决定先自定义两个很简单的中间件\n\n```javascript\nfunction firstMiddleware({ dispatch, getState }) {\n  return function(next) {\n    return function(action) {\n      console.log(\"进入-我是第一个中间件甲\");\n      //给action加上一点操作\n      action.text += \"-这是甲中间件干的\";\n      next(action);\n      console.log(\"退出-我是第二个中间件已\");\n    };\n  };\n}\n\nfunction secondMiddleware({ dispatch, getState }) {\n  return function(next) {\n    return function(action) {\n      console.log(\"进入-我是第二个中间件甲\");\n      action.text += \"-这是已中间件干的\";\n      next(action);\n      console.log(\"退出-我是第二个中间件已\");\n    };\n  };\n}\n//编写reducer\nfunction reducer(state = null, action) {\n  switch (action.type) {\n    case \"testAction\":\n      console.log(action.text)\n      return action.text;\n    default:\n      return state;\n  }\n}\nconst store = createStore(\n  reducer,\n  applyMiddleware(firstMiddleware,secondMiddleware)\n);\n\nstore.dispatch({ type: \'testAction\',text:\'测试action\' });\n\n```\n结果\n![alt](http://img.carrotwu.com/FtjjpRB7-xh3XsvSBR8Vfcj7-uPK)\n>如果图片挂了的话 直接看文字吧\n- 进入-我是第一个中间件甲\n- 进入-我是第二个中间件甲\n- 测试action-这是甲中间件干的-这是已中间件干的\n- 退出-我是第二个中间件已\n- 退出-我是第二个中间件已\n\n**可以看出，dispatch（action）的过程中回先执行第一个中间件的(action)=>{}方法，在遇到next(action)的时候，会执行下一个中间件的回调方法，依次调用直到穿过了所有的中间件。最后会把action返回给初始的store.dispatch(action)进行调用reducer函数，在这过程中只要保证最后传给store.dispatch的action是一个对象，在任意的中间件中你可以任意的调戏action。**\n\n**执行完reducer更新state之后因为最后一个中间件执行完next（action）回调函数之后，从右到左依次执行完next(action)下面的代码**\n\n**最终形成了 甲（进入）- 已（进入）.... - store.dispatch(action) - .... - 已(退出) - 甲(退出) 的流程**\n\n借一张网上的洋葱模型图就会更加清楚啦\n\n![alt](http://img.carrotwu.com/FqtsDCjsQh_k0jJurUHKG--R4I4q)\n\n# 最后\n终于分析完啦，大家应该对于redux会有更充分的了解。尤其是中间件这块，redux-thunk之所以能处理函数类型的action。(ps：顺便提一个问题，在看redux-logger中间件源码的过程中作者提到了redux-logger必须放在中间件数组的最后一个。为什么呢？如果你认真的看完了这篇文章应该大致就会懂了。)最后贴上项目的[**github链接**](https://github.com/carrot-wu/Learn-Redux-Ecosystem \"Markdown\")，上面会有redux完整源码以及更加详细的注释，如果这系列文章对您真的有能帮助的话不妨点个star？哈哈哈，谢谢各位老哥啦。（同目录下react-redux的源码注释也有，不过我发现要拆分成写文章的形式真的挺耗费时间的。哈哈哈哈哈哈哈，有空再更新吧）', 1, 'redux', 'redux源码解析（3）', 1, '2019-10-27 16:29:16', '2020-06-17 20:57:36', NULL, 'http://img.carrotwu.com/Fm1y8yqF7WvHoRn-6PhDtmvT8vq-', NULL);
INSERT INTO `article` VALUES (4, '前几天，前端发版在线上出现了问题。前端发版后过了一个小时，微信群反映极少部分用户出现了在购课车点击结算时原地刷新的效果，没有出现任何课程数据。但是在这操作之后，后续操作却回归正常。', 33, '## 前言\n\n>前几天，前端发版在线上出现了问题。前端发版后过了一个小时，微信群反映极少部分用户出现了在购课车点击结算时原地刷新的效果，没有出现任何课程数据。但是在这操作之后，后续操作却回归正常\n\n## 原因分析\n1. 第一时间我首先出现脑海的是不是上线的js代码出问题了，但是马上被否决了，因为看视频以及反馈。除了进入某个页面的原地刷新之后，后续的操作都可以正常进行。\n\n2. 经过一时间的排除，发现是**缓存问题**。猜测应该是部署过后，微信浏览器缓存了入口文件html, 造成部署完成之后旧的一些静态文件css,js被新部署的css，js文件替换，因为微信浏览器缓存了旧的html。旧的html文件拉取的依旧是旧的一些css,js文件。但是部分旧的css，js文件已被删除。浏览器拉取不到旧的文件被nginx重定向到新的index.html首页。之后的操作因为拉取了新的html，后续拉取的css，js文件回归线上最新的版本。</br>\n\n3. **总结就是：用户浏览器缓存了旧的html，部署过后使用的仍旧是就的html缓存导致异步加载的仍旧是旧的js，css文件。但是服务器旧的js文件已被删除，拉取不到被nginx重定向回html文件**\n\n![alt](http://img.carrotwu.com/FvQb0re3cRQ9JWY5h1jvdj6gsSts)\n## 问题查找\n知道了问题所在，那么接下来就是查找问题发生的条件。\n\n![alt](http://img.carrotwu.com/FvA8bzbsYMQZfTJmTmDO8KzRdaND)\n\n查看html的response header发现cache-control被设置成了private e-tag被设置了，但是因为微信浏览器的尿性除非你明确的告诉微信走协商缓存（304）和禁止缓存，有时候会自己从本地拉取缓存使用而不是向服务器比对etag走协商缓存。只要入口文件html更新了，后续引入的js，css也会自动更新。所以说关键所在就是禁止入口文件缓存。\n\n## 问题解决\n因为打包后的静态文件是托管在nginx上的，所以可以再nginx配置上禁止入口文件html缓存，确保发版后用户重新进入页面拉取到html是最新的文件。\n\n```nginx\n    location ~ /(?<app>[^/]+) {\n        index index.html;\n        try_files $uri $uri/ /$app/index.html?$args;\n        # 对于html文件添加Cache-Control的响应头\n        # 强制客户端每次在加载html文件时都需要从服务器拉取入口文件html 不允许使用缓存\n        # add_header Last-Modified $date_gmt;\n        add_header Cache-Control \'no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0\';\n    }\n```\nnginx设置之后客户端相应的报文\n\n![alt](http://img.carrotwu.com/FkxcIoXPe3r5r5RNmL_58SIXA49z)\n\n重新部署发现，每次刷新，html都是从服务器重新拉取而不是走协商缓存304或者memory cache直接拉取本地缓存，问题得到解决\n![alt](http://img.carrotwu.com/FpGPtW8UD_enK_dvtIf4AzzTk3Cl)\n## 一些额外的思考\n其实缓存只能解决部署部署前用户登陆过后续在登录拉取缓存的这么一种情况。试想这么一种情况：用户使用的过程中，我们进行了部署。那么只要当前用户不刷新，那么当前用户使用的人就是旧的html入口文件，依然会出问题</br>\n\n回到现实，其实生产会出现回滚也不一定能够解决的情况，假设问题在之前的版本就已经出现了，所以这时候我们会出现可能在用户使用高峰的情况下进行部署的情况，最终达成结果是前端如何做到用户无感知的部署。</br>\n\n从上面的分析可以得出，在部署前后的时间点会出现使用两种文件的用户。\n1. 部署后重新登录拉取最新的html文件的用户\n\n\n2. 部署前任然使用旧的html文件的用户\n\n对于第1类的用户，从http缓存机制确保用户拉取的必须是最新的html文件，就能够解决。\n\n但是对于第2类的用户，我们可以大概分析出，使用量大的时候总会出现仍处于旧入口html文件的用户，这些用户会因为出现加载不到旧的js文件而出现问题。因此只要旧的或者说上一版本的静态文件和最新的静态文件同时存在服务器的话，自然而然就可以兼容这两种状态的用户。这种情况我大概想到有两种解决办法。\n\n### 灰度部署以及新旧文件合并发版\n\n1. **新旧文件合并发版**: 我们必须至少保留上一个版本的旧文件，也就是新版本的文件和旧版本的文件共存（至少保留一个版本）。**在打包的时候用新版本的文件合并覆盖旧版本的文件而不是把旧版本的文件删除**。即使处于用的是旧版本的html的用户依然能够拉取旧版本文件而不会报错，这个方案对于后端而言接口必须向前兼容。</br>\n\n优点：简单方便，不用借助任何工具。 缺点：人肉合并覆盖代码，随着时间代码版本越来越多提交会越来越大。\n\n2. **蓝绿部署**: 蓝绿部署技术是指同时维护两套相同的生产环境，我们可以称之为蓝色环境和绿色环境，而只有一个颜色的环境负责提供完整的服务，另一个环境则完全空闲。当我们需要部署新版本的服务时，我们先在空闲的环境进行部署和验证，当验证完毕后，通过操作路由将客户端流量切换至新版本的环境，而原先的环境则变为空闲环境，依次循环交替。\n\n关于灰度部署和蓝绿部署等业界已有很多文章，这里不再赘述。', 1, 'javascript', '一次线上入口文件html被缓存的踩坑之旅以及反思', 1, '2019-11-08 15:49:10', '2020-09-16 19:22:19', NULL, 'http://img.carrotwu.com/FqXCCw0_L8uL5IWS0GHyyiQhRWbh', NULL);
INSERT INTO `article` VALUES (5, '收集的一些常用函数的实现代码，全手打！', 84, '## 函数抖动\n\n一定时间内连续触发事件不会执行\n```javascript\n/**\n *\n * @param fn 抖动函数\n * @param delay 延迟多少毫秒执行\n * @returns {Function}\n */\nvar debounce = function (fn, delay) {\n  //获取参入的参数\n  var _arguments = Array.prototype.slice.call(arguments, 2) \n  var timer = null\n  return function () {\n    var that = this\n    var fnArgs = _arguments.concat(Array.prototype.slice.call(arguments))\n    clearTimeout(timer)\n    timer = setTimeout(function () {\n      fn && fn.apply(that, fnArgs)\n    }, delay)\n  }\n}\n```\n\n## 函数节流\n\n```javascript\n/**\n * 按给定的时间延迟执行一次事件\n * @param fn 抖动函数\n * @param delay 延迟多少毫秒执行\n * @returns {Function}\n */\nvar throttle = function (fn, delay) {\n   //获取参入的参数\n  var _arguments = Array.prototype.slice.call(arguments, 2)\n  var timer = null\n  return function () {\n    var that = this\n    var fnArgs = _arguments.concat(Array.prototype.slice.call(arguments))\n    if (timer) return false\n    timer = setTimeout(function () {\n      fn && fn.apply(that, fnArgs)\n    }, delay)\n\n  }\n}\n```\n\n## apply和call的模拟实现\n\n```javascript\n/**\n * apply的模拟实现， call类似\n * @param context 被修改的this指向\n * @param args 传入的参数\n * @returns {*}\n */\n\n// 原理其实是用过隐形绑定 对象调用的方法来设置this的指向\n// 所以要把传入的this设置为对象这样子进行调用\nFunction.prototype.myApply = function (context, args = []) {\n  //注意的是如果传入的是undefined或者null 都是不绑定this 用自身的this\n  let targetContext = (context === void 0 || context === \'null\') ? this : context\n  targetContext = new Object(targetContext)\n  //设置对象 这里为了防止使用对象的key值 可以使用symbol\n  const targetKey = \'___keys___\'\n  targetContext[targetKey] = this\n  const result = targetContext[targetKey](...args)\n  delete targetContext[targetKey]\n  return result\n}\n```\n\n## bind的模拟实现\n```javascript\n//var a = b.bind(this,参数)\n/**\n *  bind的模拟实现\n * @param context 修改的this执行\n * @returns {function(): *}\n */\nFunction.prototype.myBind = function (context) {\n  //这里的this就是b函数\n  var that = this\n  var _args = Array.prototype.slice.call(arguments, 1)\n  var _fun = function () {\n    var args = _args.concat(Array.prototype.slice.call(arguments))\n    return that.apply(this instanceof _fun ? this : context, args)\n    //判断当前函数里的this是否为当前函数的实例\n  }\n  return _fun\n}\n\n```\n\n## new的模拟实现\n```javascript\n// new 的模拟实现\n// var a = b.MyNew(参数)\n/**\n *\n * @returns {*}\n * @constructor 返回的实例\n */\nObject.prototype.MyNew = function () {\n  var obj = {}\n  obj.__proto__ = this.prototype\n  var result = this.apply(obj, Array.prototype.slice.call(arguments))\n  return typeof result === \'object\' ? result : obj\n}\n```\n\n## 数组扁平化\n```javascript\n//数组扁平化\nArray.prototype.flatten = function () {\n  return this.reduce(function (prev, cur) {\n    if (Array.isArray(cur)) {\n      prev = prev.concat(cur.flatten())\n    } else {\n      prev.push(cur)\n    }\n    return prev\n  }, [])\n}\nconsole.log([1, 2, 3, [122, 12, [12], [4, 5, 6]], [12, [13, [14]]]].flatten())\n\n```\n\n## 函数柯丽化\n```javascript\n//函数柯丽化\n/**\n *\n * @param fn 需要柯丽化的函数\n * @param setArray 传参数组集合\n * @returns {Function}\n */\nfunction curry (fn, setArray) {\n  var _setArray = setArray || []\n  if (!Array.isArray(_setArray)) {\n    throw new Error(\'参数必须为数组\')\n  }\n  var length = fn.length\n  return function () {\n    var _args = _setArray.concat(Array.prototype.slice.call(arguments))\n    if (_args.length >= length) {\n      return fn.apply(this, _args)\n    } else {\n      return curry(fn, _args)\n    }\n  }\n}\n\nvar add = function (a, b, c) {\n  return a + b + c\n}\nvar curryAdd = curry(add)\nconsole.log(curryAdd(1)(2)(3))\nconsole.log(curryAdd(1, 2)(3))\nconsole.log(curryAdd(1, 2))\n\n```\n## compose方法\n\n```javascript\n// compose 方法 摘自redux中的源码\n/**\n *\n * @param fns 需要依次执行的函数数组\n * @returns {*|(function(*): *)} 返回执行compose的函数\n */\nfunction compose (...fns) {\n  if (fns.length === 0) {\n    return args => args\n  }\n  if (fns.length === 1) {\n    return fns[0]\n  }\n  return fns.reduce((prev, cur) => {\n    return (...args) => {\n      const rightResult = prev(...args)\n      return cur(rightResult)\n    }\n  })\n  // return fns.reduce((prev, cur) => (...args) => prev(cur(...args)))\n}\n/*\n// 如果设置中间件的话 传入的函数必须为这样的格式\n\nfunction createMiddleware(text) {\n  return function middleware(next) {\n    // next 为上一个中间的执行回调返回的函数\n    // 这里是中间件的初始执行\n    // 就是洋葱进入的过程\n    console.log(`${text}我进来啦hhhh`)\n    // 其中返回的函数就是回调函数\n    return function(args) {\n      // 这里是洋葱模型返回出去的执行过程\n      // 调用next的话 就是调用上一层中间的回调return方法\n      console.log(`${text}我出去啦 hhhhhh`)\n      return next()\n    }\n  }\n}\n// 如果要做中间件 还得把第一个函数进行处理 一般可以直接放进去compose内部\nconst firstMiddleware = function(next){\n  return next()\n}\nconst middlewre1 = createMiddleware(\'1111\')\nconst middlewre2 = createMiddleware(\'2222\')\nconst testCompose = compose( middlewre1, middlewre2,firstMiddleware)\ntestCompose(() => {console.log(\'first\')})\n*/\n```\n\n## 原生图片懒加载方法\n```javascript\n//懒加载\n/**\n * 原生懒加载效果\n * @param selector 需要懒加载的图片类名\n * @param distance 距离底部多少距离是进行加载图片\n */\nfunction lazyLoad (selector, distance = 50) {\n  const imgSelector = document.querySelectorAll(selector)\n  let num = 0\n  //这里的num作用是获知当前前num涨图片已经展示完毕了 不必要每次都重头开始展示\n  //获取屏幕高度\n  const windowHeight = window.innerHeight || document.documentElement.clientHeight\n\n  function _lazyLoad () {\n    for (let i = num; i < imgSelector.length; i++) {\n      //获取当前图片元素距离顶端的距离\n      let instance = windowHeight - imgSelector[i].getBoundingClientRect().top\n      if (instance >= distance) {\n        //展示图片\n        imgSelector.setAttribute(\'src\', imgSelector.getAttribute(\'data-src\'))\n        //当前图片已经展示完毕 跳转到下一张\n        num += 1\n      }\n    }\n  }\n  //这里可以添加节流\n  window.addEventListener(\'scroll\', throttle(_lazyLoad, 200), false)\n}\n```\n\n## 取数组最大值方法\n```javascript\n//取数组最大值\n/**\n * @param array 数组\n * @returns {number} 最大的数字\n */\nfunction getArrayMax (array) {\n  return Math.max.apply(null, array)\n}\n```\n\n\n## 遍历某个dom节点下的所有节点树\n```javascript\nconst _length = document.querySelectorAll(\'body *\').length\n\n// 给定节点 打印所有出现在的标签以及出现次数 使用的标签也可以显示出来 https://github.com/shiyangzhaoa/easy-tips/blob/master/tips/dom_depth.md\n/**\n *\n * @param node dom节点\n * @returns {{}|unknown} 返回的节点树对象\n */\nconst getEleObject = (node) => {\n  if (!node.children.length) {\n    return {}\n  }\n  return (function getDomTree (node, parentObject = {}) {\n    return Array.from(node.children).reduce((obj, cur) => {\n      const eleKey = cur.tagName.toLowerCase()\n      obj[eleKey] = obj[eleKey] ? (++obj[eleKey]) : 1\n      return cur.children.length ? getDomTree(cur, obj) : obj\n    }, parentObject)\n  })(node)\n}\nconst body = document.querySelector(\'body\')\ngetEleObject(body)\n```\n\n## 求dom节点最深和最宽\n```javascript\n// 求dom节点的最深长度以及dom数的宽度 这里的方法是不加算字符串的深度的\nconst getDomDeep = (node) => {\n  let maxDeep = 0\n  let maxWidth = 0\n  if (!node.children.length) return { maxDeep, maxWidth }\n  function getLength (node, deep) {\n    deep += 1\n    Array.from(node.children).forEach(item => {\n      if (item.children.length) {\n        getLength(item, deep)\n      } else {\n        maxDeep = deep > maxDeep ? deep : maxDeep\n        maxWidth += 1\n      }\n    })\n  }\n  getLength(node, 0)\n  return { maxDeep, maxWidth }\n}\n\n```\n\n## 获取dom节点所有分支数\n```javascript\n/**\n * 获取dom节点的所有分支\n * @param node dom节点\n * @returns {[]|Array} 标签名分支数组\n */\nconst getDomTree = (node) => {\n  const treeArray = []\n  if (!node.children.length) return []\n  \n  function getDom (node, parentTagName) {\n    Array.from(node.children).forEach(childNode => {\n      const currentTreeTagName = `${parentTagName ? parentTagName : node.tagName.toLowerCase()}--${childNode.tagName.toLowerCase()}`\n      if (childNode.children.length) {\n        getDom(childNode, currentTreeTagName)\n      } else {\n        treeArray.push(currentTreeTagName)\n      }\n    })\n  }\n\n  getDom(node)\n  return treeArray\n}\n\n```\n\n## 数组乱序（错误版以及正确版）\n```javascript\n// 数组的乱序\n\nfunction arraySplit (array) {\n  return array.sort(() => Math.random() > 0.5)\n}\n// 上面的乱序其实是不准确的 因为在chrome中对于sort方法\n// 如果数组长度小于10 那么就用插入排序 不然就用快速排序\n// 对于插入排序或者快速排序 其实有可能一半的数值都不用进行比较就确定值了\n\n// 参考洗牌算法才是真正的乱序\nconst d = function (array) {\n  const length = array.length\n  // （i< length ） 也可以不过在最后一个数组时也只是替换自己而且 没必要\n  // 原理是从数组末尾开始 随机替换 包括自己到数组首的赋值\n  for (let i = 0; i < length - 1; i++) {\n    let index = Math.floor((length - i) * Math.random())\n    const cur = array[length - (i + 1)]\n    // 调换两值\n    array[length - (i + 1)] = array[index]\n    array[index] = cur\n  }\n  return array\n}\n```\n\n## 简易的深拷贝\n```javascript\n/**\n *\n * @param object 深拷贝对象\n * @returns {[]}\n */\nfunction deepCopy (object) {\n  var isObject = function (target) {\n    return (typeof (target) === \'object\' && object !== null)\n  }\n  var _returnObject = Array.isArray(object) ? [] : {}\n  if (!isObject(object)) {\n    throw new Error(\'深拷贝对象必须为数组或者对象哦\')\n  }\n  //遍历对象\n  for (var key in object) {\n    if (object.hasOwnProperty(key)) {\n      //如果key值是null的话 直接进行赋值\n      // 如果不做这一步的话会在上面直接返回一个false值\n      if (object[key] === null) {\n        _returnObject[key] = object[key]\n      } else if (isObject(object[key])) {\n        //递归调用自身\n        _returnObject[key] = deepCopy(object[key])\n      } else {\n        _returnObject[key] = object[key]\n      }\n    }\n  }\n  return _returnObject\n}\n\nvar test = [null, 2, [3, undefined, 5, [1]], { key: null, value: 2 }, \'123\', function () {console.log(2)}, false]\nvar testObject = deepCopy(test)\ntest[1] = \'test\'\ntest[2][0] = \'test\'\ntest[2][3].push(\'test\')\ntest[3].key = \'test\'\ntest[5] = \'1111\'\nconsole.log(testObject)\n```\n\n## lazyman\n```javascript\nclass LazyMan {\n  constructor (name) {\n    this.name = name\n    this.task = []\n    let consoleName = () => {\n      console.log(`i am lazyName ${this.name}`)\n      this.next()\n    }\n    this.task.push(consoleName)\n    setTimeout(() => {\n      console.log(\'start\')\n      this.next()\n    }, 0)\n  }\n\n  sleep (time) {\n    let _sleep = () => {\n      setTimeout(() => {\n        console.log(`${this.name} sleep ${time} alearady`)\n        this.next()\n      }, time * 1000)\n    }\n    this.task.push(_sleep)\n    return this\n  }\n\n  eat (data) {\n    let _eat = () => {\n      console.log(`${this.name}eat${data}`)\n      this.next()\n    }\n    this.task.push(_eat)\n    return this\n  }\n\n  next () {\n    //每次执行完一个任务获取下一个任务 并且去除一开始的任务\n    let nextTask = this.task.shift()\n    //console.log(nextTask)\n    nextTask && nextTask()\n  }\n}\n\nlet man = new LazyMan(\'wuhr\')\nman.sleep(0.5).eat(\'fan\').sleep(4).eat(\'zhopu\')\n\n```\n\n## 实现一个eventEmitter\n```javascript\n//实现一个eventEmitter\nclass EventEmitter {\n  constructor (maxLength = 10) {\n    this._events = Object.create(null)\n    this.maxLength = maxLength\n  }\n\n  addListners (type, cb) {\n    //判断是否已经添加了这个方法了 如若添加了的话必须放进去一个数组中 超过的话直接报错\n    if (this._events[type] && this._events[type].length === this.maxLength) throw new Error(`超出${this.maxLength}个监听事件限制啦`)\n    this._events[type] = this._events[type] ? [...this._events[type], cb] : [cb]\n  }\n\n  emitEvents (type, ...args) {\n    if (this._events[type]) {\n      this._events[type].forEach((listner) => {\n        listner.apply(this, args)\n      })\n    }\n  }\n\n  //监听一次 只触发一次就要删除\n  once (type, cb) {\n    //先绑定 在addListners的基础上调用之后就删除 重新声明一个函数\n    function onceListners (...args) {\n      cb && cb.apply(this, args)\n      //调用完成之后删除这个监听器\n      this.removeListner(type, onceListners)\n    }\n    this.addListners(type, onceListners)\n  }\n\n  removeListner (type, cb) {\n    const removeTarget = this._events[type]\n    if (removeTarget) {\n      //如果没传cb 说明全部删除\n      if (!cb) {\n        this._events[type] = []\n      }\n      this._events[type] = this._events[type].reduce((prev, cur) => {\n        if (cur !== cb) {\n          prev.push(cur)\n        }\n        return prev\n      }, [])\n    }\n  }\n\n  //设置最大监听数\n  setMaxListners (n = 10) {\n    this.maxmaxLength = n\n  }\n\n  static getInstance (maxLength = 10) {\n    if (eventEmitter._instance) {\n      return eventEmitter._instance\n    } else {\n      eventEmitter._instance = new eventEmitter(maxLength)\n      return eventEmitter._instance\n    }\n  }\n}\n\nconst _fn = function (data) {\n  console.log(\'once\' + data)\n}\nconst _test = eventEmitter.getInstance(3)\n_test.addListners(\'hhh\', function (data) {\n  console.log(\'hhh111\' + data, this._events)\n})\n_test.once(\'hhh1\', _fn)\n_test.addListners(\'hhh\', (data) => {\n  console.log(\'hhh222\' + data)\n})\n_test.emitEvents(\'hhh\', 123)\n_test.emitEvents(\'hhh1\', 123)\n```\n\n## promise 模拟实现\n```javascript\n// promise模拟实现 其实原理与发布订阅模式类似\nclass MyPromise {\n  constructor (executor) {\n    this.statusMap = {\n      resolve: \'resolve\',\n      pending: \'pending\',\n      reject: \'reject\'\n    }\n    this.status = this.statusMap.pending\n    // 实例多次的注册then函数\n    // p.then p.then 只要resolve 都会一并执行\n    this.resolveFnArray = []\n    this.rejectFnArray = []\n\n    function resolve (resolveValue) {\n      if (this.status === this.statusMap.pending) {\n        // 延迟调用 为了后面的then先收集回调函数\n        setTimeout(() => {\n          this.status = this.statusMap.resolve\n          this.resolveValue = resolveValue\n          this.resolveFnArray.forEach(resolveFn => resolveFn && resolveFn(resolveValue))\n        }, 0)\n      }\n    }\n\n    function reject (rejectValue) {\n      if (this.status === this.statusMap.pending) {\n        setTimeout(() => {\n          this.status = this.statusMap.reject\n          this.rejectValue = rejectValue\n          this.resolveFnArray.forEach(rejectFn => rejectFn && rejectFn(rejectValue))\n        }, 0)\n      }\n    }\n\n    executor(resolve, reject)\n  }\n\n  then (resolveFn, rejectFn) {\n    const { status, resolveValue, rejectValue, statusMap, resolveFnArray, rejectFnArray } = this\n    const { resolve, reject, pending } = statusMap\n    switch (status) {\n      case resolve :\n        resolveFn(resolveValue)\n        break\n      case reject :\n        rejectFn(rejectValue)\n        break\n      case pending :\n        resolveFnArray.push(resolveFn)\n        rejectFnArray.push(rejectFn)\n        break\n      default :\n    }\n    // p.then.then\n    // 最后需要返回一个promise实例 来实现链式调用的this\n    return this\n  }\n}\n```\n## 大数相加方法（只允许字符串）\n```javascript\n/**\n * 计算大数相加值\n * @param stringArray 大数数组\n * @returns {string}\n */\nfunction bigNumSum (...stringArray) {\n  if (stringArray.length === 1) {\n    return stringArray.join(\'\')\n  }\n\n  function getZero (length) {\n    return Array.from({ length }).fill(\'0\').join(\'\')\n  }\n\n  // 获取数组最大的位数长度\n  const maxStringLength = Math.max.apply(null, stringArray.map(stringNum => stringNum.length))\n  // 给数组平整位数\n  const fillStringArray = stringArray.map(stringNum => {\n    const fillLength = Math.abs(maxStringLength - stringNum.length)\n    return getZero(fillLength) + stringNum\n  })\n  console.log(maxStringLength)\n  // 处理完毕 接下来进行计算\n  // 用一个数组来保存 相加的位数\n  const totalArray = []\n  // 是否进一 大于10的话 默认为0\n  let isUpperOne = 0\n  // 获取index值的相加和\n  function getLengthResult (index) {\n    return fillStringArray.reduce((prev, cur) => prev + Number(cur[index]), 0)\n  }\n  for (let i = fillStringArray[0].length; i > 0; i--) {\n    // 求数组的相加值\n    const result = isUpperOne + getLengthResult(i - 1)\n    if (result >= 10) {\n      // 大于10 进位数 除以10 向下取整\n      isUpperOne = Math.floor(result / 10)\n    } else {\n      // 小于10\n      isUpperOne = 0\n    }\n    // 求余数\n    const pushResult = result >= 10 ? (result % 10) : result\n    totalArray.unshift(pushResult)\n  }\n  // 循环结束之后 对于首位的进为直接添加\n  isUpperOne > 0 && totalArray.unshift(isUpperOne)\n  return totalArray.join(\'\')\n}\n\nconst __test = bigNumSum(\'9111111111111119\', \'922222222222222222219\', \'9321111111113213119\', \'9213123123119\')\n```\n\n## 正则表达式获取url的query参数\n```javascript\n/*\n* 正则表达式获取url query\n*\n* */\nlet b = \'http:www.baidu.com/index?name=username&age=27&pwd=zbc|123@&likes=lol&likes=beautifull girl&c=&d=\'\nconst c = b.match(/([?&])([^?&#]+=[^&#]*)/g).reduce((obj, item) => {\n    const [key, value] = item.slice(1).split(\'=\')\n    const prevValue = obj[key]\n    obj[key] = prevValue ? (Array.isArray(prevValue) ? [...prevValue, value] : [value, prevValue]) : value\n    return obj\n  },\n  {}\n)\n```\n\n## 任务调度器（头条面试题）\n```javascript\n/* 任务调度器*/\nclass Scheduler {\n  constructor() {\n    this.schedulerArray = []\n    Promise.resolve().then(() => {\n      this.next()\n      this.next()\n    })\n  }\n  add(promiseCreator) {\n    return new Promise((resolve, reject) => {\n      const _promiseCreator = () => {\n        return promiseCreator().then(() => {\n          this.next()\n          resolve()\n        })\n      }\n      this.schedulerArray.push(_promiseCreator)\n    })\n\n  }\n  next(){\n    const nextScheduler = this.schedulerArray.shift()\n    nextScheduler && nextScheduler()\n  }\n  // ...\n}\n\nconst timeout = (time) => new Promise(resolve => {\n  setTimeout(resolve, time)\n})\n\nconst scheduler = new Scheduler()\nconst addTask = (time, order) => {\n  scheduler.add(() => timeout(time))\n    .then((...args) => console.log(args))\n}\n\naddTask(1000, \'1\')\naddTask(500, \'2\')\naddTask(300, \'3\')\naddTask(400, \'4\')\n```', 1, 'javascript', '常用函数代码实现合集（js版）', 1, '2019-11-08 18:33:12', '2021-01-15 10:11:30', NULL, 'http://img.carrotwu.com/FgsRzz1lq4r2KLUBWhAjd3cPWnA9', NULL);
INSERT INTO `article` VALUES (6, '最近在刷 冴羽 大大的JavaScript深入系列文章 很良心的文章，再看到第8章 JavaScript深入之执行上下文 的时候发现一个很有趣的题目', 52, '# 一次关于执行上下文的深入了解\n\n最近在刷 [冴羽](https://juejin.im/user/58e4b9b261ff4b006b3227f4) 大大的JavaScript深入系列文章 很良心的文章，再看到第8章 JavaScript深入之执行上下文 的时候发现一个很有趣的题目。\n\n这里做个笔记。把之前的内容串起来。。毕竟看文章不如自己写一遍心得，好记性不如烂笔头。。。\n以下的内容很多参考了 [冴羽](https://juejin.im/user/58e4b9b261ff4b006b3227f4) 大大的JavaScript深入系列文章 以及 九死蚕传人bo的[前端基础进阶目录](https://segmentfault.com/a/1190000012646488)\n \n![alt](http://img.carrotwu.com/FjBeMFzOYy14e31ZBRazqfPmmxE3)\n\n底下的一条评论吸引了我的眼光。。 ，checkscope已经出栈了，为啥子checkscope上下文入栈时创建的变量对象还能访问= =。。\n后面才想清楚是关于数据结构的问题。 执行上下文是保存在栈结构的。一般来说，执行上下文出栈，那么入栈的过程中创建的变量也会被回收= = 。。。后面才想到。\n可执行代码执行完了，执行上下文就出栈了，变量的回收基于垃圾回收机制，只有当变量没有再被引用的时候才会被回收。这是两种不同的数据结构问题。\n简单说就是执行上下文的出栈取决于可执行代码执行完了，变量的回收取决于垃圾回收机制，虽然变量是在执行上下文入栈的时候创建的，但是这是两码子关系。就好比：大明生了一个儿子小明，但是小明寄样在婆婆家(堆结构)，大明住在自己家（栈结构），大明家着火大明去世（出栈）并不会造成小明也跟着去世（被垃圾回收机制回收）\n![alt](http://img.carrotwu.com/FhAzSa66w8TvqtPDXYvfwZfUKZAW)\n \n　　两端代码看似结果一样，但是内在的执行上下文栈缺不一样。 这里尽量还原一下为啥是这种结果，个人心得。推荐小伙伴们直接去看原[链接](https://github.com/mqyqingfeng/Blog/issues/8)。\n## 数据结构：堆，栈，队列\n### 栈\n　　首先js中JavaScript的执行上下文沿用了栈结构，即我们经常说的执行上下文栈，栈是一个什么样的数据结构呢。简单说就是：先进后出，后进后出。就像高中时化学实验的量筒，假设往量筒中放入乒乓球的模型一样\n![alt](http://img.carrotwu.com/Fsy5tMo6or8GGxqTGeo_8dmU5Gln)\n　　一号球是最开始放进去的，5好球是最后放入的。但是如果要把所有球拿出来，那么就是5号球先拿出来，一号球最后。执行上下文栈就是这种结构。\n \n### 堆\n　　堆的结构类似于图书馆的藏书架子一样，书本整齐的放在书架上，你只需要知道相对应的书架行号和列号，那么就可以直接拿到这本书，类似于对象的数据格式一样 。js中的变量都以堆的形式放在内存中\n\n### 队列 \n　　队列的机构类似于人的消化系统一样。。先吃进去的东西先消化，后出的东西必须等前面吃的消化完了之后才能消化。总结就是：先进先出，后进后出。 js中事件的循环机制依托于队列结构。\n \n## 执行上下文\n竟然知道了执行上下文是以栈的结构存在的，那么执行上下文到底是啥。\n我们都知道js引擎是按顺序一行一行的去编译代码的，每当js引擎遇到可执行代码的时候就会创建一个执行上下文，可以理解为当前代码执行所处的环境。而这个可执行代码的环境分为三种\n\n1. 全局环境：JavaScript代码运行起来会首先进入该环境 (script标签)\n1. 函数环境：当函数被调用执行时，会进入当前函数中执行代码( fn() )\n1. eval（不建议使用，可忽略）\n\n　　这里注意一点。。。是函数调用的时候才会创建一个执行上下文 函数声明的时候并不会 \n　　当创建一个执行上下文的时候又会分两个步骤 1：创建阶段 2执行阶段\n\n#### 创建阶段干了三件事　　\n\n- 创建变量对象 （vo variable object）\n- 对this的赋值 （  这里说明了为啥this是在调用的时候确定值的，而不是函数声明的时候确定值得. 函数调用--创建上下文 -- this进行赋值 ）\n- 建立作用域链  (   作用域是在函数声明时候确定的  js的作用域是词法作用域 词法作用域 = 声明时就已经确定了 动态作用域 = 在调用的时候确定，类似于this的赋值= =  注意一下作用域链是作用域的嵌套关系确定的。。 老哥们去看大大们的文章吧= = 我也算是一点点懂 )\n\n 　　**其中变量对象的创建又干了三件事情 。。。为啥这么多事情**\n\n1. 建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。\n1. 检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。\n1. 检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。\n\n总结：函数声明优先于变量声明，函数声明会覆盖前面的声明，变量声明如果前面已经声明过了就跳过不会覆盖  （这里涉及到了声明提升的面试问题啦。。。）\n![alt](http://img.carrotwu.com/Fk2Jbsuxo7pZhe6NfiLcxT4SvaPK)\n\n举个栗子：<br>\n![alt](http://img.carrotwu.com/FgCJYE9xU6rRcFNdFa4KhI5JubMO)\n \n执行流程是这样滴 <br>\n![alt](http://img.carrotwu.com/FrJ5131YmVf8wP3LPzKFkFZNVlKQ)\n    巴拉巴拉创建完之后就进入到了执行阶段，当可执行代码全部执行完成当前执行上下文出栈，也就是说当函数内的代码执行完毕之后它就出栈释放了。ok 看一下最开始放的两端代码的执行上下文栈结构\n \n# 　代码分析\n\n1. 第一部分\n```javascript\n1 var scope = \"global scope\";\n2 function checkscope(){\n3     var scope = \"local scope\";\n4     function f(){\n5         return scope;\n6     }\n7     return f(); // 相当于 var _content = f() ; return _content 就是先执行f（） 然后把f（）执行后返回的scope 再一次返回出去\n8 }\n9 checkscope();\n10\n11 //执行上下文栈的情况\n12 /*  ECStack 栈结构\n13 *   1首先全局执行上下文global context 入栈在栈底      ---ECStack = [global context]\n14 *   2执行到底16行 checkscope函数调用执行 checkscope context 入栈  ---ECStack = [global context , checkscope context]\n15 *   3这时候进入第13行checkscope函数内部执行 遇到第17行 f（）函数调用 f context入栈 --- ECStack = [global context,checkscope context, f context]\n16 *   4进入f函数内部 执行到第16行 f函数可执行代码完成全部执行完毕出栈 --- ECStack = [global context,checkscope context]\n17 *   5这时候重新返回checkscope函数第18行 返回f函数执行完返回的scope  checkscope可执行代码完成全部执行完毕出栈 --- ECStack = [global context]\n18 *   6ok 这时候只剩下全局上下文。。 全局上下文只有在网页关闭的时候才出栈\n19 *\n20 */\n```\n \n\n2. 第二部分\n\n \n```javascript\nvar scope = \"global scope\";\nfunction checkscope(){\n    var scope = \"local scope\";\n    function f(){\n        return scope;\n    }\n    return f;\n}\ncheckscope()(); //相当于 var _test = checkscope() ;\n//  _test()\n\n//执行上下文栈的情况\n/*  ECStack 栈结构\n*   1首先全局执行上下文global context 入栈在栈底      ---ECStack = [global context]\n*\n*   2执行到底9行 checkscope函数调用执行 checkscope context 入栈  ---ECStack = [global context , checkscope context]\n*\n*   --------------------这里都与前面的第一段代码一样 ------------------------------------\n*\n*   3这时候进入第9行checkscope函数内部执行  执行到第7行全部代码执行完毕了 checkscope context出栈 ---ECStack = [global context] 。 但是因为返回了一个f函数的引用 虽*然出栈了，但是垃圾回收机制因为函数f的引用还在被占用（下面f函数会被调用） 没法进行回收形成闭包（相当于第九行的注释 ）\n*\n*   4 第九行第二个括号相当于第十行 f函数进行调用 f context 入栈 --- ECStack = [global context,f context] 。注意这里和上面第一部分代码的区别 checkscope已经出栈了\n*\n*   5 f函数可执行代码完成全部执行完毕出栈  --- ECStack = [global context]\n*\n*   6 ok 这时候只剩下全局上下文。。 全局上下文只有在网页关闭的时候才出栈\n*\n*/\n```\n\n这时候就回答了这个问题啦 第二部分的代码checkscope确实是出栈了 只是因为形成了闭包 返回了一个f函数的引用 垃圾回收机制无法进行回收  好咯 吃饭去咯\n　　**![alt](http://img.carrotwu.com/FhAzSa66w8TvqtPDXYvfwZfUKZAW)**\n', 1, 'javascript', '一次关于执行上下文的深入了解', 1, '2019-10-03 11:44:11', '2020-07-24 19:52:31', NULL, 'http://img.carrotwu.com/FizkvwHQSqAF3nn_2Snu_XFDe7Gr', NULL);
INSERT INTO `article` VALUES (7, '这篇文章是之前在团队里分享的，今天看了一篇hooks的文章才想起分享到掘金，因为写的很粗糙。有任何问题或者错误之处希望可以指出修改，谢谢啦.', 85, '>这篇文章是之前在团队里分享的，今天看了一篇hooks的文章才想起分享到掘金，因为写的很粗糙。有任何问题或者错误之处希望可以指出修改，谢谢啦\n\n# 目录\n\n- memo useMemo useCallback 区别\n- useCallback或者useEffect依赖项问题\n- react hooks的闭包陷阱（和依赖项问题可以合并讲）\n- useEffect和useLayoutEffect区别\n\n\n# memo useMemo useCallback\n\n- memo缓存组件\n\n```tsx\nimport * as React from \"react\";\nimport { memo } from \"react\";\ninterface IProps {\n  count: number;\n  handleClick: () => void;\n}\n\nconst Child: React.FC<IProps> = ({ count, handleClick }) => {\n  console.log(\"Child render\");\n  return <div onClick={handleClick}>{count}</div>;\n};\n\nexport default memo(Child);\n/* 通过浅比较props的形式 props相同的情况下不会触发重新渲染 */  \n```\n\n- useMemo缓存值（类似于vue中的computed属性）\n\n```jsx\nfunction doubleFn() {\n    return count * 2;\n  }\n  const clickFn = handleClick;\n  // 只要count不发生变化 每次重渲染直接返回上一次count*2的计算值，不会触发handleClick的重新执行\n  const doubleCount = useMemo(doubleFn, [count]);\n```\n\n**把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算**\n\n- useCallback缓存函数\n\n```jsx\nfunction handleClick() {\n    console.log(`handleCLick-count${count}`);\n  }\n  // 只要count不发生变化 每次返回都是上一次函数的引用\n  const clickFn = useCallback(handleClick, [count]);\n  ...\n  return (\n    // 常用来解决传入函数的引用每一次都不同而造成重渲染的性能问题\n    <Child count={doubleCount} handleClick={clickFn} />\n  )\n```\n\n**把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用**\n\n**总结：三者都是用来做性能优化的**\n\n[例子](https://codesandbox.io/s/blue-framework-2y8bf?fontsize=14)\n\n# react hoos闭包陷阱\n\n- [例子1](https://codesandbox.io/s/w2wxl3yo0l)\n- [例子2](https://codesandbox.io/s/91n5z8jo7r)\n\n\n\n```jsx\n// 第一次渲染\nfunction Counter() {\n  const count = 0; // Returned by useState()\n  // ...\n  <p>You clicked {count} times</p>\n  // ...\n}\n\n// 再次点击触发重新渲染\nfunction Counter() {\n  const count = 1; // Returned by useState()\n  // ...\n  <p>You clicked {count} times</p>\n  // ...\n}\n\n// 再次点击触发重新渲染\nfunction Counter() {\n  const count = 2; // Returned by useState()\n  // ...\n  <p>You clicked {count} times</p>\n  // ...\n}\n```\n\n**当我们更新状态的时候，React会重新渲染组件。每一次渲染都能拿到独立的count 状态，这个状态值是函数中的一个常量。每一次调用引起的渲染中，它包含的count值独立于其他渲染（闭包）**\n\n- 每一次 render 都会生成一个闭包，每个闭包都有自己的 state 和 props（**所以在异步函数中访问hooks的state值拿到的是当前的闭包值并不是最新的state值**）.\n- class 中可以用闭包模拟 hooks 的表现。hooks 中可以使用 ref 模拟 class 的表现(实例属性)。\n\n```jsx\n// class模拟hooks的闭包变现用一个变量保存当前值\n    const count = this.state.count;\n    setTimeout(() => {\n      console.log(`You clicked ${count} times`);\n    }, 3000);\n```\n\n\n## 解决办法\n\n- 添加count依赖 （性能问题：重复创建销毁定时器）\n\n```jsx\nuseEffect(() => {\n    const id = setInterval(() => {\n      setCount(count + 1);\n    }, 1000);\n    return () => clearInterval(id);\n    // 添加count依赖 缺点会重复生成销毁定时器影响性能\n  }, [count]);\n```\n\n- 换成updater方法 count => count + 1\n\n```jsx\nuseEffect(() => {\n    const id = setInterval(() => {\n      // set函数可以为一个函数(类似于setState) 参数为上一次的state值\n      setCount(count => count + 1);\n    }, 1000);\n    return () => clearInterval(id);\n  }, []);\n```\n\n- useReducer(ps dipatch也不用添加到依赖中)\n\n```jsx\nconst initialState = {count: 0};\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case \'increment\':\n      return {count: state.count + 1};\n    case \'decrement\':\n      return {count: state.count - 1};\n    default:\n      throw new Error();\n  }\n}\n\nfunction Counter() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  return (\n    <>\n      Count: {state.count}\n      <button onClick={() => dispatch({type: \'decrement\'})}>-</button>\n      <button onClick={() => dispatch({type: \'increment\'})}>+</button>\n    </>\n  );\n}\n```\n\n- useRef\n\n## 依赖项问题\n\n- 对于一些不依赖hook state变量的函数 可以提取到最外层作用域中(加不加都可以)\n- 对于依赖到hooks变量的 可以用useCallback包一层 添加依赖 或者把函数放进去useEffect中 然后在useEffect中添加依赖\n\n# useEffect和useLayoutEffect区别\n\n首先问个问题 useEffect执行时机是什么时候\n\n![alt](http://img.carrotwu.com/Fkhy3myRqKJ8wJCJUgmwYHHlC6eH)\n\n**渲染完成之后，其实useEffect是异步的，在渲染完成之后先解绑在重新调用effect回调**\n\n与 componentDidMount、componentDidUpdate 不同的是，在浏览器完成布局与绘制之后，传给 useEffect 的函数会延迟调用。这使得它适用于许多常见的副作用场景，比如如设置订阅和事件处理等情况，因此不应在函数中执行阻塞浏览器更新屏幕的操作。\n\n[例子](https://codesandbox.io/s/react-codesandbox-q8csq)\n\n```javascript\nconst intervalId = setInterval(() => {\n  setLapse(Date.now() - startTime)\n  // 如果时间设置较大时看不出问题，但是当设置足够小0毫秒时就会有问题了\n}, 0)\n```\n![alt](http://img.carrotwu.com/Fv9SPkzwgx57f0oVUU5An2c9FoCR)\n\n**先点击start 在直接点击clear会大概率发现时间并没有清零（眼尖的人可以见到先是变成0后有变成时间数，在window下较为明显）**\n\n## 原因\n\n**setInterval(fn,0)可以理解为在每一次宏任务中都插入fn，因为useEffect是在render之后异步执行的，所以在调用clearInterval前就已经插入了 setLapse(Date.now() - startTime) 这么一段逻辑**\n\n\n## 执行流程\n\n- (setRunning(false) setLapse(0))\n- render渲染\n- **_setLapse(Date.now() - startTime) 罪魁祸首_**\n- clearInterval\n- useEffect\n- render渲染\n\n造成在render渲染之后又setLapse当前的时间值，最后又多渲染了一次.\n\n## 解决办法\n\n**那么知道了罪魁祸首是谁，那么解决办法有两个**\n\n- 不让**setLapse(Date.now() - startTime)** 这一段执行  （在interval回调函数内层加上if(running)是否可行）\n\n```javascript\nconst intervalId = setInterval(() => {\n  // 加上这个判断如果为false状态 那么也不会执行下面的setLapse(Date.now() - startTime)\n  if(running) {\n    // 然而并不可行 因为hooks的闭包问题会导致 在当前定时器中running状态一直为true的\n    setLapse(Date.now() - startTime)\n  }\n}, 0)\n```\n\n- 在**setLapse(Date.now() - startTime)** 之前就清除定时器\n\n\n# useLayoutEffect\n\n这时候就需要用到useLayoutEffect了 useLayoutEffect会在渲染完整之后**同步**执行\n\n执行流程\n\n- (setRunning(false) setLapse(0))\n- render渲染\n- clearInterval\n- useEffect\n\n\n# 参考资料\n\n- [dan博客](https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/)\n- [react hooks获取数据](https://juejin.im/post/5d5cbf545188253f64390569)\n- [react深入系列](https://github.com/MuYunyun/blog/blob/master/React/React_Hooks%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97.md)\n- [jokcy大佬的闭包分析文章](https://juejin.im/post/5c8f436ff265da610e5ec22e)', 1, 'reactHooks,react', 'React hooks的性能优化以及闭包陷阱', 1, '2019-11-12 14:12:02', '2020-09-11 11:15:23', NULL, 'http://img.carrotwu.com/FnFfNrtqMVJu3_JSUTMJNmnIZhMC', NULL);
INSERT INTO `article` VALUES (8, '收集在学习深入浅出TypeScript：从基础知识到类型编程小册过程中所做的一些笔记，第1期为泛型约束,索引查询keyof,索引访问T[K],映射类型in。', 58, '>收集在学习`深入浅出TypeScript：从基础知识到类型编程`小册过程中所做的一些笔记，第1期为`泛型约束`,`索引查询keyof`,`索引访问T[K]`,`映射类型in`。\n## 泛型约束\n一般来说，传入的泛型可以任意定义。但是假设我们需要明确传入的泛型只能是固定几个类型的一种例如string | number，这时候就需要泛型约束。\n我们通过`<T extends xx>`的语法来约束传入的泛型。\n```ts\ntype NameType = string | number\n\ninterface Person1<T extends NameType> {\n  name:T;\n  age: number;\n}\n// 可行\nconst person1: Person1<string> = {\n  name: \'cxk\',\n  age: 12\n}\n// 可行\nconst person2: Person1<number> = {\n  name: 100,\n  age: 12\n}\n// 报错 约束泛型只能为string和number类型\nconst person3: Person1<boolean> = {\n  name: true,\n  age: 12\n}\n```\n![alt](http://img.carrotwu.com/Fn8Nibe3cBXgY7RBhdSd0nDJ-Ii8)\n## 索引类型查询操作符 keyof\ntypescript的keyof关键字，将一个**类型**映射为它所有成员名称的**联合类型**。注意是类型而不是具体值，所以keyof可以用于interface接口，type类型或者class类。返回的是一个联合类型。\n```ts\ninterface Person {\n    name: string;\n    age: number;\n    location: string;\n}\n// 返回Person对象成员名称\ntype K1 = keyof Person; // \"name\" | \"age\" | \"location\"\n// 返回数组对象成员名称\ntype K2 = keyof Person[];  // \"length\" | \"push\" | \"pop\" | \"concat\" | ...\n// 返回{ [x: string]: Person }对象成员名称， 也就是string\ntype K3 = keyof { [x: string]: Person };  // string\n```\n\n## 索引访问操作符 T[K]\n使用这么一种情况，我们需求需要获取的不是成员名称的联合类型，而不是成员对应的属性值类型的话那么该如何取呢。（按上面的Person的话，需求就是把Person的属性值类型全部获取出来 string | number）。\n\n这就需要索引访问符出场了，与 JavaScript 种访问属性值的操作类似，访问类型的操作符也是通过 [] 来访问的，即 T[K]。\n```ts\ninterface Person {\n  name: string;\n  age: number;\n  location: string;\n}\n// 返回Person对象成员名称\ntype K1 = keyof Person; // name\" | \"age\" | \"location\n// 获取Person成员对应属性值的类型\ntype kValue = Person[K1] // string | number \n```\n### 使用实例\n```javascript\n实现lodash的pick方法 获取给定一个对象内的值\nconst user = {\n    username: \'Jessica Lee\',\n    id: 460000201904141743,\n    token: \'460000201904141743\',\n    avatar: \'http://dummyimage.com/200x200\',\n    role: \'vip\'\n}\nconst res = pick(user, [\'id\', \'token\', \'role\'])\n// [\'460000201904141743\', \'460000201904141743\', \'vip\']\n```\nts实现\n```ts\nfunction pick<T, k extends keyof T>(obj:T, names: k[]): T[k][] {\n  return names.map(name => obj[name])\n}\n```\n这样子实现的pick在填写names也可以获得代码提示和检验\n![alt](http://img.carrotwu.com/FtDGxJyUufLVdWGxtUrnV63LFEwR)\n## 映射类型 in\n假设我们要把下面的User全部转化为可选参数`?:`，这时候就需要使用到映射类型。\n\n```ts\ninterface User {\n    username: string\n    id: number\n    token: string\n    avatar: string\n    role: string\n}\n```\n转化的本质是把`{key: value}` => 转化成`{key ?: value}`,因此问题转化成如何获取key和value。\n\n映射类型的语法是`[k in Keys]`\n1. 其中k是类型变量，依次绑定到每个属性上，对应每个属性名的类型。(或者说是联合类型中的某一个)\n2. Keys是**联合类型**，一组字符串属性名类型(type Keys = \'username\' | \'id\' ...)。\n\n获取具体属性值类型就可以通过索引操作表示为`T[K]`，把原有的参数转化为可选参数就可以表示为`[K in Keys]:T[k]`,其中Keys的属性名联合类型可以通过索引查询获取到`keyof T`。最终就可以写成`[K in keyof T] ?: T[K]`\n\n一步步的实现思维。\n1. 通过索引查询keyof获取User的属性名联合类型`keyof User`\n```ts\ntype Keys = keyof User // \'username\' | \'id\' ...\n```\n2. 通过映射类型映射属性名联合类型`[K in Keys]`,这一步也就是转化的key\n3. 获取转化的value，通过obj[key]的方法获取value。也就是User[k]\n4. 一步步带入，最终返回的新类型就是`{[K in keyof User]: User[K]}`\n5. User类型可以通过泛型T来替代`type Partial<T> = {[K in keyof T] ?: T[K] }`\n\n具体实现：\n```ts\ninterface Person3 {\n  name: string;\n  age: number;\n  location: string;\n}\n\ntype Partial<T> = {[K in keyof T] ?: T[K] }\ntype PersonPartial = Partial<Person3>\n\n```\n![alt](http://img.carrotwu.com/Fsvysj9Te-GBt1QoTWXHz23tMSyq)  \n\n同理，内置工具类型`Pick`,`Readonly`, `Required`也就不难实现出来啦。  \n\n```ts\ninterface Person4 {\n  name: string;\n  age: number;\n  location: string;\n}\n// Readonly用于将成员所有属性置为readonly，无法再次赋值\ntype MyReadonly<T> = {readonly [K in keyof T] : T[K] }\ntype PersonReadOnly = MyReadonly<Person4>\n/* \ntype PersonReadOnly = {\n    readonly name: string;\n    readonly age: number;\n    readonly location: string;\n}\n*/\n\n// Required用于将成员所有属性置为必填参数，与Partia相反\ntype MyRequired<T> = {[K in keyof T] -?: T[K]}\ntype PersonRequired = MyRequired<Person4>\n\n// Pick接受两个泛型T,U 从T类型中挑选出U类型的属性生成一个新的类型，而且泛型U必须是T类型的字符串联合类型的子集\ntype MyPick<T, U extends keyof T> = {[P in U] : T[P] }\n// 泛型约束的关系只能传入 name age location的联合类型\ntype PersonPick = MyPick<Person4,\'name\'| \'age\'>\n\n/* \ntype PersonPick = {\n    name: string;\n    age: number;\n}\n*/\n```\n', 1, 'typescript', 'typescript高级类型学习(1)', 1, '2019-11-13 17:50:15', '2020-06-09 16:33:56', NULL, 'http://img.carrotwu.com/Fm5DKNpSui4HwPDfNrIRxerKUgtp', NULL);
INSERT INTO `article` VALUES (9, '收集在学习`深入浅出TypeScript：从基础知识到类型编程`小册过程中所做的一些笔记，第2期为`条件类型`。', 44, '>收集在学习`深入浅出TypeScript：从基础知识到类型编程`小册过程中所做的一些笔记，第2期为`条件类型`。\n## 条件类型\n一般来说，在不确定具体类型的时候可以通过泛型来传入使用泛型，但是有时候我们无法确定使用哪个泛型。或者说具体使用哪个类型依赖于外部或者内部的某些条件，这就有点类似于js中的条件判断语句`if(){} else{}`，因此ts引入了条件类型。\n\n条件类型够表示非统一的类型,以一个条件表达式进行类型关系检测，从而在两种类型中选择其一.ts中的条件类型使用方法类似于js中的三目运算符：\n```ts\ntype Test<T,U> = T extends U ? X : U\n//若 T 能够赋值给 U，那么类型是 X，否则为 Y\n```\n>只有相应的条件匹配了，条件类型才会匹配出相应的类型。看起来与三目运算符一样是挺简单的，事实上并非如此。\n```ts\n// 下面是两个使用条件类型的例子\n// 根据三目我以为第一个返回的是T即 string | number\n// 第二个返回 never类型\n// 事实上并非如此\ntype Same<T, U> = T extends U ? T : never;\ntype same = Same<string | number, number>;  // 返回的是number\n\ntype Diff<T, U> = T extends U ? never : T;\ntype diff = Diff<string | number, number | boolean>;  // 返回的是string\n```\n那么问题出在哪里呢？其实是因为例子中条件类型T是**联合类型**，如果T类型不是联合类型那么是符合三目运算符的正常逻辑的。接下来我们先放开这个例子，直接探究具体的原因。\n\n## 条件类型与联合类型\n> 以下部分内容节选自《深入浅出typescript》小册\n\n条件类型有一个特性,就是「分布式有条件类型」,但是分布式有条件类型是有前提的,条件类型里待检查的类型必须是`naked type parameter`。\n\n好了,肯定有人已经晕了,什么是分布式有条件类型?`naked type parameter`又是什么?\n\n`naked type parameter`指的是**裸类型参数**,怎么理解?这个「裸」是指类型参数没有被包装在其他类型里,比如没有被数组、元组、函数、Promise等等包裹。\n\n我们举个简单的例子:\n```ts\n// 裸类型参数,没有被任何其他类型包裹即T\ntype NakedUsage<T> = T extends boolean ? \"YES\" : \"NO\"\n// 类型参数被包裹的在元组内即[T]\ntype WrappedUsage<T> = [T] extends [boolean] ? \"YES\" : \"NO\";\n```\n好了,`naked type parameter`我们了解了之后,「**分布式有条件类型**」就相对容易理解了,按照官方文档的说法是「**分布式有条件类型在实例化时会自动分发成联合类型**」。\n\n这个说法很绕,我们直接看例子:\n```ts\ntype Distributed = NakedUsage<number | boolean> //  = NakedUsage<number> | NakedUsage<boolean> =  \"NO\" | \"YES\"\ntype NotDistributed = WrappedUsage<number | boolean > // \"NO\"\n```\n当我们给类型`NakedUsage`加入联合类型`number | boolean`时,它的结果返回`\"NO\" | \"YES\"`,相当于联合类型中的number和boolean分别赋予了`NakedUsage<T>`然后再返回出一个联合类型,这个操作大家可以类比JavaScript中的Array.map()。\n\n我们看`NotDistributed`的结果,他接受的同样是联合类型`number | boolean`,但是返回一个特定的类型\"NO\",而非一个联合类型,就是因为他的类型参数是被包裹的即[`<T>`],不会产生分布式有条件类型的特性。\n\n**总结：** 在条件类型中如果类型没被包裹（**裸类型参数**）并且是**联合类型**的话就会在实例化时自动分化成**联合类型**。\n所以回顾之前的例子：\n```ts\n// Same 和 Diff的类型都是裸类型参数并且是联合类型\n// 所以其实实例化时的会自动分化成联合类型\ntype Same<T, U> = T extends U ? T : never;\ntype same = Same<string | number, number>;  // 返回的是number\n// 转化成下面的这个类型 这样子就不难得出是number类型了\ntype equalSame = Same<string, number> | Same<number, number> //返回number\n\ntype Diff<T, U> = T extends U ? never : T;\ntype diff = Diff<string | number, number | boolean>;  // 返回的是string\n// 同理转化为\ntype equalDiff = Diff<string, number> | Same<number, number> //返回string\n```\n## 条件类型，映射类型和索引类型的高级使用\n假设我有一个interface类型，现在我需要编写一个工具类型。这个工具类型接受一个U泛型把interface中符合U泛型的类型全部筛选出来组成一个新的接口interface。\n\n```ts\ninterface Part {\n  id: number;\n  name: string;\n  subparts: Part[];\n  updatePart(newName: string): void;\n}\n\ntype FilterInterface<T, U> = 如何编写\n\ntype FilterNumber = FilterInterface<Part, number>\n/* \ntype FilterNumber = {\n    id: number;\n}\n*/\n\ntype FilterNumberOrFunction = FilterInterface<Part, number | Function>;\n/* \ntype FilterNumberOrFunction = {\n    id: number;\n    updatePart: (newName: string) => void;\n}\n*/\n```\n实际效果图:  \n![alt](http://img.carrotwu.com/FpWwi3kdfndslRsj-T721K72UeHs)\n### 接下来一步一步的分析拆解  \n1. 首先通过`keyof T`索引类型获取T的**字符串联合类型**。\n![alt](http://img.carrotwu.com/FrvEt1UZStCJUKrs_Q7V4JAfh0Qe)\n2. 通过映射类型`[K in keyof T]`获取到每一个键值字符串,通过`T[K]`获取到每一个interface的value。这时K相当于interface的key,`T[K]`相当于interface的value。<br>\n![alt](http://img.carrotwu.com/FoPwhTgldlic-YdBkpDrakvySWQO)\n\n3. 通过条件类型`T[K] extends U ? K : never`验证当前的`T[K]`是否符合传入的泛型U。是的话把映射出来的类型K（相当于interface的key）保留下来（后面有用）,不是的话保留`never`。\n4. 通过`{ [K in keyof T] : T[K] extends U ? K : never}`获取符合泛型U的新interface，不符合的会被置为`never`类型。<br>\n![alt](http://img.carrotwu.com/Fi2dyrAb5emS_dZBLGpgkIeZZFqR)\n\n5. 通过`({ [K in keyof T] : T[K] extends U ? K : never})[keyof T]`再次使用索引类型获取不为`never`类型的联合类型key。\n![alt](http://img.carrotwu.com/Fsgmg81I_mvqCart0favXg4UZGuX)\n\n6. 使用内置的`Pick`工具类型把第五步的字符串联合类型转化为最终的interface接口。\n![alt](http://img.carrotwu.com/FnURanesnA97OjwtkqNVxYvNg19F)  \n其中Pick<T,K>是内置函数，作用是从`T`中取出一系列`K`的属性。具体使用方法以及原理可以见下图。\n![alt](http://img.carrotwu.com/FtZcwVPln8BIEs9iMkP91P4JN8RQ)\n\n7. 用泛型`T,U`替换相应的类型就得到了最终的类型工具。\n```ts\ntype FilterInterface<T, U extends T[keyof T]> = Pick<T,({[K in keyof T]: T[K] extends U ? K : never})[keyof T]>\ninterface Part {\n    id: number;\n    name: string;\n    subparts: Part[];\n    updatePart(newName: string): void;\n  }\n  type Test = FilterInterface<Part, string | ((...arg: any[]) => void)>\n  /* \n  type Test = {\n    name: string;\n    updatePart: (newName: string) => void;\n}\n  */\n```  \n\n## 总结\n**索引类型，条件类型， 映射类型**的组合常用来做一些工具类型，ts的内置类型工具如`Pick,Exclude`等都是借用三个高级类型编写而来。\n\n对于一些复杂的工具库而言，普遍的思想是通过映射类型和索引类型获取到需要的字符串类型接口如上面的步骤3的接口。\n```ts\ntype R = {\n    id: \'id\';\n    name: never;\n    subparts: never;\n    updatePart: never;\n}\n```\n**其中对于不需要或者需要删除的类型，值赋值给`never`,需要保留的类型就把相应的`key`名赋值给`value`，就如`id: \'id\'`。这样子在通过一次索引类型获取到需要的联合类型字符串`\'id\' | \'name\'`。最后通过相应的工具类型例如`Pick`达到最终需要的类型。**\n\n\n\n\n\n\n', 1, 'typescript', 'typescript高级类型学习(2)', 1, '2019-11-14 18:19:34', '2020-06-17 20:57:16', NULL, 'http://img.carrotwu.com/Fm5DKNpSui4HwPDfNrIRxerKUgtp', NULL);
INSERT INTO `article` VALUES (10, '收集在学习《深入浅出TypeScript：从基础知识到类型编程》小册过程中所做的一些笔记，第3期为infer关键字', 3, '>收集在学习`深入浅出TypeScript：从基础知识到类型编程`小册过程中所做的一些笔记，第3期为`infer关键字`。\n## infer关键字\n`infer`最早出现在此 PR 中，表示在`extends`条件语句中**待推断**的类型变量。在定义上，我个人认为关键字是**待推断**这三个字。  \n个人认为表示`infer`的类型无法得到但是能够ts的类型推断推导出来。感觉上与泛型有点类似，提前声明一个未知的变量,不过不同的是泛型在使用时必须传值因此可以确定具体类型，`infer`至始至终都无法得知具体类型只能通过类型推断来推导出来。  \n干巴巴说没啥用，上个栗子看下：\n```ts\n// infer P 表示待推断的类型\ntype ParamType<T> = T extends (param: infer P) => any ? P : T;\n```\n上面的类型表示如果传入的泛型`T`能赋值给函数类型`(param: infer P) => any`，那么就返回函数类型化`(param: infer P) => any`中的`P`,也就是函数的传参类型`param`。不然的话返回泛型T。\n```ts\ninterface User {\n  name: string;\n  age: number;\n}\ntype ParamType<T> = T extends (param: infer P) => any ? P : T;\ntype Func = (user: User) => void;\n\ntype Param = ParamType<Func>; // Param = User\ntype AA = ParamType<string>; // string\n```\n### ReturnType 提取函数返回类型\n同理，我们可以把上面的待推断类型`inter P`用在函数返回值上，实现一个接受函数泛型返回函数泛型返回值的类型工具，这个类型工具其实也就是ts内置类型ReturnType的实现。\n```ts\n\ntype MyReturnType<T extends (...args: any[]) => any> = T extends (...args: any[]) => infer P ? P : any\n\ninterface Fun {\n    (params: string) : string | number\n}\ntype FunReturnType1 = MyReturnType<Fun> // string | number\n\ntype FunReturnType2 = ReturnType<Fun> // string | number\n```\n### ConstructorParameters 提取构造函数中参数（实例）类型\n`infer`同样可以使用在提取类的构造函数返回类型上，构造函数一般用两种类型来表示.\n```ts\n//类表示\nclass A {\n    public constructor(paramsA: string, paramsB: number | boolean) { }\n}\n// 函数表示\ninterface B {\n    new (paramsA: string, paramsB: number | boolean) : any\n}\n```\n因此我们可以实现一个就收构建函数泛型返回构造函数参数类型的类型工具，这个类型工具其实也是ts内置原型`ConstructorParameters`的实现\n```ts\ntype MyConstructorParameters<T extends new (...args: any[]) => any> = T extends new (...args: infer P) => any ?\nP \n:\nnever\n\ntype AParamsType1 = MyConstructorParameters<typeof A> // [string, number | boolean]\ntype AParamsType2 = ConstructorParameters<typeof A> // [string, number | boolean]\n\ntype BParamsType1 = MyConstructorParameters<B> // [(a: string) => boolean, number | boolean]\ntype BParamsType2 = ConstructorParameters<B> // [(a: string) => boolean, number | boolean]\n```\n1. 其中`T extends new (...args: any[]) => any`是泛型约束，约束传入的泛型T必须是构造函数。\n2. `T extends new (...args: infer P) => any`后续的`infer P`推断类型P来获取构造函数的参数类型。\n\n## infer的骚操作\n>以下的内容摘自《深入理解typescript》  \n\n至此，相信你已经对 infer 已有基本了解，我们来看看一些使用它的「骚操作」：\n1. tuple转union(元组转联合类型) ，如：`[string, number] -> string | number`  \n解答之前，我们需要了解 tuple 类型在一定条件下，是可以赋值给数组类型：\n```ts\ntype TTuple = [string, number];\ntype TArray = Array<string | number>;\n\ntype Res = TTuple extends TArray ? true : false; // true\ntype ResO = TArray extends TTuple ? true : false; // false\n```\n因此，在配合 infer 时，这很容做到：  \n```ts\ntype ElementOf<T> = T extends Array<infer E> ? E : never;\ntype TTuple = [string, number];\ntype ToUnion = ElementOf<TTuple>; // string | number\n```\n2. union 转 intersection(联合转交叉类型)，如：`string | number -> string & number`\n```ts\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;\n\ntype Result = UnionToIntersection<T1 | T2>; // T1 & T2\n```\n\n', 1, 'typescript', 'typescript高级类型学习(3)', 1, '2019-11-15 21:34:34', '2019-11-15 21:35:57', '2019-11-15 21:36:20', 'http://img.carrotwu.com/Fm5DKNpSui4HwPDfNrIRxerKUgtp', NULL);
INSERT INTO `article` VALUES (11, '收集在学习《深入浅出TypeScript：从基础知识到类型编程》小册过程中所做的一些笔记，第3期为infer关键字', 66, '>收集在学习`深入浅出TypeScript：从基础知识到类型编程`小册过程中所做的一些笔记，第3期为`infer关键字`。\n## infer关键字\n`infer`最早出现在此 PR 中，表示在`extends`条件语句中**待推断**的类型变量。在定义上，我个人认为关键字是**待推断**这三个字。  \n个人认为表示`infer`的类型无法得到但是能够ts的类型推断推导出来。感觉上与泛型有点类似，提前声明一个未知的变量,不过不同的是泛型在使用时必须传值因此可以确定具体类型，`infer`至始至终都无法得知具体类型只能通过类型推断来推导出来。  \n干巴巴说没啥用，上个栗子看下：\n```ts\n// infer P 表示待推断的类型\ntype ParamType<T> = T extends (param: infer P) => any ? P : T;\n```\n上面的类型表示如果传入的泛型`T`能赋值给函数类型`(param: infer P) => any`，那么就返回函数类型化`(param: infer P) => any`中的`P`,也就是函数的传参类型`param`。不然的话返回泛型T。\n```ts\ninterface User {\n  name: string;\n  age: number;\n}\ntype ParamType<T> = T extends (param: infer P) => any ? P : T;\ntype Func = (user: User) => void;\n\ntype Param = ParamType<Func>; // Param = User\ntype AA = ParamType<string>; // string\n```\n### ReturnType 提取函数返回类型\n同理，我们可以把上面的待推断类型`inter P`用在函数返回值上，实现一个接受函数泛型返回函数泛型返回值的类型工具，这个类型工具其实也就是ts内置类型ReturnType的实现。\n```ts\n\ntype MyReturnType<T extends (...args: any[]) => any> = T extends (...args: any[]) => infer P ? P : any\n\ninterface Fun {\n    (params: string) : string | number\n}\ntype FunReturnType1 = MyReturnType<Fun> // string | number\n\ntype FunReturnType2 = ReturnType<Fun> // string | number\n```\n### ConstructorParameters 提取构造函数中参数（实例）类型\n`infer`同样可以使用在提取类的构造函数返回类型上，构造函数一般用两种类型来表示.\n```ts\n//类表示\nclass A {\n    public constructor(paramsA: string, paramsB: number | boolean) { }\n}\n// 函数表示\ninterface B {\n    new (paramsA: string, paramsB: number | boolean) : any\n}\n```\n因此我们可以实现一个就收构建函数泛型返回构造函数参数类型的类型工具，这个类型工具其实也是ts内置原型`ConstructorParameters`的实现\n```ts\ntype MyConstructorParameters<T extends new (...args: any[]) => any> = T extends new (...args: infer P) => any ?\nP \n:\nnever\n\ntype AParamsType1 = MyConstructorParameters<typeof A> // [string, number | boolean]\ntype AParamsType2 = ConstructorParameters<typeof A> // [string, number | boolean]\n\ntype BParamsType1 = MyConstructorParameters<B> // [(a: string) => boolean, number | boolean]\ntype BParamsType2 = ConstructorParameters<B> // [(a: string) => boolean, number | boolean]\n```\n1. 其中`T extends new (...args: any[]) => any`是泛型约束，约束传入的泛型T必须是构造函数。\n2. `T extends new (...args: infer P) => any`后续的`infer P`推断类型P来获取构造函数的参数类型。\n\n## infer的骚操作\n>以下的内容摘自《深入理解typescript》  \n\n至此，相信你已经对 infer 已有基本了解，我们来看看一些使用它的「骚操作」：\n1. tuple转union(元组转联合类型) ，如：`[string, number] -> string | number`  \n解答之前，我们需要了解 tuple 类型在一定条件下，是可以赋值给数组类型：\n```ts\ntype TTuple = [string, number]\ntype TArray = Array<string | number>\ntype Res = TTuple extends TArray ? true : false; // true\ntype ResO = TArray extends TTuple ? true : false; // false\n```\n因此，在配合 infer 时，这很容做到：  \n```ts\ntype ElementOf<T> = T extends Array<infer E> ? E : never;\ntype TTuple = [string, number];\ntype ToUnion = ElementOf<TTuple>; // string | number\n```\n2. union 转 intersection(联合转交叉类型)，如：`string | number -> string & number`\n```ts\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;\ntype Result = UnionToIntersection<T1 | T2>; // T1 & T2\n```\n\n', 1, 'typescript', 'typescript高级类型学习(3)', 1, '2019-11-15 21:35:54', '2020-02-24 19:48:08', NULL, 'http://img.carrotwu.com/Fm5DKNpSui4HwPDfNrIRxerKUgtp', NULL);
INSERT INTO `article` VALUES (12, '工作中需要使用到react-native进行混合开发一款ios的app，因为我使用的是windows，不是使用的mac电脑（没钱），公司配备了一台ipad用于开发，在开发中也踩过了很多坑在这里进行总结。', 33, '\n>工作中需要使用到`react-native`进行混合开发一款ios的app，因为我使用的是windows，不是使用的mac电脑（没钱），公司配备了一台ipad用于开发，在开发中也踩过了很多坑在这里进行总结。\n\n## 开发环境的调试（使用mac电脑可以直接跳过这一步）。\n因为我使用的是windows，所以只能退而求其次的在window上进行编写代码，在ipad端进行查看效果以及debug。使用官方上的`create-react-native-app`。安装完下载好依赖包之后就可以在windows上愉快的进行开发了。  \n    \n运行yarn start,在控制台会直接跳出一个二维码以及连接。之后，在ios设备或者安卓设备上进行`expo`的下载。相应的安装包可以再`Google play`或者`apple store`都可以直接搜到。安装完成之后，安卓设备可以直接通过软件内部的二维码扫描控制台的二维码即可预览，苹果设备的话则需要手动输入链接。\n\n## `react-native TextInput`无法输入中文的问题。\n切换中文输入法，只要一输入一个字母自动填充金输入框了。看了一下[**issues**](https://github.com/facebook/react-native/pull/18456 \"Markdown\")发现是rn自己的bug。使用了其中一个人的方法之后经测试没有问题了（ps：看了一下最新的issues，最新版rn好像已经修复了这个问题）\n\n```jsx\nimport React, {Component} from \'react\';\nimport {Platform, TextInput} from \'react-native\';\n\nclass MyTextInput extends Component {\n  shouldComponentUpdate(nextProps){\n    return Platform.OS !== \'ios\' || this.props.value === nextProps.value;\n  }\n  render() {\n    return <TextInput {...this.props} />;\n  }\n};\n\nexport default MyTextInput;\n```\n## 关于图片自适应的问题。\n最开始需求是一行四个图片，然后图片根据屏幕宽度自适应的需求，一行四个是完成了。但是图片的高并不像web一样自动撑大或者缩小，图片各种变形。后面试了很多方法，没办法只能在`componentDidMount`生命周期内获取屏幕的宽度计算出图片的实际宽度再按照图片本身的宽高比计算出实际的自适应高度进行样式的填充。**`Dimensions.get(\'window\').width`**为获取屏幕宽度的。\n\n## rn程序的无端崩溃。\n在实际集成到项目部署到测试环境的过程中，我们发现程序在运行一段时候之后会莫名的直接崩溃返回主页面，页面直接随机性的崩溃也没有报出红屏的错误。再与ios的开发同事协调之后我们终于定位到了相关的bug。\n\n```javascript\ncom.squareup.SocketRocket.NetworkThread(18): EXC_BAD_ACCESS\n```\n\n 查阅了相关资料之后发现这是因为rn的websocket包出现了问题，查找了`issues`发现了相关人员的评论[**issues**](https://github.com/facebook/react-native/issues/6117 \"Markdown\")。   \n    \n参考了[**issues**](https://github.com/facebook/react-native/issues/19489 \"Markdown\")里pr的`files changed`我们让ios的同事根据`files changed`里的修改修改了`Libraries/WebSocket/RCTSRWebSocket.m`的文件之后，问题解决（我挂了两晚上也没有崩溃）。然而官方这个pr不知道为啥莫名其妙没有通过。。。\n\n## 获取原生保存的数据\n在开发的过程中，有时候需要使用到登录用户信息，但是我们有无法监听到用户是否切换了用户。在经过与ios的协调之后，ios会在rn文件的入口处通过props传输我们需要的数据，我们只需在最顶层（app。js）的props中获取原生传给我们的信息。再根据需要时传给子组件还是通过redux保存起来。\n\n## 图标svg的使用。\n最开始关于图标的使用最初的方案定在使用svg，但是rn对于svg的兼容并不友好，生态上其实也有类似于`react-native-svg`的库。在经过一些测试后还是被我们否决了，后面发现了一个牛逼的网站[**SVGR : The SVG to JSX transformer**](https://github.com/facebook/react-native/issues/19489 \"Markdown\")。  \n    \n这个网站能把web的svg转换成react或者rn都能使用的组件类型。把svg的源码拷贝到左边的输入框中，在左边勾选上React Native会自动帮你生成rn能够使用的组件，直接复制新建一个js文件即可。在项目中直接当做组件引用使用就可以了，还有一些自定义的参数大家可以按需求自动添加。  \n\n![alt](http://img.carrotwu.com/FmyFnCWKtazeqlebb5Rb4xIz93JZ)\n\n## rn路由的使用。\n在经过一系列的商量之后，我们选择使用`react-navigation`进行rn路由的跳转。在我们编写项目时，`react-navigation`升级到了v3，提供了许多新的api和用法。当然也踩了许多坑。  \n\n自定义组件的路由跳转。`react-navigation`的路由跳转是通过定义在props上的navigation属性进行调用跳转，一些自定义组件并不能接收到路由跳转的props,得通过`withNavigation`这个高阶组件进行包装\n\n', 1, 'react,reacat-native', 'react-native踩过的坑', 1, '2019-08-09 11:28:03', '2020-08-05 15:05:40', NULL, 'http://img.carrotwu.com/FppIeZN0v4SETdsgMpnhyegVwh3Q', NULL);
INSERT INTO `article` VALUES (13, '这几天看着博客代码的样式越看越难看，所以就在网上搜了一些文章决定使用`prism.js`来高亮代码', 29, '>这几天看着博客代码的样式越看越难看，所以就在网上搜了一些文章决定使用`prism.js`来高亮代码。\n\n## prism是什么\n `Prism`是一款轻量、可扩展的代码语法高亮库，使用现代化的Web标准构建。可以自定义自主选择高亮的代码，同时也支持一系列的插件。如代码行，自动拷贝复制，显示代码语言等。  \n 官网有对prism的优点进行了介绍：  \n1. **极致易用**。引用`prism.css`和`prism.js`，使用合适的`HTML5`标签（`code.language-xxxx`），搞定！  \n2. **天生伶俐**。语言的`CSS`类是可继承的，所以你只需定义一次就能应用到多个代码片段。\n3. **轻如鸿毛**。代码压缩后只有 1.6KB。每添加一个语言平均增加 0.3-0.5KB，主题在 1KB 左右。\n4. **快如闪电**。如果可能，支持通过`Web Workers`实现并行。\n5. **轻松扩展**。定义新语言或扩展现有语法，或者新增功能都非常简单。\n6. **丰富样式**。所有的样式通过`CSS`完成，并使用合理的类名如：`.comment, .string, .property` 等。\n\n## prism下载\n1. 首先进入prism的[官网](https://prismjs.com/download.html)下载链接。\n2. 选择需要使用的主题以及需要支持的高亮语言，plugins是一些额外的插件勾选即可。\n![alt](http://img.carrotwu.com/FjwHWK8qf_oMmDuWqLQxgR5-PbM1)  \n\n3. 选择完毕之后拖到最下方会出现`js`和`css`的文件直接拷贝引入当前项目即可。  \n![alt](http://img.carrotwu.com/Fojc_zBQ9qnrvZ2RXSUp7mNi0PHg)  \n\n4. 把`markdown`文件转化为`html`语言，我博客选择的库是`marked`，可自行选择其他相应的库。贴一下我的相关配置。\n```tsx\nimport React, {useEffect, useMemo} from \"react\"\nimport marked from \'marked\'\nconst Prism = window && window.Prism\n//设置代码高亮\nmarked.setOptions({\n  highlight(code: string, lang: any) {\n   return Prism.highlight(code, Prism.languages[lang], lang)\n  }\n})\nconst Post:React.FC = () => {\n  // 获取html\n  const html = useMemo(() => marked(content),[content])\n  return (\n   <div className=\"markdown-body\" dangerouslySetInnerHTML={{__html:html}}/>\n  )\n}\nexport default Post\n```\n6. 接下来就可以看到代码高亮效果了，prism官网上还有许多额外的css主题，选择相应的css样式进行覆盖即可。如果需要自定义样式直接修改css样式代码就可以了，十分方便。', 1, 'prism.js', '使用prism.js美化代码块', 1, '2019-11-18 18:02:39', '2020-07-24 15:58:06', NULL, 'http://img.carrotwu.com/FtHT11YtWLoIMll6bgJlWR0i41HS', NULL);
INSERT INTO `article` VALUES (14, '在阅读极客时间《透视http协议》中的学习笔记，好记性不如烂笔头。', 40, '>在阅读极客时间《透视http协议》中的学习笔记，好记性不如烂笔头。\n\n## http是什么\nhttp是**超文本传输协议**,要深入的理解就得把定义拆分出来逐个击破.\n1. 超文本：表示`HTTP`传输的不是 `TCP/UDP` 这些底层协议里被切分的杂乱无章的二进制包`（datagram）`，而是完整的、有意义的数据，可以被浏览器、服务器这样的上层应用程序处理。\n2. 传输：传输的条件是需要两方进行交流传输，http是一个在计算机世界里专门用来在两点之间传输数据的约定和规范。\n3. 协议：协议指的是一种规范，双方都必须遵守，不然的话协议不生效。\n\n## “四层”和“七层”\n`TCP/IP` 协议实际上是一系列网络通信协议的统称，`tcp`处于传输层,`ip`处于网络层，其余层次也十分重要，这会在后面讲到。\n\n`ip`是解决寻址和路由问题，以及如何在两点间传送数据包。`tcp`在`ip`之上，基于 IP 协议提供可靠的、字节流形式的通信，是 HTTP 协议得以实现的基础。\n\n### TCP/IP 网络分层模型\n\n`TCP/IP` 协议总共有四层，就像搭积木一样，每一层需要下层的支撑，同时又支撑着上层，任何一层被抽掉都可能会导致整个协议栈坍塌.\n1. 链接层\n2. 网络层，ip层就是在这里\n3. 传输层，tcp就是在这里，还有tcp的另外一个伙伴udp\n4. 应用层，http就是在这里\n\n### OSI 网络分层模型\n1. 第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等；\n2. 第二层：数据链路层，它基本相当于 TCP/IP 的链接层；\n3. 第三层：网络层，相当于 TCP/IP 里的网际层；\n4. 第四层：传输层，相当于 TCP/IP 里的传输层；\n5. 第五层：会话层，维护网络中的连接状态，即保持会话和同步；\n6. 第六层：表示层，把数据转换为合适、可理解的语法和语义；\n7. 第七层：应用层，面向具体的应用传输数据。\n\n## 域名\n相对于访问服务器的ip地址而言，用户更喜欢访问一串相对好几的名字，这就是域名的产生。\n\n### 域名的形式\n1. 根域名：我们常见的`.com` `.com.cn` `.org`都是根域名.\n2. 顶级域名：我们可以买到的域名如博客地址`carrotwu.com` `baidu.com`等\n3. 二级域名：...依次类推，没在前面加一个前缀就加上一级。\n\n### 域名的解析\n访问一个域名时，如果没有缓存的话会从根域名开始依次向上直到找到相应的服务器ip地址，这一过程叫做域名解析。\n域名解析会耗费大量的时长，所以可以通过**缓存**的思路去进行优化。大致过程是：发送\n** 浏览器缓存->操作系统缓存->hosts->dns->根域名->顶级域名....持续下去**\n\n### 为什么要连接要三次断开要四次\n #### 三次握手\n  在进行连接时，客户端和服务端都必须确定对方具有良好的发送能力和接受能力。对于两次握手时，客户端发送了数据包并且接收到了服务端的数据包。说明客户端的知道服务端的发送能力跟接受能力是良好的。但是对于客户端来说，它只知道客户端的发送能力是好的，接受能力好不好并不清楚。所以需要第三次握手客服端再次发送一个数据包来让服务端明白客户端的接受能力也是良好的。\n 详细的行为：\n 1. 客户端发送syn的报文给服务端，然后客户端处于SYN_SEND的状态\n 2. 客户端接受到syn报文之后，也发送一个syn以及ack报文给客户端,这时候服务端处于SYN_REV的状态。此时处于半连接状态\n 3. 客户端接受到syn的报文之后也会发送一个ack给服务端,这是后客户端处于establised状态。客户端接受了ack的报文也处于establised状态，建立起链接\n **务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中**\n #### 四次挥手\n 在进行挥手时。第一次挥手用于高速服务端断开链接。第二次挥手用于服务端告诉客户端断开链接，这时候客户端处于closeWait状态。第三次用于服务端告诉告诉客户端他也要断开链接了，服务端处于last_ack状态。第四次客服端告诉服务端可以断开链接一段时间后断开（在这个事件处于timeWAIT状态，其实就是为了防止服务端没有收到第四次发的报文，或者服务端还有数据在传输）。服务端接收到第四次的报文就关闭链接\n 1. 客户端发送FIN的报文给服务端，客户端处于FIN_WAIT状态\n 2. 服务端接送到报文，返回ack的报文给客户端告诉客户端接受到消息了。服务端这时候处于CLOSE_WAIT状态\n 3. 服务端发送FIN报文给客户端，告诉客户端他也要关闭连接了，这时候服务端处于LAST_ACK状态。\n 4. 第四个客户端发送相应的ack报文给服务端告诉它我接手到了，然后客户端处于(TIME_WAIT)状态，一段时间后就断开链接。客户端接收到报文断开链接\n\n **理论上，四次挥手也可以合并成三次挥手，因为第二次和第三次是可以合并起来的。但是一般对于服务端来说数据可能没传完，所以一般都是四次挥手。同时第四次挥手中的客户端之所以处于TIME_WAIT状态，是因为客户端如果直接关掉链接的话，这时候假设服务端还有数据发送就丢失了。所以客户端需要等待一个时间没有接受到服务端的报文才会进行关闭。**\n\n  参考资料[https://juejin.im/post/5ccd0dfc6fb9a0324a08bb73]\n## 标准请求方法\n目前 HTTP/1.1 规定了八种方法，单词都必须是大写的形式。\n1. GET：获取资源，可以理解为读取或者下载数据；\n2. HEAD：获取资源的元信息；\n3. POST：向资源提交数据，相当于写入或上传数据；\n4. PUT：类似 POST；\n5. DELETE：删除资源；\n6. CONNECT：建立特殊的连接隧道；\n7. OPTIONS：列出可对资源实行的方法；\n8. TRACE：追踪请求 - 响应的传输路径。\n\n## URI 和 URL\n需要获取指定服务器的文件或者请求需要用到URI 和 URL。 URI，也就是统一资源标识符。URL，统一资源定位符。两者之间差距不大URL只是URI的一种具体表现形式。\n\n### URI 的格式\nURI 本质上是一个字符串，这个字符串的作用是唯一地标记资源的位置或者名字.\n下面的这张图显示了 URI 最常用的形式，由 `scheme`、`host:port`、`path` 和 `query` 四个部分组成，但有的部分可以视情况省略。\n![alt](http://img.carrotwu.com/Fk8saVU2ODPqvHIgbN00LIPBCFpn)\n1. scheme 叫“方案名”或者“协议名”，表示资源应该使用哪种协议来访问(`http` 和 `https`)；\n2. “host:port”表示资源所在的主机名和端口号；\n3. path 标记资源所在的位置；\n4. query 表示对资源附加的额外要求\n\n## 相应状态码\n服务器通过http获取客户端请求的数据之后，会返回一个数据报文给客户端，不同的请求结果会对应不同的状态码.\n\n1. 1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；\n2. 2××：成功，报文已经收到并被正确处理；\n3. 3××：重定向，资源位置发生变动，需要客户端重新发送请求；\n4. 4××：客户端错误，请求报文有误，服务器无法处理；\n5. 5××：服务器错误，服务器在处理请求时内部发生了错误。\n\n### 一些常用需要记住的状态码\n\n1. “200 OK”是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果，如果是非 HEAD请求，通常在响应头后都会有 body 数据。\n2. “204 No Content”是另一个很常见的成功状态码，它的含义与“200 OK”基本相同，但响应头后没有 body 数据。所以对于 Web 服务器来说，正确地区分 200 和 204是很必要的。\n3. “301”永久重定向, “302”临时重定向.\n4. “304 Not Modified” 是一个比较有意思的状态码，它用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）。\n5. 401代表需要登录, 403代表没有响应的权限, 404查找到响应的文件, 405请求方法不合理。\n\n## http的实体数据\n在http的请求头中，可以通过设置响应的类别（`content-type`）来声明需要获取的文件格式.\n1. `text`：即文本格式的可读数据，我们最熟悉的应该就是`text/html` 了，表示超文本文档，此外还有纯文本`text/plain`、样式表 `text/css` 等。\n2. `image`：即图像文件，有 `image/gif`、`image/jpeg`、`image/png` 等。\n3. `audio/video`：音频和视频数据，例如 `audio/mpeg`、`video/mp4` 等。\n4. `application`：数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释。常见的有`application/json`，`application/javascript`、`application/pdf` 等，另外，如果实在是不知道数据是什类型，像刚才说的“黑盒”，就会是`application/octet-stream`，即不透明的二进制数据。\n\nHTTP在传输时为了节约带宽，有时候还会压缩数据，为了不要让浏览器继续“猜”，还需要有一个“`Encoding type`”，告诉数据是用的什么编码格式，这样对方才能正确解压缩，还原出原始的数据。\n1. gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式；\n2. deflate：zlib（deflate）压缩格式，流行程度仅次于gzip；\n3. br：一种专门为 HTTP 优化的新压缩算法（Brotli）。\n\n## http传输大文件的方法\n1. 压缩 HTML 等文本文件是传输大文件最基本的方法；\n2. 分块传输可以流式收发数据，节约内存和带宽，使用响应头字段“`Transfer-Encoding: chunked`”来表示，分块的格式是 16 进制长度头 + 数据块；\n3. 范围请求可以只获取部分数据，即“分块请求”，实现视频拖拽或者断点续传，使用请求头字段“`Range`”和响应头字段“`Content-Range`”，响应状态码必须是 206；\n4. 也可以一次请求多个范围，这时候响应报文的数据类型是“`multipart/byteranges`”，body 里的多个部分会用`boundary` 字符串分隔。\n\n### http的断点续传以及多线程上传\n1. 断点续传：假设某个1024kb的文件下载了512k,这时候再下一次发起http的请求头中会带上请求头字段“`Range`”。其中range字段是一个左闭右开的区间，在例子中就是512000~。表示这一次的下载从512k开始重新下载。 这时候服务器端接收到客户端的断点续传请求，会在响应头中加入字段“`Content-Range: 512000~1024000`”，并且状态码返回必须是206。\n2. 多线程：按照上面断点续传的方法，可以发起多个http请求通过分块请求的方法进行多线程的上传或者下载。\n## HTTP的连接管理\n![alt](http://img.carrotwu.com/FkZXP3semwjK-wh1bMwR6zWfDjma)\n\n### 短连接\n因为客户端与服务器的整个连接过程很短暂，不会与服务器保持长时间的连接状态，所以就被称为“短连接”`（shortlived connections）`。早期的 HTTP 协议也被称为是“无连接”的协议。\n\n### 长连接\n针对短连接暴露出的缺点，HTTP 协议就提出了“长连接”的通信方式，也叫“持久连接”`（persistentconnections）`、“连接保活”`（keep alive）`、“连接复用”`（connection reuse）`。长链接的请求会复用之前已经连接过的tcp连接而不会重新创建一个新的http连接。\n\n### 连接相关的头字段\n我们可以在请求头里明确地要求使用长连接机制，使用的字段是`Connection`，值是`“keep-alive”`。\n在客户端，可以在请求头里加上`“Connection: close”`字段，告诉服务器：“这次通信后就关闭连接”。\n服务器端通常不会主动关闭连接，但也可以使用一些策略。拿 Nginx 来举例，它有两种方式：\n1. 使用`“keepalive_timeout”`指令，设置长连接的超时时间，如果在一段时间内连接上没有任何数据收发就主动断开连接，避免空闲连接占用系统资源。\n2. 使用`“keepalive_requests”`指令，设置长连接上可发送的最大请求次数。比如设置成 1000，那么当 Nginx 在这个连接上处理了 1000 个请求后，也会主动断开连接。\n\n### tcp的队头阻塞\n看完了短连接和长连接，接下来就要说到著名的“队头阻塞”（`Head-of-line blocking`，也叫“队首阻塞”）了。\n因为 HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理。\n\n如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本。\n\n在TCP传输过程中，由于单个数据包的丢失⽽造成的阻塞称为TCP上的队头阻塞。\n\n### 滑动窗口\n在建立好tcp链接之后，在后续的数据包传输过程之中，必须保证包的传输必须依照次序进行送达。如果某个包半路丢失了那么就要重新进行发送。所以问题是对于tcp的包传输时，如何以高效率的形式进行传输呢。这就是**滑动窗口**的由来。\n滑动窗口协议：**在TCP协议中，发送方和接受方通过各自维护自己的缓冲区。通过商定包的重传机制等一系列操作，来解决不可靠的问题。**。我们先不管这个协议，我们假设如何才能高效的进行包的传输呢。\n1. 客户端发送一个包，收到一个确认包之后在发送第二个包。特点：次序是保证了，但是效率十分低。\n2. 客户端一次性发送n个包，等待所有的包回来之后在一起确认。特点：为了保证包的次序，需要等到所有包回来之后才能进行排序确认，要是第一个包丢失了后续的包依旧没法进行确认。\n\n解决办法：\n假设一开始我们发送5个包，123个包是已经收到确认的。这时候我们就可以再缓冲区把前三个包放进内存。同时发送678的包数据，这样子每当一个包确认之后。就像一个滑块向右移动一格，这种通过维护自己的缓存区依次发送依次确认提高吞吐量的协议称之为**滑动窗口**协议。\n\n### 性能优化\n1. 并发连接:也就是同时对一个域名发起多个长连接，用数量来解决质量的问题。\n2. 域名分片:后台有多个服务器，可以通过分发到不同的服务器解决，用数量来解决质量。\n\n## HTTP的Cookie机制\n\n1. Cookie 是服务器委托浏览器存储的一些数据，让服务器有了“记忆能力”；\n2. 响应报文使用 `Set-Cookie` 字段发送`“key=value”`形式的 Cookie 值；\n3. 请求报文里用 Cookie 字段发送多个 Cookie 值；\n4. 为了保护 Cookie，还要给它设置有效期、作用域等属性，常用的有 `Max-Age、Expires、Domain、HttpOnly` 等；\n“HttpOnly”会告诉浏览器，此 Cookie 只能通过浏览器 HTTP 协议传输，禁止其他方式访问，浏览器的 JS 引擎就会禁用 document.cookie 等一切相关的 API，脚本攻击也就无从谈起了。\n\n另一个属性“SameSite”可以防范“跨站请求伪造”（XSRF）攻击，设置成“SameSite=Strict”可以严格限定 Cookie 不能随着跳转链接跨站发送，而“SameSite=Lax”则略宽松一点，允许 GET/HEAD 等安全方法，但禁止POST 跨站发送。\n\n还有一个属性叫“Secure”，表示这个 Cookie 仅能用 HTTPS 协议加密传输，明文的HTTP 协议会禁止发送。但 Cookie 本身不是加密的，浏览器里还是以明文的形式存在。\n5. Cookie 最基本的用途是身份识别，实现有状态的会话事务。\n\n## https\n由于 HTTP 天生“明文”的特点，整个传输过程完全透明，任何人都能够在链路中截获、修改或者伪造请求 / 响应报文，数据不具有可信性。所以我们需要另外一种协议来确保数据的安全,https就应运而生了。\nHTTPS 其实是一个“非常简单”的协议，RFC 文档很小，只有短短的 7 页，里面规定了新的协议名“https”，默认端口号 443，至于其他的什么请求 - 应答模式、报文结构、请求方法、URI、头字段、连接管理等等都完全沿用 HTTP，没有任何新的东西。https只是在http的基础上加了一层，把原有的传输协议从下层的传输协议由 `TCP/IP` 换成了`SSL/TLS`\n![alt](http://img.carrotwu.com/FkfghsuX5zkRgJKEL4B_3Czq14uV)\n\n### ssl\nTLS 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。\n\n浏览器和服务器在使用 TLS 建立连接时需要选择一组恰当的加密算法来实现安全通信，这些算法的组合被称为“密码套件”（cipher suite，也叫加密套件）。\n\n### 对称加密与非对称加密\n1. 对称加密:加密和解密都用同一个秘钥,对称加密本身并不能解决秘钥在传输过程中被劫持的问题。\n2. 非对称加密:加密用公钥,解密用秘钥。公钥由权威证书机构颁发，秘钥自己保存。因为每次传输数据都会使用不一样的秘钥导致非对称加密速度确实很慢\n所以现在都是通过使用混合加密的方式进行传输，第一次传输的过程中使用非对称加密传输秘钥，之后使用相同的公钥和秘钥进行堆成加密。（SSL 就是通信双方通过非对称加密协商出一个用于对称加密的密钥。）\n\n## http的一些缺点\n1. 队头阻塞\n2. 明文传输\n3. header每次传输都带上，头部数据大\n4. 只能主动向服务端请求数据，不能被动推送\n\n## http2\n1. 头部压缩 对臃肿的header进行压缩处理\n2. 二进制格式\n3. 通过流的形式解决队头阻塞和多路复用\n4. 服务端可推送数据\n\n### http的队头阻塞\n因为http也是规定了一发一收的报文请求机制，对于一个域名的多个请求，http会把所有任务放在一个任务队列中进行请求，如果第一个任务耗时过长就会造成后续的请求被堵塞了，这个就是著名的http队头阻塞（跟tcp的队头阻塞有点类似）,在http1.1阶段如何解决这个问题呢？\n1. 并发连接：对于一个域名允许同时处理多个连接，这样子就相当于增加了任务队列，在chrome的标准中允许同时请求6个连接。\n2. 域名分片：请求可以分发到不同的域名或者子域名去，通过dns或者nginx代理到相同的一台服务器中，这样子其实也是增加了吞吐量。\n\n### http2的对头阻塞解决方案\n在http1.1中可以哦通过域名分片，并发连接进行解决队头阻塞的问题，但是依然治标不治本，所以http2通过流的形式解决。简单说就是对路复用的解决方案，浏览器把数据通过二进制进行分针层处理，转化成一个个带id编号的帧发送给服务器。服务器接受后把相同id的帧进行拼接组合完整的数据。同理服务器也会把数据经过分针层处理转为为一个个带id的帧传给客户端，客户端也进行拼装处理。因此客户端就可以进行所谓的“乱序”发送，但是最终拼接的时候需要把相同id的帧进行拼装处理。\nhttp2依然还会有队友阻塞的问题，因为假设tcp中的一个数据包2发生了错误，这时候整个http需要重新发送数据包2，这样子回导致数据包1任然需要等待数据包2的完成。所以下面就出现了http3。\n\n### http2的请求方式\n1. ⾸先，浏览器准备好请求数据，包括了请求⾏、请求头等信息，如果是POST⽅法，那么还要有请求体。\n2. 这些数据经过⼆进制分帧层处理之后，会被转换为⼀个个带有请求ID编号的帧，通过协议栈将这些帧发送给服务器。\n3. 服务器接收到所有帧之后，会将所有相同ID的帧合并为⼀条完整的请求信息。\n4. 然后服务器处理该条请求，并将处理的响应⾏、响应头和响应体分别发送⾄⼆进制分帧层。\n5. 同样，⼆进制分帧层会将这些响应数据转换为⼀个个带有请求ID编号的帧，经过协议栈发送给浏览器。\n6. 浏览器接收到响应帧之后，会根据ID编号将帧的数据提交给对应的请求。\n\n### http3\n虽然`HTTP/2`解决了应⽤层⾯的队头阻塞问题，不过和`HTTP/1.1`⼀样，`HTTP/2`依然是基于TCP协议的，⽽TCP最初就是为了单连接⽽设计的。所以http2依然还会有队友阻塞的问题，因为假设tcp中的一个数据包2发生了错误，这时候整个http需要重新发送数据包2，这样子回导致数据包1任然需要等待数据包2的完成。即时`http2`实现了多路复用，依然会出现这样的问题。\n![alt](http://img.carrotwu.com/Fq_lEoMtIoAqUrll2s60Shv5Lyce)\n\n因此，`HTTP/3`选择了⼀个折衷的⽅法⸺`UDP`协议，基于UDP实现了类似于 TCP的多路数据流、传输可靠性等功能，我们把这套功能称为`QUIC`协议。\n![alt](http://img.carrotwu.com/FrH9n_zf9BO-UbpYmrm1MuyB5d8a)\n\n1. 实现了类似TCP的流量控制、传输可靠性的功能。虽然UDP不提供可靠性的传输，但QUIC在UDP的基础之上增加了⼀层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他⼀些TCP中存在的特性。\n2. 集成了TLS加密功能。⽬前QUIC使⽤的是TLS1.3，相较于早期版本TLS1.3有更多的优点，其中最重要的⼀点是减少了握⼿所花费的RTT个数。\n3. 实现了HTTP/2中的多路复⽤功能。和TCP不同，QUIC实现了在同⼀物理连接上可以有多个独⽴的逻辑数据流。实现了数据流的单独传输，就解决了TCP中队头阻塞的问题。\n4. 实现了快速握⼿功能。由于QUIC是基于UDP的，所以QUIC可以实现使⽤0-RTT或者1-RTT来建⽴连接，这意味着QUIC可以⽤最快的速度来发送和接收数据，这样可以⼤⼤提升⾸次打开⻚⾯的速度。\n', 1, 'http,https', 'http学习笔记', 1, '2019-11-20 10:51:38', '2020-04-28 10:29:32', NULL, 'http://img.carrotwu.com/FsZpbmjd1aTiLGd_oZw-0a0Wd8XF', NULL);
INSERT INTO `article` VALUES (15, '之前学习了ts的几个高级类型，这次顺着热度把ts的几个内置工具类型自己实现了一篇', 2, '# typescript内置工具类型\n\n\n## Partial\n\n```typescript\n// Partial\n  interface Todo {\n    title: string;\n    description: string;\n  }\n\n  type MyPartial<T> = { [P in keyof T]?: T[P] };\n  type TypeTodo1 = Partial<Todo>;\n  type TypeTodo2 = MyPartial<Todo>;\n```\n\n## Readonly\n\n```typescript\n// Readonly\n  interface Todo {\n    title: string;\n    description: string;\n  }\n\n  type MyReadonly<T> = { readonly [P in keyof T]: T[P] };\n  type TypeTodo1 = Readonly<Todo>;\n  type TypeTodo2 = MyReadonly<Todo>;\n```\n\n## Record\n\n```typescript\n// Record\n  interface PageInfo {\n    title: string;\n    description: string;\n  }\n\n  type Page = \"home\" | \"about\" | \"contact\";\n\n  type MyRecord<T extends string | number | symbol, U> = { [P in T]: U };\n  type TypeTodo1 = Record<Page, PageInfo>;\n  type TypeTodo2 = MyRecord<Page, PageInfo>;\n```\n\n## Pick\n\n```typescript\n// Pick\n  interface Todo {\n    title: string;\n    description: string;\n  }\n\n  type MyPick<T, U extends keyof T> = { [P in U]: T[P] };\n  type TypeTodo1 = Pick<Todo, \"description\">;\n  type TypeTodo2 = MyPick<Todo, \"description\">;\n```\n\n## Exclude\n\n```typescript\n// Exclude\n  type MyExclude<T, U> = T extends U ? never : T;\n  type T0 = Exclude<\"a\" | \"b\" | \"c\", \"a\">; // \"b\" | \"c\"\n  type T1 = Exclude<\"a\" | \"b\" | \"c\", \"a\" | \"b\">; // \"c\"\n  type A2 = MyExclude<\"a\" | \"b\" | \"c\", \"a\">;\n```\n\n## Omit\n\n```typescript\n// Omit\n  interface Todo {\n    title: string;\n    description: string;\n    completed: boolean;\n  }\n  type MyOmit<T, U extends keyof T> = Pick<T, Exclude<keyof T, U>>;\n  type TodoPreview = Omit<Todo, \"description\">;\n  type TodoPreview2 = MyOmit<Todo, \"description\">;\n```\n\n## Extract\n\n```typescript\n// Extract\n  type MyExtract<T, U> = T extends U ? T : never;\n  type T0 = Extract<\"a\" | \"b\" | \"c\", \"a\" | \"f\">; // \"a\"\n  type T01 = MyExtract<\"a\" | \"b\" | \"c\", \"a\" | \"f\">; // \"a\"\n  type T1 = Extract<string | number | (() => void), Function>; // () => void\n```\n\n## NonNullable\n\n```typescript\n// NonNullable\n  type MyNonNullable<T> = Exclude<T, null>;\n  type T0 = NonNullable<string | number | undefined>; // string | number\n  type T1 = NonNullable<string[] | null | undefined>; // string[]\n```\n\n## ReturnType\n\n```typescript\n// ReturnType\n  type MyReturnType<T extends (...args: any[]) => any> = T extends (\n    ...args: any[]\n  ) => infer P\n    ? P\n    : any;\n  type MyReturnParamsType<T extends (...args: any[]) => any> = T extends (\n    ...args: infer P\n  ) => any\n    ? P\n    : any;\n  type T0 = ReturnType<() => string>; // string\n  type T1 = ReturnType<(s: string) => void>; // void\n  type T2 = ReturnType<<T>() => T>; // unknown\n  type T3 = ReturnType<<T extends U, U extends number[]>() => T>; // number[]\n  type T5 = ReturnType<any>; // any\n  type T6 = ReturnType<never>; // any\n  //type T7 = ReturnType<string>; // Error\n  //type T8 = ReturnType<Function>; // Error\n  type T9 = MyReturnParamsType<(a: boolean, ...args: string[]) => void>;\n```\n\n## InstanceType\n\n```typescript\n// InstanceType\n  interface Obj {\n    a: string;\n    b: boolean;\n  }\n  interface TestA {\n    new (paramsA: string, paramsB: boolean): Obj;\n  }\n\n  type MyInstanceType<T extends new (...args: any[]) => any> = T extends new (\n    ...args: any[]\n  ) => infer P\n    ? P\n    : any;\n  type MyInstanceParamsType<\n    T extends new (...args: any[]) => any\n  > = T extends new (...args: infer P) => any ? P : any;\n  class C {\n    x = 0;\n    y = 0;\n  }\n\n  type T0 = InstanceType<typeof C>; // C\n  type T1 = InstanceType<any>; // any\n  type T2 = InstanceType<never>; // any\n  //type T3 = InstanceType<string>;  // Error\n  //type T4 = InstanceType<Function>;  // Error\n  type T5 = MyInstanceParamsType<TestA>;\n```\n', 1, 'typescript', 'ts内置工具类型实现', 1, '2019-11-25 16:04:32', '2019-11-25 16:06:16', '2019-11-25 16:06:31', 'http://img.carrotwu.com/Fm5DKNpSui4HwPDfNrIRxerKUgtp', NULL);
INSERT INTO `article` VALUES (16, '之前学习了ts的几个高级类型，这次顺着热度把ts的几个内置工具类型自己实现了一遍。其实也不难，都是之前讲过的索引类型，映射类型，条件类型，infer的组合应用而已', 18, '\n## Partial\n**构造类型T，并将它所有的属性设置为可选的。它的返回类型表示输入类型的所有子类型。**  \n\n```typescript\n// Partial\n  interface Todo {\n    title: string;\n    description: string;\n  }\n\n  type MyPartial<T> = { [P in keyof T]?: T[P] };\n  type TypeTodo1 = Partial<Todo>;\n  type TypeTodo2 = MyPartial<Todo>;\n```\n\n## Readonly\n**构造类型T，并将它所有的属性设置为readonly，也就是说构造出的类型的属性不能被再次赋值。**  \n\n```typescript\n// Readonly\n  interface Todo {\n    title: string;\n    description: string;\n  }\n\n  type MyReadonly<T> = { readonly [P in keyof T]: T[P] };\n  type TypeTodo1 = Readonly<Todo>;\n  type TypeTodo2 = MyReadonly<Todo>;\n```\n\n## Record\n**构造一个类型，其属性名的类型为K，属性值的类型为T。这个工具可用来将某个类型的属性映射到另一个类型上。**  \n\n```typescript\n// Record\n  interface PageInfo {\n    title: string;\n    description: string;\n  }\n\n  type Page = \"home\" | \"about\" | \"contact\";\n\n  type MyRecord<T extends string | number | symbol, U> = { [P in T]: U };\n  type TypeTodo1 = Record<Page, PageInfo>;\n  type TypeTodo2 = MyRecord<Page, PageInfo>;\n```\n\n## Pick\n**从类型T中挑选部分属性K来构造类型。**  \n\n```typescript\n// Pick\n  interface Todo {\n    title: string;\n    description: string;\n  }\n\n  type MyPick<T, U extends keyof T> = { [P in U]: T[P] };\n  type TypeTodo1 = Pick<Todo, \"description\">;\n  type TypeTodo2 = MyPick<Todo, \"description\">;\n```\n\n## Exclude\n**从类型T中剔除所有可以赋值给U的属性，然后构造一个类型。**  \n\n```typescript\n// Exclude\n  type MyExclude<T, U> = T extends U ? never : T;\n  type T0 = Exclude<\"a\" | \"b\" | \"c\", \"a\">; // \"b\" | \"c\"\n  type T1 = Exclude<\"a\" | \"b\" | \"c\", \"a\" | \"b\">; // \"c\"\n  type A2 = MyExclude<\"a\" | \"b\" | \"c\", \"a\">;\n```\n\n## Omit\n**从类型T中获取所有属性，然后从中剔除K属性后构造一个类型。**  \n\n```typescript\n// Omit\n  interface Todo {\n    title: string;\n    description: string;\n    completed: boolean;\n  }\n  type MyOmit<T, U extends keyof T> = Pick<T, Exclude<keyof T, U>>;\n  type TodoPreview = Omit<Todo, \"description\">;\n  type TodoPreview2 = MyOmit<Todo, \"description\">;\n```\n\n## Extract\n**从类型T中提取所有可以赋值给U的类型，然后构造一个类型。**  \n\n```typescript\n// Extract\n  type MyExtract<T, U> = T extends U ? T : never;\n  type T0 = Extract<\"a\" | \"b\" | \"c\", \"a\" | \"f\">; // \"a\"\n  type T01 = MyExtract<\"a\" | \"b\" | \"c\", \"a\" | \"f\">; // \"a\"\n  type T1 = Extract<string | number | (() => void), Function>; // () => void\n```\n\n## NonNullable\n从类型T中剔除null和undefined，然后构造一个类型。  \n\n```typescript\n// NonNullable\n  type MyNonNullable<T> = Exclude<T, null>;\n  type T0 = NonNullable<string | number | undefined>; // string | number\n  type T1 = NonNullable<string[] | null | undefined>; // string[]\n```\n\n## ReturnType\n**由函数类型T的返回值类型构造一个类型。**  \n\n```typescript\n// ReturnType\n  type MyReturnType<T extends (...args: any[]) => any> = T extends (\n    ...args: any[]\n  ) => infer P\n    ? P\n    : any;\n  type MyReturnParamsType<T extends (...args: any[]) => any> = T extends (\n    ...args: infer P\n  ) => any\n    ? P\n    : any;\n  type T0 = ReturnType<() => string>; // string\n  type T1 = ReturnType<(s: string) => void>; // void\n  type T2 = ReturnType<<T>() => T>; // unknown\n  type T3 = ReturnType<<T extends U, U extends number[]>() => T>; // number[]\n  type T5 = ReturnType<any>; // any\n  type T6 = ReturnType<never>; // any\n  //type T7 = ReturnType<string>; // Error\n  //type T8 = ReturnType<Function>; // Error\n  type T9 = MyReturnParamsType<(a: boolean, ...args: string[]) => void>;\n```\n\n## InstanceType\n**由构造函数类型T的实例类型构造一个类型。**  \n\n```typescript\n// InstanceType\n  interface Obj {\n    a: string;\n    b: boolean;\n  }\n  interface TestA {\n    new (paramsA: string, paramsB: boolean): Obj;\n  }\n\n  type MyInstanceType<T extends new (...args: any[]) => any> = T extends new (\n    ...args: any[]\n  ) => infer P\n    ? P\n    : any;\n  type MyInstanceParamsType<\n    T extends new (...args: any[]) => any\n  > = T extends new (...args: infer P) => any ? P : any;\n  class C {\n    x = 0;\n    y = 0;\n  }\n\n  type T0 = InstanceType<typeof C>; // C\n  type T1 = InstanceType<any>; // any\n  type T2 = InstanceType<never>; // any\n  //type T3 = InstanceType<string>;  // Error\n  //type T4 = InstanceType<Function>;  // Error\n  type T5 = MyInstanceParamsType<TestA>;\n```\n', 1, 'typescript', 'ts内置工具类型实现', 1, '2019-11-25 16:06:11', '2020-09-17 09:52:43', NULL, 'http://img.carrotwu.com/Fm5DKNpSui4HwPDfNrIRxerKUgtp', NULL);
INSERT INTO `article` VALUES (17, '在编写工具类型的过程中频繁接触到unknown,never这两个类型，这篇文章用来好好搞清楚它们三者之前的区别', 23, '## any,unknown和never\n`any`,`unknown`是所有非空集合的超级类型(数学上称为全集)，什么类型都可以赋值给这两个类型，又把这两个类型称为顶级类型。\n`never`代表空集合，任何值都不能冠以类型，因此也被称为低端集合。  \n底端和顶端集合可分别借助操作符 union（|） 和 intersection（&）来识别，比如，给定类型 T，则：\n```ts\n// [1,2] | [2,3] => [1,3] \n// [1,2] | []什么都没有 => [1,2]\nT | never => T \n// [1,2] & [-无穷，+无穷] => [1,2]\nT & unknown => T\n```\n\n### any\n一般情况下，我们并不知道某个变量的具体类型或者在编程过程中，因为一些原因我们并不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。一般这种情况为我们就会使用`any`这个类型声明\n```ts\nlet a:any = \'123\'\na = 123\na = {\n    a: 123\n}\n```\n`any`类型是多人协作项目的大忌，很可能把`Typescript`变成`AnyScript`，通常在不得已的情况下，不应该首先考虑使用此类型。\n\n### unknown\n`unknown` 和 `any` 的主要区别是 `unknown` 类型会更加严格:在对unknown类型的值执行大多数操作之前,我们必须进行某种形式的检查,而在对 `any` 类型的值执行操作之前,我们不必进行任何检查。  \n直接使用 `unknown` 没什么意义，但是你可借助“类型守卫”在块级作用域内收敛类型，并由此获得准确的类型检查。什么意思呢，具体可以下面的例子:  \n```ts\nfunction getValue(params: unknown): string {\n  if (Array.isArray(params)) {\n    return `type is array, value is ${params.join(\",\")}`;\n  }\n  if (typeof params === \"number\") {\n    return `type is number, value is ${params / 1}`;\n  }\n  if (params instanceof Date) {\n    return `type is Date, time is ${params.getTime()}`;\n  }\n  return \"test\";\n}\n```\n`unknown`和`any`十分相似，它们都可以是任何类型。但是`unknown`相比会更加安全，`unknown`会进行类型检查并且类型被确定是某个类型之前,它不能被进行任何操作比如实例化、getter、函数执行等等。\n```ts\nlet value:unknown\nvalue() \nvalue.b\nvalue.a()\n// 上述三个全部报错\n\n// any 可行\nlet anyValue:any \nanyValue()\nanyValue.b\nanyValue.a()\n```\n\n### never\n`never` 类型表示的是那些永不存在的值的类型，never 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 `never` 的子类型或可以赋值给 `never` 类型（除了never本身之外）,`never` 用于那些永不可发生的情况\n```ts\n// 仅仅只是抛出异常的函数\n// 以往返回值会返回void 看起来没问题\nfunction error1(message: string): void {\n  // 假设我在这之前就进行了返回void 不会报错 但是函数的使用就不正确了\n  // return void\n  throw new Error(message);\n}\n\n// 使用never\nfunction error2(message: string): never {\n    // 这之前返回void 会报错 因为任何类型赋值给void都会报错\n  return void 0\n  throw new Error(message);\n}\n\n```\n\n### 如何在 never、unknown、any 之间作出选择\n1. 在那些将或既不能取得任何值的地方，使用 `never`\n2. 在那些将或既取得任意值，但不知类型的地方，请使用 `unknown`\n3. 除非你有意忽略类型检查，不要使用 `any`', 1, 'typescript', 'ts中any,unknown和never的区别', 1, '2019-11-25 22:32:02', '2020-02-28 13:49:53', NULL, 'http://img.carrotwu.com/Fm5DKNpSui4HwPDfNrIRxerKUgtp', NULL);
INSERT INTO `article` VALUES (18, '在阅读极客时间《浏览器工作原理与实践》中的学习笔记，好记性不如烂笔头。', 72, '>在阅读极客时间《浏览器工作原理与实践》中的学习笔记，好记性不如烂笔头。\n\n## 进程与线程\n现代浏览器以chrome为例都是多线程甚至是多进程的。⼀个进程就是⼀个程序的运⾏实例，一个进程中可以有多个线程同时存在。\n1. 进程中的任意⼀线程执⾏出错，都会导致整个进程的崩溃。\n2. 线程之间共享进程中的数据。\n3. 当⼀个进程关闭之后，操作系统会回收进程所占⽤的内存。\n4. 进程之间的内容相互隔离。\n![alt](http://img.carrotwu.com/FtXbqYDnjMIvqMUnJ9zWUmJgBOjY)\n\n从图中可以看出，最新的Chrome浏览器包括：1个浏览器（Browser）主进程、1个 GPU 进程、1个⽹络（NetWork）进程、多个渲染进程和多个插件进程。\n1. 浏览器进程。主要负责界⾯显⽰、⽤⼾交互、⼦进程管理，同时提供存储等功能。\n2. 渲染进程。核⼼任务是将 HTML、CSS 和 JavaScript 转换为⽤⼾可以与之交互的⽹⻚，排版引擎Blink和JavaScript引擎V8都是运⾏在该进程中，默认情况下，Chrome会为每个Tab标签创建⼀个渲染进程。出于安全考虑，渲染进程都是运⾏在沙箱模式下。\n3. GPU进程。其实，Chrome刚开始发布的时候是没有GPU进程的。⽽GPU的使⽤初衷是为了实现3D CSS的效果，只是随后⽹⻚、Chrome的UI界⾯都选择采⽤GPU来绘制，这使得GPU成为浏览器普遍的需求。最后，Chrome在其多进程架构上也引⼊了GPU进程。\n4. ⽹络进程。主要负责⻚⾯的⽹络资源加载，之前是作为⼀个模块运⾏在浏览器进程⾥⾯的，直⾄最近才独⽴出来，成为⼀个单独的进程。\n5. 插件进程。主要是负责插件的运⾏，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和⻚⾯造成影响。\n\n## 输入url之后发生的过程\n1. 用户输入url，浏览器会进行判断是进行请求还是搜索内容，如果是搜索内容就会拼接上合理的协议http或者https把url请求丢给网络请求进程。\n2. 网络进程接收到url，判断是否有缓存,如果有的话判断是强缓存还是写上缓存。如果是强缓存直接使用本地缓存，返回200状态码链接结束。如果是协商缓存或者没有缓存就要向服务器请求。（协商缓存头`cache-control` 属性值`no-store`禁止缓存, `no-cache`允许缓存但必须走协商缓存）\n3. dns解析。判断是否有dns缓存，从浏览器缓存->本机host缓存->代理商缓存->根域名->顶级域名->二级域名开始直到找到服务器的ip地址。\n4. 获取到服务器ip地址，发起http请求，如果是https的话还会建立ssl/tsl链接。在经过三次握手，交换syn，seq等三次数据包之后建立起http连接。\n5. 客户端拼接请求头和请求体传输给客户端，其中是协商缓存的话客户端还会拼接`etag last-modified`等请求头。\n6. 服务端接受到数据进行相应，拼接相应的响应头和响应状态码给服务端（其中304写上缓存允许使用缓存， 301永久重定向等等）。\n7. 服务端根据需要可以选择返回`connection: close`经过四次挥手关闭http链接，或者使用`connection: keep-alive`保持长链接进行复用http。\n8. 客户端根据返回的`content-type`相关类型进行相应的操作。\n9. 接受到是html或者css文件会交给渲染进程进行渲染操作，开始下载相应的html或者css文件。\n10. 边下载边解析，其中把html转化为`DomTree`，把css转化为`styleSheet`。两者解析完成会合并成`RenderTree`,其中遇到js文件时会进行堵塞dom节点的渲染执行。\n11. 生成的`RenderTree`经过layout计算出每个节点的位置，不断进行回流重绘最终形成我们看到的页面。\n\n## 减少回流重绘的方法\n1. 通过style来一次性控制样式。\n2. 批量合并多次修改style的操作为一次，减少回流。\n3. 通过`createDocumentFragment`进行修改样式操作，之后一次性替换。\n4. 使用`transfrom`等css属性进行样式修改。\n\n\n### 使用transform能够优化的原因\n![alt](http://img.carrotwu.com/Fp27Ux7CveG1KLc_oPfL6KxMcZMa)\n\n在上图中，我们使⽤了CSS的transform来实现动画效果，这可以避开重排和重绘阶段，直接在⾮主线程上执⾏合成动画操作。这样的效率是最⾼的，因为是在⾮主线程上合成，并没有占⽤主线程的资源，另外也避开了布局和绘制两个⼦阶段，所以相对于重绘和重排，合成能⼤⼤提升绘制效率。\n\n## js的内存机制\n\n### js是一门动态类型语言\n![alt](http://img.carrotwu.com/FvMBL49C3nkr9vby3mL_5wCYDRVM)\n\n在声明变量之前需要先定义变量类型，我们把这种在使⽤之前就需要确认其变量数据类型的称为**静态语⾔**，相反地，我们把在运⾏过程中需要检查数据类型的语⾔称为**动态语⾔**。因此js其实是一门动态类型语言，所以在运行过程中，变量类型是可以发生变化的。另外，⽀持隐式类型转换的语⾔称为**弱类型语⾔**，不⽀持隐式类型转换的语⾔称为**强类型语⾔**，因为隐形转换的存在js也是一门弱类型语言。\n\n### js的数据类型\n![alt](http://img.carrotwu.com/Fr1FhjZa1z12jvaB44nKtJP64CVV)\n\nJavaScript中的数据类型⼀种有8种，它们分别是：\n其中，我们把除了object意外的其中类型称为原始类型，object对象称为引用类型，之所以把它们区分为两种不同的类型，是因为它们在内存中存放的位置不⼀样。\n\n### 内存空间\n![alt](http://img.carrotwu.com/FqQ0h1Xp1pc6Sl2rwlaKbwgM-53i)\n\n在`JavaScript`的执⾏过程中， 主要有三种类型内存空间，分别是代码空间、栈空间和堆空间。\n\n### 栈空间和堆空间\n原始类型的数据值都是直接保存在“栈”中的，引⽤类型的值是存放在“堆”中的，在栈空间中变量值只是保留了对象的引⽤地址而已。\n所以通常情况下，栈空间都不会设置太⼤，主要⽤来存放⼀些原始类型的⼩数据。⽽引⽤类型的数据占⽤的空间都⽐较⼤，所以这⼀类数据会被存放到堆中，堆空间很⼤，能存放很多⼤的数据，不过缺点是分配内存和回收内存都会占⽤⼀定的时间。\n在`JavaScript`中，赋值操作和其他语⾔有很⼤的不同，原始类型的赋值会完整复制变量值，⽽引⽤类型的赋值是复制引⽤地址。在`JavaScript`中将⼀个原始类型的变量a赋值给b，那么a和b会相互独⽴、互不影响；但\n![alt](http://img.carrotwu.com/FssI3loGfd7AJ3vL6DjYMO3Ccl5D)\n\n是将引⽤类型的变量a赋值给变量b，那会导致a、b两个变量都同时指向了堆中的同⼀块数据。\n\n\n## 垃圾回收策略\n通常情况下，垃圾数据回收分为⼿动回收和⾃动回收两种策略。\n1. 如`C/C++`就是使⽤⼿动回收策略，何时分配内存、何时销毁内存都是由代码控制的。\n2. `JavaScript`、`Java`、`Python`等语⾔，产⽣的垃圾数据是由垃圾回收器来释放的，并不需要⼿动通过代码来释放。\n\n### 调⽤栈中的数据是如何回收的\n我们都知道，执行上下文是保存在栈中的，当⼀个函数可执行代码执⾏结束之后，`JavaScript`引擎会通过向下移动ESP来销毁该函数保存在栈中的执⾏上下⽂。\n\n### 堆中的数据是如何回收的\n要回收堆中的垃圾数据，就需要⽤到`JavaScript`中的垃圾回收器\n\n#### 代际假说和分代收集\n代际假说有以下两个特点：\n\n1. 第⼀个是⼤部分对象在内存中存在的时间很短，简单来说，就是很多对象⼀经分配内存，很快就变得不可访问；\n2. 第⼆个是不死的对象，会活得更久。\n所以，在V8中会把堆分为**新⽣代**和**⽼⽣代**两个区域，新⽣代中存放的是⽣存时间短的对象，⽼⽣代中存放的⽣存时间久的对象。\n1. 副垃圾回收器，主要负责新⽣代的垃圾回收。\n2. 主垃圾回收器，主要负责⽼⽣代的垃圾回收。\n\n### 垃圾回收器的⼯作流程\n现在你知道了V8把堆分成两个区域⸺新⽣代和⽼⽣代，并分别使⽤两个不同的垃圾回收器。其实不论什么类型的垃圾回收器，它们都有⼀套共同的执⾏流程。\n1. 第⼀步是标记空间中活动对象和⾮活动对象。所谓活动对象就是还在使⽤的对象，⾮活动对象就是可以进⾏垃圾回收的对象。\n2. 第⼆步是回收⾮活动对象所占据的内存。其实就是在所有的标记完成之后，统⼀清理内存中所有被标记为可回收的对象。\n3. 第三步是做内存整理。⼀般来说，频繁回收对象后，内存中就会存在⼤量不连续空间，我们把这些不连续的内存空间称为内存碎⽚。当内存中出现了⼤量的内存碎⽚之后，如果需要分配较⼤连续内存的时候，就有可能出现内存不⾜的情况。\n\n## 编译器和解释器：V8是如何执⾏⼀段JavaScript代码的？\n要深⼊理解V8的⼯作原理，你需要搞清楚⼀些概念和原理，⽐如接下来我们要详细讲解的**编译器（Compiler）、解释器（Interpreter）、抽象语法树（AST）、字节码（Bytecode）、即时编译器（JIT）**等概念，都是你需要重点关注的。\n\n### 编译器和解释器\n编译型语⾔在程序执⾏之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的⼆进制⽂件，这样每次运⾏程序时，都可以直接运⾏该⼆进制⽂件，⽽不需要再次重新编译了。⽐如C/C++、GO等\n都是编译型语⾔。\n\n⽽由解释型语⾔编写的程序，在每次运⾏时都需要通过解释器对程序进⾏动态解释和执⾏。⽐如`Python、JavaScript`等都属于解释型语⾔。\n那编译器和解释器是如何“翻译”代码的呢？具体流程你可以参考下图：\n![alt](http://img.carrotwu.com/FqiDl5rRNxPW9h4ibQ3QBtS9nzht)\n\n\n## V8是如何执⾏⼀段JavaScript代码的\n![alt](http://img.carrotwu.com/FkSNKAfFh1V88-a8Xyqx8RFKtNiS)\n\n从图中可以清楚地看到，V8在执⾏过程中既有解释器`Ignition`，⼜有编译器`TurboFan`，那么它们是如何配合去执⾏⼀段`JavaScript`代码的呢? 下⾯我们就按照上图来⼀⼀分解其执⾏流程。\n### ⽣成抽象语法树（AST）和执⾏上下⽂\n1. 第⼀阶段是分词（`tokenize`），⼜称为词法分析，其作⽤是将⼀⾏⾏的源码拆解成⼀个个`token`。所谓token，指的是语法上不可能再分的、最⼩的单个字符或字符串。你可以参考下图来更好地理解什么token。\n![alt](http://img.carrotwu.com/FkmsIrXx6yGdyZ3fqSHOU3mie2uC)\n\n2. 第⼆阶段是解析（`parse`），⼜称为语法分析，其作⽤是将上⼀步⽣成的token数据，根据语法规则转为AST。\n\n### 生成字节码\n字节码就是介于AST和机器码之间的⼀种代码。但是与特定类型的机器码⽆关，字节码需要通过解释器将其转换为机器码后才能执⾏。v8最开始是没有生成字节码而是直接生成机器码的，但是因为手机内存太小执行效率不高的原因就转为了先编译成字节码。\n![alt](http://img.carrotwu.com/FiAg3rbUP1AMxgwNPS7IsuYqwVvT)\n\n从图中可以看出，机器码所占⽤的空间远远超过了字节码，所以使⽤字节码可以减少系统的内存使⽤。\n\n### 执行代码\n问题： “V8执⾏时间越久，执⾏效率越⾼“\n通常，如果有⼀段第⼀次执⾏的字节码，解释器`Ignition`会逐条解释执⾏。在执⾏字节码的过程中，如果发现有热点代码`（HotSpot）`，⽐如⼀段代码被重复执⾏多次，这种就称为热点代码，那么后台的编译器`TurboFan`就会把该段热点的字节码编译为⾼效的机器码，然后当再次执⾏这段被优化的代码时，只需要执⾏编译后的机器码就可以了，这样就⼤⼤提升了代码的执⾏效率。\n简单说就是随着执行时间越长，重复的代码（热点代码）就会直接北编译成机器码，跳过了字节码这个阶段。这个其实就是**即时编译（JIT）**技术的由来。\n![alt](http://img.carrotwu.com/FkpZIFlPBJomkzumk1-sKHge7BOV)\n\n1. 解释器-分词解析成ast-是否为热点代码不是的话通过解析器解释器转化为字节码。\n2. 编译器-如果是热点代码直接通过编译器转回为机器码。\n\n## 消息队列和事件循环\n浏览器⻚⾯是由消息队列和事件循环系统来驱动的。\n\n渲染主线程会频繁接收到来⾃于IO线程的⼀些任务，接收到这些任务之后，渲染进程就需要着⼿处理，⽐如接收到资源加载完成的消息后，渲染进程就要着⼿进⾏DOM解析了；接收到⿏标点击的消息后，渲染主线程就要开始执⾏相应的JavaScript脚本来处理该点击事件。\n### 事件循环\n要想在线程运⾏过程中，能接收并执⾏新的任务，就需要采⽤事件循环机制。浏览器会在每次渲染完成之后，从消息队列中拿取所有任务依次执行。\n### 消息队列\n⼀个通⽤模式是使⽤消息队列。在解释如何实现之前，我们先说说什么是消息队列，可以参考下图：\n![alt](http://img.carrotwu.com/Fkq2mTvPvZLj9wneEOLabDGZyatB)\n\n从图中可以看出，消息队列是⼀种数据结构，可以存放要执⾏的任务。它符合队列“**先进先出**”的特点，也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。\n\n### 完整的渲染进程\n![alt](http://img.carrotwu.com/Fm2sijKXQIuOM1k0Xyx_5rH2O6Tg)\n\n1. 消息队列用于保存需要执行的任务。\n2. 渲染进程存在一个定时任务（时间循环），发现只有消息队列有任务就拿过来执行。\n3. 另外的事件处理线程或者计时器线程在完成之后通过**IO线程**把回调插入消息队列中\n4. 对于其他进程比如浏览器进程的点击或者网络进程，渲染进程专⻔有⼀个IO线程⽤来接收其他进程传进来的消息。\n\n## 宏任务和微任务\n\n### 宏任务\n宏任务包括\n1. 渲染事件（如解析DOM、计算布局、绘制）；\n2. ⽤⼾交互事件（如⿏标点击、滚动⻚⾯、放⼤缩⼩等）；\n3. JavaScript脚本执⾏事件；\n4. ⽹络请求完成、⽂件读写完成事件。\n5. 定时器setTimeout和setInterval\n6. IO事件\n\n### 微任务\n**微任务就是⼀个需要异步执⾏的函数，执⾏时机是在主函数执⾏结束之后、当前宏任务结束之前。每次宏任务结束前都会去查询微任务队列，直到微任务队列为空，这时候会进行浏览器的渲染。**\n我们知道当JavaScript执⾏⼀段脚本的时候，V8会为其创建⼀个全局执⾏上下⽂，在创建全局执⾏上下⽂的同时，V8引擎也会在内部创建⼀个微任务队列。顾名思义，这个微任务队列就是⽤来存放微任务的，所以在浏览器把可执行代码推入栈的时候都会创建一个微任务队列。在现代浏览器⾥⾯，产⽣微任务有两种⽅式。\n1. 第⼀种⽅式是使⽤`MutationObserver`监控某个DOM节点，然后再通过JavaScript来修改这个节点，或者为这个节点添加、删除部分⼦节点，当DOM节点发⽣变化时，就会产⽣DOM变化记录的微任务。\n2. 第⼆种⽅式是使⽤Promise，当调⽤`Promise.resolve()`或者`Promise.reject()`的时候，也会产⽣微任务。\n通常情况下，在当前宏任务中的JavaScript快执⾏完成时，也就在JavaScript引擎准备退出全局执⾏上下⽂并清空调⽤栈的时候，JavaScript引擎会检查全局执⾏上下⽂中的微任务队列，然后按照顺序执⾏队列中的\n微任务。WHATWG把执⾏微任务的时间点称为**检查点**。当然除了在退出全局执⾏上下⽂式这个检查点之外，还有其他的检查点，不过不是太重要，这⾥就不做介绍了。\n\n如果在执⾏微任务的过程中，产⽣了新的微任务，同样会将该微任务添加到微任务队列中，**V8引擎⼀直循环执⾏微任务队列中的任务，直到队列为空才算执⾏结束。也就是说在执⾏微任务过程中产⽣的新的微任务并不会推迟到下个宏任务中执⾏，⽽是在当前的宏任务中继续执⾏**。\n![alt](http://img.carrotwu.com/FrKYgE3Y1yu_gVnCpqd1OtsmIS0u)\n\n以上就是微任务的⼯作流程，从上⾯分析我们可以得出如下⼏个结论：\n\n1. 微任务和宏任务是绑定的，每个宏任务在执⾏时，会创建⾃⼰的微任务队列。\n2. 微任务的执⾏时⻓会影响到当前宏任务的时⻓。\n3. 在⼀个宏任务中，分别创建⼀个⽤于回调的宏任务和微任务，⽆论什么情况下，微任务都早于宏任务执⾏。\n\n### 监听DOM变化⽅法演变MutationObserve\n`MutationObserve`用来检测dom节点的变化，一旦dom节点发生变化就会触发相应的回调。相比于之前的发布观察者模式`Mutation Event`。`MutationObserver`将响应函数改成异步调⽤，可以不⽤在每次DOM变化都触发异步调⽤，⽽是等多次DOM变化后，⼀次触发异步调⽤，并且还会使⽤⼀个数据结构来记录这期间所有的DOM变化。这样即使频繁地操纵DOM，也不会对性能造成太⼤的影响。\n\n## DOM树：JavaScript是如何影响DOM树构建的\n\n### DOM树如何⽣成\n在渲染引擎内部，有⼀个叫HTML解析器`（HTMLParser）`的模块，它的职责就是负责将HTML字节流转换为DOM结构。在浏览器边下载的时候，html解析器也会进行dom树的构建\n![alt](http://img.carrotwu.com/FpaNPSO7Y89mdlH9NtwJWGtSiQXr)\n\n1. 通过分词器将字节流转换为`Token`。\n2. ⾄于后续的第⼆个和第三个阶段是同步进⾏的，需要将Token解析为DOM节点，并将DOM节点添加到DOM树中。\n\nasync和defer虽然都是异步的，不过还有⼀些差异，使⽤async标志的脚本⽂件⼀旦加载完成，会⽴即执⾏；⽽使⽤了defer标记的脚本⽂件，需要等到DOMContentLoaded事件之后执⾏。\n\n>截取了一段精彩评论\n\n1. CSS不阻塞dom的生成。\n2. CSS不阻塞js的加载，但是会阻塞js的执行。\n3. js会阻塞dom的生成，也就是会阻塞页面的渲染，那么css也有可能会阻塞页面的渲染。\n4. 如果把CSS放在文档的最后面加载执行，CSS不会阻塞DOM的生成，也不会阻塞JS，但是浏览器在解析完DOM后，要花费额外时间来解析CSS，而不是在解析DOM的时候，并行解析CSS。并且浏览器会先渲染出一个没有样式的页面，等CSS加载完后会再渲染成一个有样式的页面，页面会出现明显的闪动的现象。所以应该把CSS放在文档的头部，尽可能的提前加载CSS；把JS放在文档的尾部，这样JS也不会阻塞页面的渲染。CSS会和JS并行解析，CSS解析也尽可能的不去阻塞JS的执行，从而使页面尽快的渲染完成。\n\n## 分层和合成机制：为什么CSS动画⽐JavaScript⾼效？\n\n### 浏览器的渲染流程\n除去网络资源获取的步骤，我们理解的 Web 页面的展示，一般可以分为`构建 DOM 树、构建渲染树、布局、绘制、渲染层合成`几个步骤。\n构建 DOM 树：浏览器将 HTML 解析成树形结构的 DOM 树，一般来说，这个过程发生在页面初次加载，或页面 JavaScript 修改了节点结构的时候。\n\n1. 构建渲染树：浏览器将 CSS 解析成树形结构的 CSSOM 树，再和 DOM 树合并成渲染树。\n2. 布局（Layout）：浏览器根据渲染树所体现的节点、各个节点的CSS定义以及它们的从属关系，计算出每个节点在屏幕中的位置。Web 页面中元素的布局是相对的，在页面元素位置、大小发生变化，往往会导致其他节点联动，需要重新计算布局，这时候的布局过程一般被称为回流（Reflow）。\n3. 绘制（Paint）：遍历渲染树，调用渲染器的 paint() 方法在屏幕上绘制出节点内容，本质上是一个像素填充的过程。这个过程也出现于回流或一些不影响布局的 CSS 修改引起的屏幕局部重画，这时候它被称为重绘（Repaint）。实际上，绘制过程是在多个层上完成的，这些层我们称为渲染层（RenderLayer）。\n4. 渲染层合成（Composite）：多个绘制后的渲染层按照恰当的重叠顺序进行合并，而后生成位图，最终通过显卡展示到屏幕上。\n\n![alt](http://img.carrotwu.com/FhIgN9FoPpr4aF4lH76zRtL9Nzvs)\n\n从图片中不难看出，对于一些需要复杂度高的动画效果中，最好的方式是通过gpu加速提升到合成层，这样子渲染路径会更短，并且动画效果并不会触发回流与重绘。\n### 如何⽣成⼀帧图像\n任意⼀帧的⽣成⽅式，有**回流、重绘和合成**三种⽅式。\n这三种⽅式的渲染路径是不同的，通常**渲染路径越⻓，⽣成图像花费的时间就越多**。⽐如重排，它需要重新根据`CSSOM`和`DOM`来计算布局树，这样⽣成⼀幅图⽚时，会让整个渲染流⽔线的每个阶段都执⾏⼀遍，如果布局复杂的话，就很难保证渲染的效率了。⽽重绘因为没有了重新布局的阶段，操作效率稍微⾼点，但是依然需要重新计算绘制信息，并触发绘制操作之后的⼀系列操作。\n相较于重排和重绘，合成操作的路径就显得⾮常短了，**并不需要触发布局和绘制两个阶段**，如果采⽤了`GPU`，那么合成的效率会⾮常⾼。\n\n### 如何实现合成\n那么一个渲染层满足哪些特殊条件时，才能被提升为合成层呢？这里列举了一些常见的情况：\n1. 3D transforms：translate3d、translateZ 等\n2. video、canvas、iframe 等元素\n3. 通过 Element.animate() 实现的 opacity 动画转换\n4. 通过 СSS 动画实现的 opacity 动画转换\n5. position: fixed\n6. 具有 will-change 属性\n7. 对 opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition\n\n为了提升每帧的渲染效率，Chrome引⼊了分层和合成的机制。那该怎么来理解分层和合成机制呢？\n将**素材分解为多个图层的操作就称为分层**，最后将这些图层**合并到⼀起**的操作就称为合成。所以，分层和合成通常是⼀起使⽤的。\n在Chrome的渲染流⽔线中，分层体现在⽣成布局树之后，渲染引擎会根据布局树的特点将其转换为层树`（Layer Tree）`，层树是渲染流⽔线后续流程的基础结构,所以合成是在回流和重绘后面，路径更加短。\n需要重点关注的是，合成操作是在合成线程上完成的，这也就意味着在执⾏合成操作时，是不会影响到主线程执⾏的。这就是为什么经常主线程卡住了，但是CSS动画依然能执⾏的原因。\n\n### 为什么高效\n1. 使用`css`动画时，浏览器会把当前元素单独设置为一个图层，该元素进行动画时，只会在当前图层进行修改。\n2. 图层的渲染是在另外一个合成线程上进行的，并不会影响主线程。\n3. 合成的操作是在回流和重绘之后（布局和绘制），渲染路径较短，不用重新生成布局树。\n\n## PWA\n\n### Web应⽤ VS 本地应⽤\n\n那相对于本地应⽤，Web⻚⾯到底缺少了什么？\n1. ⾸先，Web应⽤缺少离线使⽤能⼒，在离线或者在弱⽹环境下基本上是⽆法使⽤的。⽽⽤⼾需要的是沉浸式的体验，在离线或者弱⽹环境下能够流畅地使⽤是⽤⼾对⼀个应⽤的基本要求。\n2. 其次，Web应⽤还缺少了消息推送的能⼒，因为作为⼀个App⼚商，需要有将消息送达到应⽤的能⼒。\n3. 最后，Web应⽤缺少⼀级⼊⼝，也就是将Web应⽤安装到桌⾯，在需要的时候直接从桌⾯打开Web应⽤，⽽不是每次都需要通过浏览器来打开。\n针对以上Web缺陷，`PWA`提出了两种解决⽅案：通过引⼊`Service Worker`来试着解决离线存储和消息推送的问题，通过引⼊`manifest.json`来解决⼀级⼊⼝的问题。\n\n### Service Worker\n\n`Service Worker`的主要思想是在**⻚⾯和⽹络之间增加⼀个拦截器，⽤来缓存和拦截请求**。整体结构如下图所⽰：\n![alt](http://img.carrotwu.com/Fi1eaCrrZ9Ts7oXdztQrp53ANoDY)\n\n在没有安装`Service Worker`之前，WebApp都是直接通过⽹络模块来请求资源的。安装了`Service Worker`模块之后，`WebApp`请求资源时，会先通过`Service Worker`，让它判断是返回`Service Worker` 缓存的资源还是重新去⽹络请求资源。⼀切的控制权都交由`Service Worker`来处理。\n\n\n## Web Components\n`WebComponent`是⼀套技术的组合，具体涉及到了`Custom elements`（⾃定义元素）、`Shadow DOM`（影⼦DOM）和`HTML templates`（HTML模板）。\n1. ⾸先，**使⽤template属性来创建模板**。利⽤DOM可以查找到模板的内容，但是模板元素是不会被渲染到⻚⾯上的，也就是说DOM树中的template节点不会出现在布局树中，所以我们可以使⽤template来⾃定义⼀些基础的元素结构，这些基础的元素结构是可以被重复使⽤的。\n2. 其次，我们需要创建⼀个GeekBang的类。查找模板内容；创建影⼦DOM；再将模板添加到影⼦DOM上。\n总之，通过影⼦DOM，我们就实现了CSS和元素的封装，在创建好封装影⼦DOM的类之后，我们就可以使⽤`customElements.define`来⾃定义元素了\n\n```html\n<!DOCTYPE html>\n<html>\n  <body>\n    <!--\n⼀：定义模板\n⼆：定义内部CSS样式\n三：定义JavaScript⾏为\n-->\n    <template id=\"geekbang-t\">\n      <style>\n        p {\n          background-color: brown;\n          color: cornsilk;\n        }\n        div {\n          width: 200px;\n          background-color: bisque;\n          border: 3px solid chocolate;\n          border-radius: 10px;\n        }\n      </style>\n      <div>\n        <p>time.geekbang.org</p>\n        <p>time1.geekbang.org</p>\n      </div>\n      <script>\n        function foo() {\n          console.log(\"inner log\");\n        }\n      </script>\n    </template>\n    <script>\n      class GeekBang extends HTMLElement {\n        constructor() {\n          super();\n          //获取组件模板\n          const content = document.querySelector(\"#geekbang-t\").content;\n          //创建影⼦DOM节点\n          const shadowDOM = this.attachShadow({ mode: \"open\" });\n          //将模板添加到影⼦DOM上\n          shadowDOM.appendChild(content.cloneNode(true));\n        }\n      }\n      customElements.define(\"geek-bang\", GeekBang);\n    </script>\n    <geek-bang></geek-bang>\n    <div>\n      <p>time.geekbang.org</p>\n      <p>time1.geekbang.org</p>\n    </div>\n    <geek-bang></geek-bang>\n  </body>\n</html>\n\n```\n\n## 同源策略\n如果两个URL的**协议、域名和端⼝**都相同，我们就称这两个URL同源,因此只要三者中的一个不相同，我们就称为跨域。同源策略主要表现在DOM、Web数据和⽹络这三个层⾯。\n1. 第⼀个，DOM层⾯。同源策略限制了来⾃不同源的JavaScript脚本对当前DOM对象读和写的操作。\n2. 第⼆个，数据层⾯。同源策略限制了不同源的站点读取当前站点的`Cookie、IndexDB、LocalStorage`等数据。\n3. 第三个，⽹络层⾯。同源策略限制了通过`XMLHttpRequest`等⽅式将站点的数据发送给不同源的站点。\n\n## 跨站脚本攻击（XSS）\n`XSS`攻击是指⿊客往`HTML`⽂件中或者`DOM`中注⼊恶意脚本，从⽽在⽤⼾浏览⻚⾯时利⽤注⼊的恶意脚本对⽤⼾实施攻击的⼀种⼿段。\n1. 存储型XSS攻击。⿊客利⽤站点漏洞将⼀段恶意`JavaScript`代码提交到⽹站的数据库中；然后⽤⼾向⽹站请求包含了恶意`JavaScript`脚本的⻚⾯；当⽤⼾浏览该⻚⾯的时候，恶意脚本就会将⽤⼾的`Cookie`信息等数据上传到服务器。\n2. 反射型XSS攻击。在⼀个反射型`XSS`攻击过程中，恶意`JavaScript`脚本属于⽤⼾发送给⽹站请求中的⼀部分，随后⽹站⼜把恶意`JavaScript`脚本返回给⽤⼾。\n3. 基于DOM的XSS攻击。基于DOM的XSS攻击是不牵涉到⻚⾯Web服务器的。具体来讲，⿊客通过各种⼿段将恶意脚本注⼊⽤⼾的⻚⾯中，⽐如通过⽹络劫持在⻚⾯传输过程中修改HTML⻚⾯的内容。\n\n### 如何阻⽌XSS攻击\n1. 服务器对输⼊脚本进⾏过滤或转码。\n不管是反射型还是存储型XSS攻击，我们都可以在服务器端将⼀些关键的字符进⾏转码,比如`<script>`。\n2. 充分利⽤CSP。（同源策略）\n3. 使⽤HttpOnly属性\n\n## CSRF攻击：跨站请求伪造\n简单来讲，`CSRF`攻击就是⿊客利⽤了⽤⼾的登录状态，并通过第三⽅的站点来做⼀些坏事。例如在浏览其他网站时，有个img标签，因为图片是没有同源策略的所以可以调用已经登陆过网站的接口，例如调用支付宝的转账接口。\n到这⾥，相信你已经知道什么是CSRF攻击了。和XSS不同的是，CSRF攻击不需要将恶意代码注⼊⽤⼾的⻚⾯，仅仅是利⽤服务器的漏洞和⽤⼾的登录状态来实施攻击。\n\n### 如何防⽌CSRF攻击\n\n#### 充分利⽤好Cookie 的 SameSite 属性\n如果是从第三⽅站点发起的请求，那么需要浏览器禁⽌发送某些关键Cookie数据到服务器；如果是同⼀个站点发起的请求，那么就需要保证Cookie数据正常发送。\n\n**SameSite选项通常有Strict、Lax和None三个值**。\n1. Strict最为严格。如果SameSite的值是Strict，那么浏览器会完全禁⽌第三⽅ Cookie。简⾔之，如果你从极客时间的⻚⾯中访问InfoQ的资源，⽽InfoQ的某些Cookie设置了SameSite = Strict的话，那么这些Cookie是不会被发送到InfoQ的服务器上的。只有你从InfoQ的站点去请求InfoQ的资源时，才会带上这些Cookie。\n2. Lax相对宽松⼀点。在跨站点的情况下，从第三⽅站点的链接打开和从第三⽅站点提交Get⽅式的表单这两种⽅式都会携带Cookie。但如果在第三⽅站点中使⽤Post⽅法，或者通过img、iframe等标签加载的URL，这些场景都不会携带Cookie。\n3. ⽽如果使⽤None的话，在任何情况下都会发送Cookie数据。\n\n#### 验证请求的来源站点\n`Referer`是HTTP请求头中的⼀个字段，记录了该HTTP请求的来源地址。但在服务器端验证请求头中的`Referer`并不是太可靠，因此标准委员会⼜制定了`Origin`属性，在⼀些重要的场合，⽐如通过`XMLHttpRequest、Fecth`发起跨站请求或者通过Post⽅法发送请求时，都会带上`Origin`属性\n![alt](http://img.carrotwu.com/Fn1LnBcSti4O7H4BPYc0RoVxyelX)\n\n因此，服务器的策略是优先判断Origin，如果请求头中没有包含Origin属性，再根据实际情况判断是否使⽤Referer值。\n\n#### CSRF Token\n1. 在进行调用接口前，通过某种方法获取一串字符串，我们这里称为`token`。\n2. 在进行调用接口时，必须带上`token`，后台进行检验。\n', 1, 'browser', '《浏览器工作原理与实践》学习笔记', 1, '2019-11-28 09:35:34', '2020-07-23 17:58:27', NULL, 'http://img.carrotwu.com/Fqns52y4fRlIVIPkA0KeGFLYj-IH', NULL);
INSERT INTO `article` VALUES (19, '在阅读慕课网《设计模式精讲》中的学习笔记，好记性不如烂笔头。', 52, '## 单例模式\n\n**单例模式** （Singleton Pattern）又称为单体模式，保证**一个类只有一个实例**，并提供一个访问它的全局访问点。也就是说，**第二次使用同一个类创建新对象的时候，应该得到与第一次创建的对象完全相同的对象**。\n具体实现:\n```ts\nclass Single {\n  name: string\n  private static _instance : Single\n  constructor (name: string) {\n    this.name = name\n  }\n  tellName () {\n    console.log(this.name)\n  }\n  static getInstance (name: string) {\n    if (!Single._instance) {\n      Single._instance = new Single(name)\n    }\n    return Single._instance\n  }\n}\nconsole.log(Single.getInstance(\'hh\') === Single.getInstance(\'hh\')) //true\n```\n\n### 优点\n1. 单例模式在创建后在内存中只存在一个实例，节约了内存开支和实例化时的性能开支，特别是需要重复使用一个创建开销比较大的类时，比起实例不断地销毁和重新实例化，单例能节约更多资源，比如数据库连接；\n2. 单例模式可以解决对资源的多重占用，比如写文件操作时，因为只有一个实例，可以避免对一个文件进行同时操作；\n3. 只使用一个实例，也可以减小垃圾回收机制 GC（Garbage Collecation） 的压力，表现在浏览器中就是系统卡顿减少，操作更流畅，CPU 资源占用更少；\n### 缺点\n1. 单例模式对扩展不友好，一般不容易扩展，因为单例模式一般自行实例化，没有接口；\n2. 与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化；\n\n## 工厂模式\n工厂模式 （Factory Pattern），根据不同的输入返回不同类的实例，一般用来创建** 同一类对象**。工厂方式的主要思想是将**对象的创建与对象的实现分离**\n\n```ts\ntype AnimalType = \'cat\' | \'dog\'\n// 工厂类\nclass AnimalFactory {\n  static getInstance(type:AnimalType, name:string):Cat | Dog {\n    switch (type) {\n      case \'cat\':\n        return new Cat(name)\n        break;\n  \n      case \'dog\':\n        return new Dog(name)\n        break;\n      \n        default:\n        break;\n    }\n  }\n}\n// 声明两个产品类 \nclass Cat {\n  name: string\n  constructor(name: string) {\n    this.name = name\n  }\n  say() {\n    console.log(`cat name is ${this.name}`)\n  }\n  miao() {\n    console.log(`cat ${this.name} miao miao miao`)\n  }\n}\nclass Dog {\n  name: string\n  constructor(name: string) {\n    this.name = name\n  }\n  say() {\n    console.log(`Dog name is ${this.name}`)\n  }\n}\n```  \n![alt](http://img.carrotwu.com/FsHjHLKWpKrrmHU6W1OKQzIUpWno)  \n\n1. 工厂类用于进行实现相关逻辑的实现，外部只需要传入相关的参数即可获取类的实例，外部并不用关系如何创建。内部自动进行处理创建。\n2. 产品类用于逻辑的具体实现，外部并不会直接调用或者实例化产品类，而是通过工厂模式实现的工厂类去实例化。\n\n### 优缺点\n1. 良好的封装，代码结构清晰，**访问者无需知道对象的创建流程**，特别是创建比较复杂的情况下；\n2. 扩展性优良，通过工厂方法**隔离了用户和创建流程隔离**，符合开放封闭原则；\n3. 解耦了高层逻辑和底层产品类，符合最少知识原则，不需要的就不要去交流； \n\n工厂模式的缺点：带来了额外的系统复杂度，增加了抽象性；\n\n## 抽象工厂模式\n> 前面说了：工厂模式 （Factory Pattern），根据不同的输入返回不同类的实例，一般用来创建** 同一类对象**。工厂方式的主要思想是将**对象的创建与对象的实现分离**。  \n\n抽象工厂：通过对类的工厂抽象使其业务用于对产品类簇的创建，而不是**负责创建某一类产品的实例**。关键在于使用抽象类制定了实例的结构，调用者直接面向实例的结构编程，从实例的具体实现中解耦。   \n\n总结： 抽象工厂其实就是对工厂模式中工厂类和产品类的进一层抽象，把一些通过逻辑并且方法封装成类进一步继承抽象，这个类就叫抽象类。注意这个抽象类不允许进行实例化，只允许继承。\n\n以上文的工厂模式为例，Cat和Dog类都具有name属性，并且有相同的say原型方法，因此我们可以通过进一步抽象成抽象类的形式进行继承来复用代码，这就是抽象类。\n\n```ts\n  type AnimalType = \'cat\' | \'dog\'\n  // 工厂类\n  class AnimalFactory {\n    static getInstance(type:AnimalType, name:string):Cat | Dog {\n      switch (type) {\n        case \'cat\':\n          return new Cat(name)\n          break;\n    \n        case \'dog\':\n          return new Dog(name)\n          break;\n        \n          default:\n          break;\n      }\n    }\n  }\n  //ts 中可以通过加上abstract关键词声明抽象类 es6中可以通过构造函数在实例化是抛出错误\n\n  // class Test {\n  //   constructor() {\n  //     if(this instanceof Test) {\n  //       throw new Error(\'抽象类不允许实例化\')\n  //     }\n  //   }\n  // }\n  // 声明一个抽象类\n  abstract class AbstractAnimal {\n    name: string\n    type: string\n    constructor(type: string, name:string) {\n      this.name = name\n      this.type = type\n    }\n\n    say() {\n      console.log(`${this.type} name is ${this.name}`)\n    }\n  }\n\n  // 具体的cat 和dog类继承\n  class Cat extends AbstractAnimal {\n    name: string\n    constructor(name: string) {\n      super(\'cat\',name)\n    }\n    miao() {\n      console.log(`${this.type} ${this.name} miao miao miao`)\n    }\n  }\n  class Dog extends AbstractAnimal {\n    name: string\n    constructor(name: string) {\n      super(\'dog\',name)\n    }\n    bark() {\n      console.log(`${this.type} ${this.name} bark me ~~~~`)\n    }\n  }\n}\n```  \n例子里只是对动物类进行了抽象，动物工厂AnimalFactory类依然可以进行抽象，不过会提升复杂度。抽象工厂主要有下面几个概念。  \n\n1. **Factory** ：工厂，负责返回产品实例；\n2. **AbstractFactory** ：虚拟工厂，制定工厂实例的结构（抽象类）；\n3. **Product** ：产品，访问者从工厂中拿到的产品实例，实现抽象类；\n4. **AbstractProduct** ：产品抽象类，由具体产品实现，制定产品实例的结构（抽象类）；  \n\n![alt](http://img.carrotwu.com/FhpPhbzUwzXr6oyMSQTtVx-RG5mS)  \n\n### 优缺点\n抽象模式的优点：抽象产品类将**产品的结构抽象出来**，访问者不需要知道产品的具体实现，只需要面向产品的结构编程即可，从产品的具体实现中解耦。  \n\n抽象模式的缺点：  \n\n1. 扩展新类簇的产品类比较困难，因为需要创建新的抽象产品类，并且还要修改工厂类，违反开闭原则；\n2. 带来了系统复杂度，增加了新的类，和新的继承关系；\n\n## 建造者模式（生成器模式）\n建造者模式（Builder Pattern）又称生成器模式，**分步**构建一个复杂对象，并允许**按步骤构造**。同样的构建过程可以采用不同的表示，将**一个复杂对象的构建层与其表示层分离**。  \n\n>把一个复杂的对象的构造拆分成多个简单的对象，实现买个简单的对象后进行组装。\n\n接下来，我们通过建造一辆车来梳理建造者的几个基础概念。试想用户想要买一辆车（product），这一辆车由汽车公司（director）用零件进行组件的，而不同的零件（轮胎，车架）又交给不同的厂家（builder）进行生产，最终交付到买家手中。所以建造者模式涉及到三个概念。  \n\n1. **Director**： 指挥者，调用建造者中的部件具体实现进行部件装配，相当于整车组装厂，最终返回装配完毕的产品；\n2. **Builder**： 建造者，含有不同部件的生产方式给指挥者调用，是部件真正的生产者，但没有部件的装配流程；\n3. **Product**： 产品，要返回给访问者的复杂对象；  \n\n建造者模式的主要功能是构建复杂的产品，并且是**复杂的、需要分步骤构建的产品**，其构建的算法是统一的，构建的过程由指挥者决定，只要配置不同的指挥者，就可以构建出不同的复杂产品来。也就是说，建造者模式**将产品装配的算法和具体部件的实现分离**，这样构建的算法可以扩展和复用，部件的具体实现也可以方便地扩展和复用，从而可以灵活地通过组合来构建出不同的产品对象。\n\n![alt](http://img.carrotwu.com/Frz23AmQHxIi0X_27WoJhacNcBbg)  \n\n\n```ts\n// 建造者模式\n{\n  // 零件组件者\n  class Builder {\n    params: object\n    part1: string\n    part2: string\n    constructor(params:object = {}) {\n      this.params = params\n    }\n    buildPart1() {\n      // 也可以调用其他类的方然\n      this.part1 = \'part1\'\n      // this.part1 = new LunTai(params)\n      return this\n    }\n    buildPart2() {\n      // 也可以调用其他类的方然\n      this.part2 = \'part1\'\n      // this.part1 = new LunTai(params)\n      return this\n    }\n  }\n\n  // 组装者\n  class Director {\n    params: object\n    constructor(params:object = {}) {\n      this.params = params\n      return new Builder(params).buildPart1().buildPart2()\n      // 这里其实也可以不通过类通过方法实现\n      // buildLuntai(this)\n      // buildCheJia(this)\n    }\n  }\n\n  const params = {}\n  // 获取产品\n  const product = new Director(params)\n}\n\n```\n### 优缺点\n建造者模式的优点：\n\n1. 使用建造者模式可以使**产品的构建流程和产品的表现分离**，也就是将产品的创建算法和产品组成的实现隔离，访问者不必知道产品部件实现的细节；\n2. **扩展方便**，如果希望生产一个**装配顺序**或方式不同的新产品，那么直接新建一个指挥者即可，不用修改既有代码，符合开闭原则；\n3. **更好的复用性**，建造者模式将产品的创建算法和产品组成的实现分离，所以产品创建的算法可以复用，产品部件的实现也可以复用，带来很大的灵活性；  \n\n建造者模式的缺点：\n\n1. 建造者模式一般适用于产品之间组成部件类似的情况，如果产品之间**差异性很大、复用性不高**，那么不要使用建造者模式；\n2. 实例的创建增加了许多额外的结构，无疑增加了许多复杂度，如果对象粒度不大，那么我们最好直接创建对象；\n\n\n## 代理模式\n\n代理模式 （Proxy Pattern）又称委托模式，它在访问者与目标对象之间创建了一个新的代理对象，以控制对目标对象的访问。  \n\n> 直接拦截对原对象的访问，类似于中间加了一个中间商，对原对象的任何访问处理都必须通过代理对象。\n\n代理模式把代理对象插入到访问者和目标对象之间，从而为访问者对目标对象的访问引入一定的间接性。正是这种间接性，给了代理对象很多操作空间，比如在调用目标对象前和调用后进行一些预操作和后操作，从而实现新的功能或者扩展目标的功能。  \n\n代理对象主要有访问者（vistor），代理对象（proxy），目标对象（target）三个概念。  \n\n1. vistor: 对目标对象的访问者。\n2. proxy: 对目标对象的代理者，负责引用目标对象，以及对访问的过滤和预处理。\n3. target: 目标对象，被代理的对象也是具体业务的执行者。  \n\n现实中每一个明星都有一个经纪人，导演需要找明星拍电影。这时候导演都是直接去询问经纪人，而不是直接与明星进行联系。在这其中，导演就是访问者（vistor），经纪人就是代理对象（proxy），明星就是目标对象（target）。\n\n![alt](http://img.carrotwu.com/FnjYZ8Qleg7mmWWGTdRwHgVp84gY)  \n\n```ts\n  // 代理模式\n  // 明星类 只负责拍电影\n  class Singer {\n    name: string\n    constructor(name: string) {\n      this.name = name\n    }\n    playMovie(movieName: string) {\n      console.log(`${this.name} begin playing movie ${movieName}`)\n    }\n  }\n\n  // 经纪人\n  class Assitant {\n    name: string\n    mySinger: Singer\n    minMoney: number\n    constructor(name: string) {\n      this.name = name\n    }\n    // 设置为谁的经纪人\n    setSinger(singer: Singer, minMoney: number) {\n      this.mySinger = singer\n      this.minMoney = minMoney\n    }\n    // 接电影通告\n    adjustMovie(money: number, movieName: string) {\n      if(!this.mySinger){\n        throw new Error(\'暂无工作\')\n      }\n      if(money < this.minMoney){\n        throw new Error(\'给我爬， 价格太低了\')\n      }\n      this.mySinger.playMovie(movieName)\n    }\n  }\n  const cxk = new Singer(\'cxk\')\n  const cxkjjr = new Assitant(\'cxkjjr\')\n  cxkjjr.setSinger(cxk, 10000000)\n\n  cxkjjr.adjustMovie(10000, \'打篮球\') // 给我爬， 价格太低了\n  cxkjjr.adjustMovie(100000000, \'鸡你太美\') // cxk begin playing movie 鸡你太美\n}\n```\n\n### 优缺点\n代理模式的主要优点有：\n\n1. 代理对象在访问者与目标对象之间可以起到**中介和保护目标对象**的作用；\n2. 代理对象可以**扩展**目标对象的功能；\n3. 代理模式能将访问者与目标对象分离，在一定程度上降低了系统的耦合度，如果我们希望适度**扩展目标对象的一些功能，通过修改代理对象**就可以了，符合开闭原则；  \n\n代理模式的缺点主要是增加了系统的复杂度，要斟酌当前场景是不是真的需要引入代理模式（十八线明星就别请经纪人了）。\n\n## 享元模式\n享元模式 （Flyweight Pattern）运用**共享技术**来有效地支持大量**细粒度对象的复用**，以**减少创建**的对象的数量。  \n享元模式的主要思想是共享细粒度对象，也就是说如果系统中存在多个相同的对象，那么只需共享一份就可以了，不必每个都去实例化每一个对象，这样来精简内存资源，提升性能和效率。  \n\n>把多实例限制成限定数量的几个实例，减少内存，通过队列机制进行排队运行。\n\n就像靠驾照时候，考试车只有几部但是考试人员可能会有几百名。还没轮到的人进行排队，一个考试完空出来的考试车继续进行考试。其中的几部考试车就是享元模式的体现，不然每人一个考试车这就太浪费资源了。\n\n```ts\n  // 考试车\n  class ExamCar {\n    readonly carId: number\n    isUsing: boolean\n    constructor(carId: number) {\n      this.carId = carId\n      this.isUsing = false\n    }\n\n    examine(studentId: number) {\n      this.isUsing = true\n      console.log(`${studentId}在${this.carId}开始考试`)\n      const time = Math.ceil(Number(Math.random()) * 3)\n      return new Promise((resolve, reject) => {\n        setTimeout(() => {\n          this.isUsing = false\n          console.log(`${studentId}在${this.carId}考试车经过${time}s后考试完毕`)\n          resolve()\n        }, time * 1000)\n      })\n    }\n  }\n\n  // 资源池\n  class ExamCarPool {\n    carPool: ExamCar[]\n    taskQueue: (() => Promise<void>)[]\n    constructor() {\n      this.carPool = []\n      this.taskQueue = []\n    }\n    // 增加考试车\n    addExamCar(car: ExamCar) {\n      this.carPool.push(car)\n    }\n    // 初始化考试车\n    initExamCar(carIdArray: number[]) {\n      for(let id of carIdArray) {\n        this.addExamCar(new ExamCar(id))\n      }\n    }\n    // 增加考试人员\n    addExamStudent(studentIdArray: number[]) {\n      const taskArray:(() => Promise<void>)[] = studentIdArray.map(studentId => {\n        return async () => {\n          const car = this.getUnUsedCar()\n          await car.examine(studentId)\n          this.next()\n        }\n      })\n      this.taskQueue = [...this.taskQueue, ...taskArray]\n    }\n    // 获取没人使用的车辆\n    getUnUsedCar() {\n      return this.carPool.find(car => !car.isUsing)\n    }\n    next() {\n      const task = this.taskQueue.shift()\n      if(typeof task === \'function\'){\n        task()\n      }\n    }\n    // 开始考试\n    startExam() {\n      for(let i =0 ; i< this.carPool.length; i++) {\n        this.next()\n      }\n    }\n  }\n\n  const carExam = new ExamCarPool()\n  carExam.initExamCar([11, 22, 33])\n  carExam.addExamCar(new ExamCar(44))\n  carExam.addExamStudent([99 , 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88 ])\n  carExam.startExam()\n```\n\n### 优缺点\n享元模式的优点：\n\n1. 由于减少了**系统中的对象数量**，提高了程序运行效率和性能，精简了内存占用，加快运行速度；\n2. 外部状态相对独立，不会影响到内部状态，所以享元对象能够在不同的环境被共享；  \n\n享元模式的缺点：\n\n1. 引入了**共享对象**，使对象结构变得复杂；\n2. 共享对象的**创建、销毁**等需要维护，带来额外的复杂度（如果需要把共享对象维护起来的话）；\n\n## 装饰者模式\n\n装饰者模式 （Decorator Pattern）又称装饰器模式，在**不改变原对象**的基础上，通过对其**添加属性或方法**来进行包装拓展，使得原有对象可以动态具有更多功能。  \n\n>对原有方法或者类的能力进行增强。\n\n本质是功能**动态组合**，即动态地给一个对象添加额外的职责，就增加功能角度来看，使用装饰者模式比用继承更为灵活。好处是有效地把对象的核心职责和装饰功能区分开，并且通过动态增删装饰去除目标对象中重复的装饰逻辑。  \n\n![alt](http://img.carrotwu.com/FlYzOQ8b-iOWtE_dg9Glw9GeL-qx)  \n\n\n>下面的装饰器讲直接使用ts的装饰器  \n\nts已经自带了装饰器，声明是一个函数，接受三个参数。\n```ts\nfunction eat(target, key, descriptor) {\n  // 修饰类是 target指代的是修的类 key descriptor都为void\n  // 修饰类的方法时 target指代的依然是类 key指代的是要装饰的属性名 descriptor表示该属性的描述对象\n}\n```\n注意的是多个装饰器应用使用在同一个声明上时：\n\n1. 由上至下依次对装饰器表达式求值；\n2. 求值的结果会被当成函数，由下至上依次调用；\n\n```ts\nfunction f() {\n    console.log(\"f(): evaluated\");\n    return function (target, propertyKey: string, descriptor: PropertyDescriptor) {\n        console.log(\"f(): called\");\n    }\n}\n\nfunction g() {\n    console.log(\"g(): evaluated\");\n    return function (target, propertyKey: string, descriptor: PropertyDescriptor) {\n        console.log(\"g(): called\");\n    }\n}\n\nclass C {\n    @f()\n    @g()\n    method() {}\n}\n\n// f(): evaluated\n// g(): evaluated\n// g(): called\n// f(): called\n```\n```ts\n  // 装饰器模式\n  class Test {\n    miao: boolean\n    constructor() {}\n    @log\n    test(val: number) {\n      return val + 1\n    }\n  }\n\n  function log(target:any, key:string, descriptor:PropertyDescriptor) {\n    // 给类加上静态属性\n    target.miao = true\n    // 获取旧的属性方法 赋值新的方法\n    const oldFn = descriptor.value\n    descriptor.value = (...args: any[]) => {\n      console.log(`log -----`)\n      oldFn.apply(args)\n    }\n  }\n```\n\n## 桥接模式\n桥接模式（Bridge Pattern）又称桥梁模式，将**抽象部分与它的实现部分**分离，使它们都可以独立地变化。使用**组合关系代替继承关系**，降低抽象和实现两个可变维度的耦合度。（有点像建造者模式）主要有三个部分组成。\n> 简单说就是把某个方法的实现拆分成多个部分，有点类似于建造者模式。就像桥一样进行组合拼装可以组成不同类型的桥。与建造者的区别更像是建造者如何造一个桥（水泥，桥墩。。），桥接模式是如何造一个多功能的桥（有灯，有多车道）\n\n1. Product： 产品，由多个独立部件组成的产品；\n2. Component： 部件，组成产品的部件类；\n3. Instance： 部件类的实例；\n\n![alt](http://img.carrotwu.com/FusYyb4bB6BlsaX0lA4dtDa4ZIIA)  \n\n```ts\n  // 桥接模式\n\n  // 组件一个人\n  class Person {\n    leg: Leg\n    arm: Arm\n    head: Head\n    constructor(headLength: number, armLength: number, legLength: number) {\n      this.head = new Head(headLength)\n      this.arm = new Arm(armLength)\n      this.leg = new Leg(legLength)\n    }\n    move() {\n      this.head.move()\n      this.arm.move()\n      this.leg.move()\n\n    }\n  }\n  // 头部\n  class Head {\n    head: string\n    constructor(length: number) {\n        this.head =`${length}米长的头`\n    }\n    \n    move() {\n        console.log(this.head + \'疯狂晃动\')\n    }\n  }\n  // 手臂\n  class Arm {\n    arm: string\n    constructor(length: number) {\n        this.arm =`${length}米长的手臂`\n    }\n    \n    move() {\n        console.log(this.arm + \'疯狂摇摆\')\n    }\n  }\n  // 腿部\n  class Leg {\n    leg: string\n    constructor(length: number) {\n        this.leg =`${length}米长的大腿`\n    }\n    \n    move() {\n        console.log(this.leg + \'疯狂骚动\')\n    }\n  }\n```\n### 优缺点\n\n桥接模式的优点：\n\n1. 分离了抽象和实现部分，将实现层（DOM 元素事件触发并执行具体修改逻辑）和抽象层（ 元素外观、尺寸部分的修改函数）解耦，有利于分层；\n2. 提高了可扩展性，多个维度的部件自由组合，避免了类继承带来的强耦合关系，也减少了部件类的数量；\n3. 使用者不用关心细节的实现，可以方便快捷地进行使用；  \n\n\n桥接模式的缺点：\n\n1. 桥接模式要求两个部件没有耦合关系，否则无法独立地变化，因此要求正确的对系统变化的维度进行识别，使用范围存在局限性；\n2. 桥接模式的引入增加了系统复杂度；\n\n## 发布订阅模式（观察者模式）\n\n发布-订阅模式 （Publish-Subscribe Pattern, pub-sub）又叫观察者模式（Observer Pattern），它定义了一种**一对多**的关系，让**多个订阅者对象同时监听某一个发布者**，或者叫主题对象，这个主题对象的状态发生变化时就会**通知所有订阅自己的订阅者对象**，使得它们能够自动更新自己。\n\n\n主要有下面几个概念：\n\n1. Publisher ：发布者，当消息发生时负责通知对应订阅者\n2. Subscriber ：订阅者，当消息发生时被通知的对象\n3. SubscriberMap ：持有不同 type 的数组，存储有所有订阅者的数组\n4. type ：消息类型，订阅者可以订阅的不同消息类型\n5. subscribe ：该方法为将订阅者添加到 SubscriberMap 中对应的数组中\n6. unSubscribe ：该方法为在 SubscriberMap 中删除订阅者\n7. notify ：该方法遍历通知 SubscriberMap 中对应 type 的每个订阅者\n\n```ts\n  interface EventsType {\n    [key: string]: undefined | ((...args:any[]) => any)[]\n  }\n  // 发布订阅模式\n  class EventEmitter {\n    private events: EventsType\n    private maxLength:number\n    private static _instance: EventEmitter\n    constructor(maxLength = 10) {\n      this.events = Object.create(null)\n      this.maxLength = maxLength\n    }\n    //添加订阅\n    addListners(type:string, cb: (...args:any[]) => any) {\n      const eventType = this.events[type]\n      if(Array.isArray(eventType)){\n        if(eventType.length >= this.maxLength){\n          throw new Error(`超出${this.maxLength}个监听事件限制啦`)\n        }\n        eventType.push(cb)\n      }else {\n        this.events[type] = [cb]\n      }\n    }\n    // 订阅依次\n    once(type:string, cb: (...args:any[]) => any) {\n      const onceCb = (...args:any[]) => {\n        cb && cb.apply(this,args)\n        // 执行完成之后删除相应的订阅\n        this.removeListners(type, onceCb)\n      }\n      this.addListners(type, onceCb)\n    }\n    // 删除订阅\n    removeListners(type:string, cb?:(...args:any[]) => any):void {\n      // 如果添加了cb 那么只删除一个订阅 不然全部进行删除\n      const typeEvents = this.events[type]\n      if(!typeEvents){\n        return \n      }\n      if(!cb){\n        this.events[type] = undefined\n        return \n      }\n      if(typeof cb === \'function\'){\n        this.events[type] = typeEvents.filter(event => event !== cb)\n      }\n    }\n    // 发布事件\n    emitEvents(type: string, ...args: any[]) {\n      const eventType = this.events[type]\n      if(Array.isArray(eventType)){\n        eventType.forEach(cb => cb.apply(this, args))\n      }\n    }\n    // 设置最大订阅数量\n    setMaxListners(maxLength: number) {\n      if(typeof maxLength === \'number\' && maxLength > 0) {\n        this.maxLength = maxLength\n      }\n    }\n    // 设置单例\n    static getInstance (maxLength: number) {\n      if (!EventEmitter._instance) {\n        EventEmitter._instance = new EventEmitter(maxLength)\n      }\n      return EventEmitter._instance\n    }\n  }\n}\n```\n\n### 优缺点\n\n发布-订阅模式最大的优点就是**解耦**：\n\n1. 时间上的解耦 ：注册的订阅行为由消息的发布方来决定何时调用，订阅者不用持续关注，当消息发生时发布者会负责通知；\n2. 对象上的解耦 ：发布者不用提前知道消息的接受者是谁，发布者只需要遍历处理所有订阅该消息类型的订阅者发送消息即可（迭代器模式），由此解耦了发布者和订阅者之间的联系，互不持有，都依赖于抽象，不再依赖于具体；\n\n发布-订阅模式也有缺点：\n\n1. 增加消耗 ：创建结构和缓存订阅者这两个过程需要消耗计算和内存资源，即使订阅后始终没有触发，订阅者也会始终存在于内存；\n2. 增加复杂度 ：订阅者被缓存在一起，如果多个订阅者和发布者层层嵌套，那么程序将变得难以追踪和调试，参考一下 Vue 调试的时候你点开原型链时看到的那堆 deps/subs/watchers 们\n\n### 发布订阅者与观察者模式之间的区别\n\n![alt](http://img.carrotwu.com/FngySlszWokSIOdJERt0yUMCSPuV) \n \n\n区别主要在发布-订阅模式中间的这个 Event Channel：\n\n1. 观察者模式 中的观察者和被观察者之间还存在耦合，被观察者还是知道观察者的；\n2. 发布-订阅模式 中的发布者和订阅者不需要知道对方的存在，他们通过消息代理来进行通信，解耦更加彻底；\n\n就像杀手工会，老板下单，工会悬赏，杀手接单。杀手并不能知道是谁下的单，这就是发布订阅模式，中间隔着一个用于发布和订阅的工会。而老板直接指定某个杀手下单，这就是观察者模式，发布者和订阅者都明确知道对反过的信息。\n\n### 策略模式\n策略模式 （Strategy Pattern）又称政策模式，其定义一系列的**算法**，把它们一个个封装起来，并且使它们可以互相替换。封装的策略算法一般是独立的，策略模式根据输入来调整采用哪个算法。关键是策略的实现和使用分离。  \n\n>个人认为就是把一些相似或者同一逻辑下不同条件的方法进行封装，通过表驱动的方式。 \n\n```ts\n  // 策略模式\n  let a = 2;\n  let b;\n  if (a === 1) {\n    b = \"1\";\n  } else if (a === 2) {\n    b = \"2\";\n  } else if (a === 3) {\n    b = \"3\";\n  } else if (a === 4) {\n    b = \"4\";\n  }\n\n  const aMap: any = {\n    1: \'1\',\n    2: \'2\',\n    3: \'3\',\n    4: \'4\'\n  }\n\n  // 使用表驱动\n  let c = aMap[a]\n\n  // 检查类型的策略模式\n  type TypeChecker = {\n    \'number\': number\n    \'boolean\': boolean\n    \'array\': Array<any>\n    \'object\': object\n    \'function\': (...args: any[]) => any\n    \'string\': string\n    \'null\': null\n    \'undefined\': undefined\n    \'symbol\': symbol\n    \'date\': Date\n    \'error\': Error\n  }\n  const toString = Object.prototype.toString\n  const checkType = <U extends keyof TypeChecker>(type: U) => {\n    // 检查是否相应的类型\n    return function(val: unknown):val is TypeChecker[U]{\n      return toString.call(val).slice(8, -1).toLowerCase() === type\n    }\n  }\n  const isNumber = checkType(\'number\')\n  const isArray = checkType(\'array\')\n  const isBoolean = checkType(\'boolean\')\n  const isObject = checkType(\'object\')\n  const isFunction = checkType(\'function\')\n  const isUndefined= checkType(\'undefined\')\n  const isString = checkType(\'string\')\n  const isSymbol = checkType(\'symbol\')\n  const isDate = checkType(\'date\')\n  const isError = checkType(\'error\')\n  const a: number[] | string = Math.random() > 0.5 ? [1] : \'str\'\n  if(isArray(a)){\n    a.push(1)\n  }else {\n    a.split(\',\')\n  }\n\n}\n```\n\n### 优缺点\n\n策略模式将算法的实现和使用拆分，这个特点带来了很多优点：\n\n1. 策略之间相互独立，但策略可以自由切换，这个策略模式的特点给策略模式带来很多灵活性，也提高了策略的复用率；\n2. 如果不采用策略模式，那么在选策略时一般会采用多重的条件判断，采用策略模式可以避免多重条件判断，增加可维护性；\n3. 可扩展性好，策略可以很方便的进行扩展；\n\n策略模式的缺点：\n\n1. 策略相互独立，因此一些复杂的算法逻辑无法共享，造成一些资源浪费；\n2. 如果用户想采用什么策略，必须了解策略的实现，因此所有策略都需向外暴露，这是违背迪米特法则/最少知识原则的，也增加了用户对策略对象的使用成本。\n\n## 职责链模式\n\n职责链有以下特点:  \n\n1. 请求在一系列对象中传递，形成一条链；\n2. 链中的请求接受者对请求进行分析，要么处理这个请求，要么把这个请求传递给链的下一个接受者；\n\n就像我们进行请假审批一样，可能需要在app上进行申请，然后hr小姐姐批转完成之后，再推送给部门负责人，部门负责人批准后推送给中心负责人，中心负责人再推送给老板等等等...  \n\n其中，这就是一条完整的职责链，每个人就干自己责任内的事情。另外一个清晰的例子就是redux中的中间件，每个中间件都会对数据进行处理，最后会把数据传递給下一个中间件进行处理以此类推。当然还有`rxjs`的pipe方法等。\n\n### 原理\n职责链模式可能在真实的业务代码中见的不多，但是作用域链、原型链、DOM 事件流的事件冒泡，都有职责链模式的影子:\n\n1. 作用域链： 查找变量时，先从当前上下文的变量对象中查找，如果没有找到，就会从父级执行上下文的变量对象中查找，一直找到全局上下文的变量对象。\n2. 原型链： 当读取实例的属性时，如果找不到，就会查找当前对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。\n3. 事件冒泡： 事件在 DOM 元素上触发后，会从最内层的元素开始发生，一直向外层元素传播，直到全局 document 对象。\n\n### 模拟实现\n```ts\n  // 职责链模式\n\n  abstract  class Leader {\n    nextLeader: Leader\n    name: string\n    constructor(name:string) {\n      this.name = name\n    }\n    // 执行逻辑方法\n    handle(day: number){ }\n    //\n    pipe(nextLeader: Leader) {\n      const _nextLeader = this.nextLeader\n      if(_nextLeader){\n        _nextLeader.pipe(nextLeader)\n      }else {\n        this.nextLeader = nextLeader\n      }\n      return this\n    }\n  }\n\n  class FirstLeader extends Leader {\n    constructor(name: string) {\n      super(name)\n    }\n    handle(day: number) {\n      // 大于1天的假期批不了\n      if(day > 1) {\n        return this.nextLeader.handle(day)\n      }else {\n        console.log(`可以放假了，${this.name}准你${day}天的假期`)\n      }\n    }\n  }\n  class SecondLeader extends Leader {\n    constructor(name: string) {\n      super(name)\n    }\n    handle(day: number) {\n      // 大于1天的假期批不了\n      if(day > 2 && Math.random() > 0.2) {\n        return this.nextLeader.handle(day)\n      }else {\n        console.log(`可以放假了，${this.name}准你${day}天的假期`)\n      }\n    }\n  }\n  class ThirdLeader extends Leader {\n    constructor(name: string) {\n      super(name)\n    }\n    handle(day: number) {\n      // 大于1天的假期批不了\n      if(day > 3) {\n        return this.nextLeader.handle(day)\n      }else {\n        console.log(`可以放假了，${this.name}准你${day}天的假期`)\n      }\n    }\n  }\n  const zhangsan = new FirstLeader(\'zhangsan\')\n  const lisi = new SecondLeader(\'lisi\')\n  const zhaowu = new ThirdLeader(\'zhaowu\')\n\n  zhangsan.pipe(lisi).pipe(zhaowu).handle(2)\n```\n\n### 优缺点\n职责链模式的优点：\n\n1. 和命令模式类似，由于处理请求的职责节点可能是职责链上的任一节点，所以请求的发送者和接受者是解耦的；\n2. 通过改变链内的节点或调整节点次序，可以动态地修改责任链，符合开闭原则；  \n\n\n职责链模式的缺点：\n\n1. 并不能保证请求一定会被处理，有可能到最后一个节点还不能处理；\n2. 调试不便，调用层次会比较深，也有可能会导致循环引用；\n\n## 中介者模式\n中介者模式 （Mediator Pattern）又称调停模式，使得各对象不用显式地相互引用，将对象与对象之间紧密的耦合关系变得松散，从而可以独立地改变他们。**核心是多个对象之间复杂交互的封装**。\n\n### 原理\n\n解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过**中介者对象来通信**，而不是互相引用，所有当一个对象发生改变时，只需要通知中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者模式使网状的**多对多**关系变成了相对简单的**一对多**关系。  \n\n\n1. Colleague： 同事对象，只知道中介者而不知道其他同事对象，通过中介者来与其他同事对象通信；\n2. Mediator： 中介者，负责与各同事对象的通信；  \n\n![alt](http://img.carrotwu.com/FtsAF0vMxV3n-f_0FNtnYv9kSjZa)  \n\n\n### 模拟实现--泡泡堂游戏\n```ts\n  // 中介者模式\n  type Color = \"red\" | \"blue\" | \"yellow\" | \"green\";\n  type State = \"die\" | \"alive\";\n  class Player {\n    name: string;\n    teamColor: Color;\n    state: State;\n    partners: Player[];\n    enemies: Player[];\n    constructor(name: string, color: Color) {\n      this.partners = []; // 队友列表\n      this.enemies = []; // 敌人列表\n      this.state = \"alive\"; // 玩家状态\n      this.name = name; // 角色名字\n      this.teamColor = color; // 队伍颜色\n    }\n    // 一位玩家死了 需要通知其他玩家把队友列表或者敌人列表清除 并且如果所有队友都死了 那就得打印失败\n    setDie() {\n      this.state = \"die\";\n      let all_dead = true\n      // 遍历队友列表\n      for (var i = 0, partner; (partner = this.partners[i++]); ) {\n        if (partner.state !== \"die\") {\n          all_dead = false;\n          break;\n        }\n      }\n      // 如果队友全部死亡\n      if (all_dead === true) {\n        this.lose();\n        // 通知所有队友玩家游戏失败\n        for (var i = 0, partner; (partner = this.partners[i++]); ) {\n          partner.lose();\n        }\n\n        // 通知所有敌人游戏胜利\n        for (var i = 0, enemy; (enemy = this.enemies[i++]); ) {\n          enemy.win();\n        }\n      }\n    }\n    lose() {\n      console.log(`${this.teamColor} 颜色队伍失败`)\n    }\n    win() {\n      console.log(`${this.teamColor} 颜色队伍胜利`)\n    }\n  }\n```\n\n试想如果有8个玩家一起在游玩游戏，每个玩家都必须与另外七个玩家的状态相关联，一个玩家的死亡会影响另外七个玩家的状态，可想而知后续逻辑会非常复杂。所以我们可以通过引入中介者模式——增加一个导演类来控制玩家间的状态。\n```ts\n  // 中介者模式\n  type Color = \"red\" | \"blue\" | \"yellow\" | \"green\";\n  type State = \"die\" | \"alive\";\n\n  interface PlayerParams {\n    name: string;\n    color: Color;\n    director: Director;\n  }\n  // 玩家类\n  class Player {\n    name: string;\n    teamColor: Color;\n    state: State;\n    director: Director;\n    constructor(params: PlayerParams) {\n      const { name, color, director } = params;\n      this.state = \"alive\"; // 玩家状态\n      this.name = name; // 角色名字\n      this.teamColor = color; // 队伍颜色\n      this.director = director; //导演\n    }\n    // 一位玩家死了通知导演 导演进行处理\n    die() {\n      this.state = \"die\";\n      this.director.notifyDie(this);\n    }\n    lose() {\n      console.log(`玩家${this.name}失败`);\n    }\n    win() {\n      console.log(`玩家${this.name}胜利`);\n    }\n  }\n\n  type TeamPlayers = {\n    [P in Color]?: Player[];\n  };\n  // 导演类 用于控制玩家之间的状态\n  class Director {\n    teamPlayers: TeamPlayers;\n    // 任然处于处于活着状态的队伍\n    aliveTeam: Color[];\n    createPlayer(name: string, color: Color) {\n      return new Player({ name, color, director: this });\n    }\n    addPlayer(player: Player) {\n      const { teamColor } = player;\n      const currentTeam = this.teamPlayers[teamColor];\n      this.teamPlayers[teamColor] = currentTeam\n        ? currentTeam.concat(player)\n        : [player];\n      return this;\n    }\n    // 删除某位玩家\n    removePlayer(player: Player) {\n      const { teamColor, name } = player;\n      const currentTeam = this.teamPlayers[teamColor];\n      this.teamPlayers[teamColor] = currentTeam.filter(\n        player => player.name !== name\n      );\n      return this;\n    }\n    // 玩家换队伍\n    toggleTeam(player: Player, toggleTeamColor: Color) {\n      this.removePlayer(player);\n      player.teamColor = toggleTeamColor;\n      this.addPlayer(player);\n    }\n    // 某位玩家死亡\n    notifyDie(player: Player) {\n      // 检验当前颜色的团队是否都死亡\n      const { teamColor } = player;\n      const teamArray = this.teamPlayers[teamColor];\n      const isTeamAllDie = teamArray.every(player => player.state === \"die\");\n      if (isTeamAllDie) {\n        // 全部死掉 通知队友打印失败\n        teamArray.forEach(player => player.die());\n        // 移除当前队伍\n        this.aliveTeam = this.aliveTeam.filter(color => color !== teamColor);\n        // 如果队伍只剩一只 打印当前队伍的胜利\n        if (this.aliveTeam.length === 1) {\n          const winTeamColor = this.aliveTeam[0];\n          this.teamPlayers[winTeamColor].forEach(player => player.win());\n        }\n      }\n    }\n  }\n```', 1, 'design-patterns,typescript', '《设计模式精讲》学习笔记', 1, '2020-01-04 17:52:27', '2020-09-21 10:09:53', NULL, 'http://img.carrotwu.com/Fu-DUMUjspFfIxRotFVc0VAy3bsx', NULL);
INSERT INTO `article` VALUES (20, '下面列举的自定义hooks都是我在编写我的前端博客中总结封装出来的hooks。hooks的编写相对于简单，但是要加上ts进行类型约束和返回值的代码提示就是个大问题了', 9, '>自己博客中使用到并且进行封装的自定义hooks。全手打自己实现`。\n## usePromise\n一般来说，对于每一次发起的网络请求。其实都是有一些通用的公共逻辑，比如请求中的loading状态，错误处理的方法。数据的公共处理，在博客中对请求方法进行了封装这就是**usePromise**的由来。\n### 源码实现\n```ts\nimport {useCallback, useState} from \'react\';\nimport {isArray, isPlainObject} from \"utils/checkType\";\n\nexport interface IResponseConfig<T = any> {\n  resultCode: number\n  resultMsg: string\n  status: number\n  data: T\n}\n\n// 获取函数的参数类型\nexport type ReturnParamsType<T extends (...args: any[]) => any> = T extends (...args: infer P) => any ? P : any;\n\n// 限制传入的函数类型\ntype PromiseFn<U> = (...params: any[]) => Promise<IResponseConfig<U>>\n\n// 一些默认的配置\ninterface PromiseOptions {\n  // 默认数值， 用于初始化时的显示\n  defaultData?: any;\n  reqInterceptors?: () => void;\n  resInterceptors?: () => void;\n}\n\n// 返回的对象类型\ninterface PromiseRes<U, T> {\n  // 用于进行调用的方法\n  loadFn: T;\n  // loading状态\n  loading: boolean;\n  // 请求的返回值\n  res: IResponseConfig<U>;\n  // 请求错误时的error\n  error: Error | null;\n}\n\n// 函数重载\nfunction usePromise<U, T extends PromiseFn<U>>(\n  loadFn: T,\n): PromiseRes<U,T>;\nfunction usePromise<U, T extends PromiseFn<U>>(\n  loadFn: T,\n  depListOrOptions: any[] | PromiseOptions\n): PromiseRes<U,T>;\nfunction usePromise<U, T extends PromiseFn<U>>(\n  loadFn: T,\n  depList: any[],\n  options: PromiseOptions\n): PromiseRes<U,T>;\n\n/**\n * 用于封装请求的自定义hooks方法\n * @param {T} loadFn promise方法\n * @param {any[] | PromiseOptions} depList 依赖数组\n * @param {PromiseOptions} options 一些自定义的配置\n * @returns {PromiseRes<U, T>}\n */\nfunction usePromise<U, T extends PromiseFn<U>>(\n  loadFn: T,\n  depList?: any[] | PromiseOptions,\n  options?: PromiseOptions,\n): PromiseRes<U,T> {\n  //重载\n  let _options:PromiseOptions\n  let _depList: any[]\n  _depList = isArray(depList) ? depList : []\n  _options = (isPlainObject(depList) && !isArray(depList)) ? depList : (options || {})\n\n  const {defaultData = {data: {}}} = _options;\n  const [loading, setLoading] = useState(true);\n  const [data, setData] = useState<IResponseConfig<U>>(defaultData);\n  const [error, setError] = useState<Error | null>(null);\n\n  const initLoad = useCallback(async (...params: ReturnParamsType<T>) => {\n    try {\n      setError(null);\n      setLoading(true);\n      const result = await loadFn(...params);\n      setData(result);\n      setLoading(false);\n      return result\n    } catch (e) {\n      setLoading(false);\n      setError(e);\n      return Promise.reject(e)\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [..._depList])\n\n  return {\n    loadFn: initLoad as T,\n    res: data,\n    loading,\n    error,\n  };\n}\n\nexport default usePromise\n```\n### 使用\n```tsx\nconst Post:React.FC = () => {\n  // 只需要传入一个promise函数 然后节后获得一个loadFn函数 在需要的地方调用即可\n  // res和loading变量会进行更新\n  // 依托于ts的强大之处 如果通过ts定义了getArticleById的返回类型 那么在data中也会进行相应的代码提示\n  const { loadFn: getArticleDetail, res: {data}, loading } = usePromise(\n    async (id: string) => getArticleById({id}),\n    [id]\n  );\n  const {title, content = \'\', createdStamp} = data\n  useEffect(() => {\n    if(!id){\n      //不存在id\n      history.replace(\'/home\')\n    }else {\n      getArticleDetail(id)\n    }\n    // eslint-disable-next-line\n  }, [id])\n\n  return (\n    <div className=\"content\">\n      {loading ?\n        <div className=\"post-loading\">\n          <Loading size={50}>文章加载中</Loading>\n        </div>\n        :\n        <div className=\"post\">\n        {content}\n        </div>\n      }\n\n    </div>\n  )\n}\n\n```\n## useSetState\n可能刚接触hooks的**setXXX**函数时大家会感觉到有一部分的不适应，因为该函数对于对象并不像class组件的**setState**一样对象之间进行合并更新，需要通过结构或者**Object.assing**进行返回一个新的对象。对于偷懒的我来说是无法忍受的。当然强大的hooks也可以模拟出class组件的**setState**的方法，我这里同时也允许传入第二个参数用于渲染后的回调操作。\n\n### 源码\n```ts\nimport {useCallback, useState, useEffect, useRef} from \"react\";\nimport {isFunction} from \"utils/checkType\";\n\n// 约束传入useSetState的类型\ntype ISetState<U> = U | ((...args: any[]) => U)\n\n// 返回方法的参数类型 setState() 允许接收两种参数 传统的直接对象数据 或者是一个函数 函数的话参数是上一次state的值\ntype ReturnStateMethods<U> = Partial<U> | ((state: U) => Partial<U>)\n\ntype ReturnSetStateFn<T> = (state: ReturnStateMethods<T>, cb?: (...args: any[]) => void) => void\n/**\n * 模拟class组件的setState方法\n * @param {ISetState<T>} initObj\n * @returns {[T, ((state: ReturnStateMethods<T>) => void)]}\n */\nexport default function useSetState<T extends object>(initObj:ISetState<T>): [T, ReturnSetStateFn<T>] {\n  const [state, setState] = useState<T>(initObj)\n  const executeCb = useRef<(...args: any[]) => void>()\n  const newSetState = useCallback<ReturnSetStateFn<T>>((state, cb) => {\n    let newState = state\n    setState((prevState:T) => {\n      executeCb.current = cb\n      if(isFunction(state)){\n        newState = state(prevState)\n      }\n      return {...prevState, ...newState}\n    })\n  }, [])\n  useEffect(() => {\n    const {current: cb} = executeCb\n    isFunction(cb) && cb()\n    // eslint-disable-next-line\n  }, [executeCb.current])\n  return [state, newSetState]\n}\n```\n\n### 使用\n\n```tsx\nconst Post:React.FC = () => {\n  interface Detail {\n    time: number,\n    test: string\n  }\n  // useSetState必须接受一个对象\n  const [detail, setDetail] = useSetState<Detail>({test: \'123\', time: new Date().getTime()})\n  const onChangeTime = useCallBack(() => {\n    // 需要修改啥就传啥即可\n    setDetail({\n      time: new Date().getTime()\n    }, () => {\n      // 这次render完之后可进行的回调操作\n    })\n  })\n  return (\n    <div className=\"content\" onClick={onChangeTime}>\n      {loading ?\n        <div className=\"post-loading\">\n          <Loading size={50}>文章加载中</Loading>\n        </div>\n        :\n        <div className=\"post\">\n        {content}\n        </div>\n      }\n\n    </div>\n  )\n}\n```\n\n## useMethods\n**useMethods**是我在看知乎时一位大佬提供的思路以及代码编写完成（相关的ts类型提示以及检查是我写的，源码并不是我）。这个方法提供了通用封装方法的思路[**知乎链接**](https://www.zhihu.com/question/357020049/answer/909484669 \"html\")。简单说就是**给我一个值和一堆方法，我帮你变成hook**。\n\n### 源码\n```ts\nimport {useState} from \'react\'\n\n// 筛选出符合函数的类型\n\ntype FilterMethods<K, U> = {\n  [P in keyof K]: K[P] extends (value: U, ...args: any[]) => U ? K[P] : never\n}\n\n// 获取除了state本身自外的其他函数参数\ntype GetExtraParams<U, T> = U extends (value: T, ...args: infer P) => void ? P : never\n\n// 映射类型生成返回的函数对象\ntype ReturnMethods<U, T> = {\n  [P in keyof U]: (...args: GetExtraParams<U[P], T>) => void;\n}\n\n/**\n *  接受一个值和方法进行hooks化\n * @param {T} initState 初始化值\n * @param {K} methods 需要hooks话的方法\n * @returns {[T, ReturnMethods<K, T>]}\n */\nfunction useMethods<T, K extends FilterMethods<K, T>>(\n  initState: T,\n  methods: K\n): [T, ReturnMethods<K, T>] {\n  const [value, setValue] = useState<T>(() => initState);\n  const methodsTypes = Object.keys(methods) as Array<keyof K>\n  const boundMethods = methodsTypes.reduce((newMethods, name) => {\n    const fn = methods[name];\n    if (typeof fn === \'function\') {\n      newMethods[name] = (...args: any[]) => {\n        setValue(value => fn(value, ...args));\n      }\n    }\n    return newMethods;\n  }, {} as ReturnMethods<K, T>);\n  return [value, boundMethods];\n}\n\nexport default useMethods\n\n```\n\n### 使用\n在上面的`useMethods`的帮助下，我们可以二次封装很多常用的方法集合比如说数组的自定义hooks，数字加一减一的自定义hooks等等等等。放开来说，可以把一个模块通用的utils方法全部通过`useMethods`进行hooks化。在下面举几个我使用过的hooks。\n```ts\n// useNumber\nimport useMethods from \"./useMethods\"\n\ninterface UseNumberMethods<T = number> {\n  increment:(value:T) => T\n  decrement:(value:T) => T\n  add:(value:T, num: number) => T\n  dec:(value:T, num: number) => T\n}\nconst methods:UseNumberMethods = {\n  increment(value) {\n    return value + 1;\n  },\n  decrement(value) {\n    return value - 1;\n  },\n  add(value, num: number){\n    return value + num\n  },\n  dec(value, num: number){\n    return value - num\n  }\n}\n\n/**\n *\n * @param {number} initState 初始值\n * @returns {[number, ReturnMethods<UseNumberMethods<number>, number>]}\n */\nfunction useNumber(initState: number) {\n  return useMethods(initState, methods)\n}\n\n// useArray\ninterface UseArrayMethods<T extends any[]> {\n  plainPush:(value:T, ...args: T) => T\n  plainPop:(value:T) => T\n  plainUnshift:(value:T, ...args: T) => T\n  plainShift:(value:T) => T\n}\n\n/**\n *\n * @param {boolean} initState 初始值\n * @returns {[number, ReturnMethods<UseNumberMethods<number>, number>]}\n */\nfunction useArray<T>(initState: T[]) {\n  const methods:UseArrayMethods<T[]> = {\n    plainPush(value, ...args) {\n      return [...value, ...args]\n    },\n    plainPop(value) {\n      return value.slice(0, -1)\n    },\n    plainUnshift(value, ...args) {\n      return [...args, ...value]\n    },\n    plainShift(value) {\n      return value.slice(1)\n    },\n  }\n\n  return useMethods(initState, methods)\n}\n\nexport default useArray\n\n```', 1, 'reactHooks,typescript', 'ts+hooks封装一些好用的自定义hooks', 1, '2020-03-03 18:29:28', '2020-08-05 15:07:29', NULL, 'http://img.carrotwu.com/FurODhateRXYGYBkh0WgsN3xoR4X', NULL);
INSERT INTO `article` VALUES (21, '前端学习算法：好好学习算法，从我做起', 0, '## 动态规划\n\n>每天一道算法题不太行，两三天一道算法题还是可以的吧。坚持算法题，我最薄弱的算法= =冲冲冲。\n### 先从台阶算法题说起\n\n在讲解动态规划之前，我觉得可以先从一个面试题开始讲起——阶梯问题：**假如楼梯有10个台阶，每次可以走1个或2个台阶，请问走完这10个台阶有几种走法**。  题目看似很难入手，我们可以通过下面的步骤思维去理解。\n1. 因为一次只能走1个台阶或者2个台阶，所以可想而知走后一步时只有两种情况：**从第九个台阶走一步上去以及从第八个台阶走两步上去**。\n2. 所以求走完10个台阶的求解就编程了：**走完第8个台阶的走法+走完第九个台阶的走法**。\n3. 以此类推，走完第8个台阶的走法=**走完第7个台阶的走法+走完第6个台阶的走法**。等等等等，这样子可以一直递归下去。\n4. 注意的是，只有一个台阶时只有一种走法：**走一步**。只有两个台阶时只有一种走法：**走两次一步或者直接走两步**\n\n因此我们可以得到这么一条公式。\n```ts\nfunction getStairsMethods(stairNumber:number):number {\n  //如果台阶数在两次以下，走法对应本身\n  if(n <= 2) return n\n  return getStairsMethods(stairNumber - 1) + getStairsMethods(stairNumber - 2)\n}\n```\n\n暴力递归这种方法通俗易懂，但是非常低效，我们可以来看下它的递归树：\n![alt](http://img.carrotwu.com/Fn5dfZ9yfKztumitbpGnxNa0ERSa)\n\n这个递归树怎么理解？这是一种自顶向下的方法，我们想求出f(10)，得先求出子问题f(9)和f(8),并且满足f(10)=f(9)+f(8)，同理可得f(9)=f(8)+f(7),f(8)=f(7)+f(6),······f(3)=f(2)+f(1)。最后遇到f(2)或者f(1)时，一颗完整的递归树就出来了，这其实就是一个二叉树。\n\n这种递归求解的方式时间复杂度为O(2^n)，其实不难看出这种自顶向下的递归算法其实有一个很大的问题就是：对于任意一个数f(10)或者f(9)f(8)都会递归计算到f(2)f(1)的值，这里面其实做了很多多余的计算：f(9)f(8)都要递归一次f(7)的值。我们不妨换一种思路：不从第10次台阶开始推算：\n1. 从f(1)+f(2)推算出f(3)。保存f(3)的值。\n2. 从f(12+f(3)推算出f(4)。保存f(4)的值\n3.  .....等等。\n\n我们不难看出我们换了一种思路从下层开始推算出上层：要计算f(10)的值，我们得出解法就是先求f(1)f(2)的值再求出f(3)，对于每次求出的值就行缓存。最后通过f(8)+f(9)求出f(10即可)。\n\n### 什么是动态规划\n\n上面的第二种思路：**通过利用各个阶段阶段的递推关系，逐个确定每个阶段的最优决策，并最终得到原问题的最优决策，这就是动态规划**,动态规划擅长解决“多阶段决策问题”。简单来说动态规划就是“大事化小，小事化小”，从小任务开始解决然后扩大规模解决大问题。\n\n1. 动态规划本质上不是递归，甚至可以理解是和递归相反的一种算法设计思想。\n2. 递归是自顶向下的，从顶部开始分解问题，然后通过解决分解出的小问题，从而解决出整个问题\n3. 动态规划是自底向上的，从底部开始解决问题，按照顺序一步一步扩大问题的规模从而去解决整个问题\n\n通过动态规划的思路我们不难得出上面台阶算法题的另外一种解法：\n```ts\nfunction getStairsMethods(n:number):number {\n  //用于缓存 f(1)f(2)f(3)f(4)的数组 先保存f(1)f(2)的值\n  const cacheStairs = Array.from(new Array(n)).fill(0)\n  cacheStairs[0] =1\n  cacheStairs[1] =2\n  // 循环开始\n  for(let i = 3; i<=n; i++){\n    const index = i - 1\n    // 开始计算\n    cacheStairs[index] = cacheStairs[index - 1] + cacheStairs[index -2]\n  }\n  return cacheStairs[n-1]\n}\n```\n\n![alt](http://img.carrotwu.com/FoCAL7x4WvDH66Z0b7RErFoTzsLZ)\n\n### 不同路径问题\n接下来我们看下leetcode上的一道算法题：\n\n![alt](http://img.carrotwu.com/FqU_xzb4VbrDGpElbnHKub9uidTD)\n\n根据上面的动态规划的思想我们试着解决这么一道题：\n1. 因为每次只能**向右走一步或者向下走一步**，所以我们可以得出走到终点时有那么两种情况：1终点上一格的位置向下走一格到终点，2终点左一格的位置向又走一格到终点。\n2. 因此不难得出这么一条公式，对于 m x n 格的网格，路径总数**f(m,n) = f(m-1,n) + f(m, n-1)**。\n3. 其中f(1,1) = 0,f(2,1) = 1,f(1,2) = 1。\n4. 网格中的障碍物怎么办呢。假设障碍物的处在(a,b)位置，意思就是说**走到(a,b)的路径是永远不可能的，因此f(a,b) = 0**。\n5. 注意一些边界条件，如果第一行或者第一列有阻挡物的话，那么后续的方块路径都是0无法到达（第一行有个方块有阻挡物，因为只能向右或者向下，那么右边第一列的都过不去了）\n\n根据上面的思路我们可以得出路径解法如下\n```ts\nconst uniquePathsWithObstacles = function(obstacleGrid: number[][]):number {\n  //先获取m,n的大小\n  const m = obstacleGrid.length\n  const n = obstacleGrid[0].length\n\n  // 制造一个二维数组\n  const cacheArray: number[][] = Array.from({length: m}).fill(1).map(() => ([]))\n  // 其中(1,1)的值为0 (2,1)的值为1 (1,2)的值为\n\n  //如果m,n都为1 或者起点终点坐标有障碍物直接返回0\n  if(obstacleGrid[m-1][n-1] ===1 || obstacleGrid[0][0]) return 0\n  if(m === 1 && n === 1) return 1\n\n  //开始遍历\n  for(let i = 1; i <= m; i++){\n    for(let k = 1; k <= n; k++){\n      const mIndex = i -1\n      const nIndex = k -1\n      // 是否有障碍物\n      const isDisabled = obstacleGrid[mIndex][nIndex] === 1\n      if(isDisabled) {\n        // 障碍物直接给0\n        cacheArray[mIndex][nIndex] = 0\n      }else {\n        // 处理边界值\n        if(i ===1){\n          // i=1时 第一行 如果上一列为0被阻挡了那么是无法下来的 得返回0不然就返回1\n          cacheArray[mIndex][nIndex] = cacheArray[0][nIndex-1] === 0 ? 0: 1\n        }else if(k ===1){\n          // 同理\n          cacheArray[mIndex][nIndex] = cacheArray[mIndex-1][0] === 0 ? 0: 1\n        }else {\n          // 都不是的话 f(m,n) = f(m-1,n) + f(m, n-1)\n          cacheArray[mIndex][nIndex] = cacheArray[mIndex -1][nIndex] + cacheArray[mIndex][nIndex - 1]\n        }\n      }\n    }\n  }\n  return cacheArray[m-1][n-1]\n}\n```\n\n### 背包问题\n接下来我们继续看下一道题，动态规划的比之前更难的一道题就是背包问题，网上已经有很多人进行了解析，接下来我们也开始搞定这么一道题。\n>先举一个很通俗易懂的例子，也是图解算法中的例子，有一个载重量是10kg 的背包，有五个物品，a 2kg 6元，b 2kg 3元，c 6kg 5元，d 5kg 4元，e 4kg 6元。问怎么放物品，价值最高？？\n\n接下来的内容我们将通过表格来方便大家理解\n\n1. 假设我们只有a物品，对于0-10kg的背包而言，明显放下去的价值比较高，这个很好理解。所以如果背包容量足够的话，那么当前价值最高就是a物品的6元。\n\n![alt](http://img.carrotwu.com/Fm1a1Tk8T2SXlEenYzyjsRffe5u3)\n\n2. 假设这时候多了b物品，对于b物品而言只有两种情况：a:放进背包或者b:不放进背包。\n3. 对于a情况而言：假设放进去了b物品，这时候**剩下的背包容量=总容量-b物品的容量**,剩下了的容量我们可以去到a物品的那一行去查找相对应的价值。所以对于a情况而言，价值最高就是**b物品的价值3元加上剩余容量在上一行查找的价值k**(假设背包容器是7kg，这时候放下b物品的话，那么剩余容量就是7-2=5, 所以我们可以在上一行a物品的那一行去查找5kg对应的最大价值是6元，所以放下b物品的最高价值就是3+6=9；假设是3kg的背包的话，那么只剩下1kg的容量查找a那一行的1kg容量的包价值是0元)，这里计算出来的总价值我们为**AA**\n4. 对于b情况而言：不放进去b物品，所以我们可以直接**通过当前背包容量去上一行查找对应的最高价值为BB**\n5. 对于背包b而言放不放的两种情况总价值我们都计算出来了AA和BB，**取最大值的价值CC就是只有物品a和物品b时的最大价值**，继续填进去表格中。\n\n![alt](http://img.carrotwu.com/Fmn8drypGhk5De2HC5ukynUPb-Pc)\n\n6. 一次类推，我们就可以abcde的表格全部罗列出来。\n\n![alt](http://img.carrotwu.com/FoWZGouKKDo30Uw17MSQtE_Ey8Rq)\n\n上面中动态规划的思想就是：我们不通过直接递归求出abcde的所有价值情况。而是先从只有a物品的情况开始计算价值，加上b物品的话存在两种情况：放与不放。通过计算出放与不放的最大值求出只有ab物品时的最大价值。以此类推，在加入c物品时，计算出放入c的价值以加上剩余容量只有ab的价值以及只有不放c只有ab的价值。最终推算出一个0-10kg，所有物品价值的二维数组表格。\n\n```ts\n/**\n *\n * @param weight 物品重量数组\n * @param values 物品价值数组\n * @param maxWeight 背包最大重量\n */\nfunction getProductMaxValue(weight: number[],values: number[],maxWeight: number):Array<Array<number>> {\n  const defaultArray:Array<Array<number>> = Array.from({length: weight.length}).fill(1).map(() => ([]))\n  //获取第一件物品在 0 - maxWeight的价值\n  for(let currentWeight = 1; currentWeight<= maxWeight; currentWeight ++){\n    //第一件物品的价值‘’\n    const firstValue =  values[0]\n    // 当前物品的质量是否大于背包中粮\n    if(weight[0] > currentWeight){\n      // 大于 那么价值就为0\n      defaultArray[0][currentWeight] = 0\n    }else{\n      // 不然 价值就是当前物品的价值\n      defaultArray[0][currentWeight] = firstValue\n    }\n  }\n  // 接下来循环之后的产品\n  for(let currentWeight = 1; currentWeight<= maxWeight; currentWeight ++){\n\n    //获取第二件以及以后的产品价值\n    for(let currentItemIndex = 1; currentItemIndex <= weight.length-1; currentItemIndex++){\n      // 获取当前产品价值\n      const currentItemValue = values[currentItemIndex]\n      // 获取当前产品重量\n      const currentItemWeight = weight[currentItemIndex]\n      const remainWeight = currentWeight - currentItemWeight\n      // 接下来有两种情况 如果能够放进去当前物品的话\n      // 剩余背包的重量 remainWeight = maxWeight - currentWeight\n      // 那入背包的最高价值就是 当前背包价值 加上剩余重量的最高价值（就是上一个数组的重量价值defaultArray[currentItemIndex-1]）\n      // (currentValue + defaultArray[currentItemIndex-1][remainWeight])\n      // 那么比较加入跟不加入之前的价值 取最大即可\n\n      // 不加当前物品质量最大价值（上一个数组就是最大值）\n      const noCurrentItemMaxValue = defaultArray[currentItemIndex-1][currentWeight]\n      if(remainWeight >= 0 ){\n        //  加入当前物品最大价值\n        const addItemMaxValue = currentItemValue + defaultArray[currentItemIndex-1][remainWeight]\n        // 取最大值\n        defaultArray[currentItemIndex][currentWeight] = Math.max(noCurrentItemMaxValue, addItemMaxValue)\n      }else{\n        // 放不进去的话 那么那之前的最大值\n        defaultArray[currentItemIndex][currentWeight] = noCurrentItemMaxValue\n      }\n    }\n  }\n  return defaultArray\n}\n```\n', 1, 'algorithm', '前端学习算法：动态规划', 1, '2020-03-08 17:54:17', '2020-03-08 17:54:17', '2020-03-08 17:55:51', '', NULL);
INSERT INTO `article` VALUES (22, '前端学习算法：好好学习算法，从我做起', 19, '## 动态规划\n\n>每天一道算法题不太行，两三天一道算法题还是可以的吧。坚持算法题，我最薄弱的算法= =冲冲冲。\n### 先从台阶算法题说起\n\n在讲解动态规划之前，我觉得可以先从一个面试题开始讲起——阶梯问题：**假如楼梯有10个台阶，每次可以走1个或2个台阶，请问走完这10个台阶有几种走法**。  题目看似很难入手，我们可以通过下面的步骤思维去理解。\n1. 因为一次只能走1个台阶或者2个台阶，所以可想而知走后一步时只有两种情况：**从第九个台阶走一步上去以及从第八个台阶走两步上去**。\n2. 所以求走完10个台阶的求解就编程了：**走完第8个台阶的走法+走完第九个台阶的走法**。\n3. 以此类推，走完第8个台阶的走法=**走完第7个台阶的走法+走完第6个台阶的走法**。等等等等，这样子可以一直递归下去。\n4. 注意的是，只有一个台阶时只有一种走法：**走一步**。只有两个台阶时只有一种走法：**走两次一步或者直接走两步**\n\n因此我们可以得到这么一条公式。\n```ts\nfunction getStairsMethods(stairNumber:number):number {\n  //如果台阶数在两次以下，走法对应本身\n  if(n <= 2) return n\n  return getStairsMethods(stairNumber - 1) + getStairsMethods(stairNumber - 2)\n}\n```\n\n暴力递归这种方法通俗易懂，但是非常低效，我们可以来看下它的递归树：\n![alt](http://img.carrotwu.com/Fn5dfZ9yfKztumitbpGnxNa0ERSa)\n\n这个递归树怎么理解？这是一种自顶向下的方法，我们想求出f(10)，得先求出子问题f(9)和f(8),并且满足f(10)=f(9)+f(8)，同理可得f(9)=f(8)+f(7),f(8)=f(7)+f(6),······f(3)=f(2)+f(1)。最后遇到f(2)或者f(1)时，一颗完整的递归树就出来了，这其实就是一个二叉树。\n\n这种递归求解的方式时间复杂度为O(2^n)，其实不难看出这种自顶向下的递归算法其实有一个很大的问题就是：对于任意一个数f(10)或者f(9)f(8)都会递归计算到f(2)f(1)的值，这里面其实做了很多多余的计算：f(9)f(8)都要递归一次f(7)的值。我们不妨换一种思路：不从第10次台阶开始推算：\n1. 从f(1)+f(2)推算出f(3)。保存f(3)的值。\n2. 从f(12+f(3)推算出f(4)。保存f(4)的值\n3.  .....等等。\n\n我们不难看出我们换了一种思路从下层开始推算出上层：要计算f(10)的值，我们得出解法就是先求f(1)f(2)的值再求出f(3)，对于每次求出的值就行缓存。最后通过f(8)+f(9)求出f(10即可)。\n\n### 什么是动态规划\n\n上面的第二种思路：**通过利用各个阶段阶段的递推关系，逐个确定每个阶段的最优决策，并最终得到原问题的最优决策，这就是动态规划**,动态规划擅长解决“多阶段决策问题”。简单来说动态规划就是“大事化小，小事化小”，从小任务开始解决然后扩大规模解决大问题。\n\n1. 动态规划本质上不是递归，甚至可以理解是和递归相反的一种算法设计思想。\n2. 递归是自顶向下的，从顶部开始分解问题，然后通过解决分解出的小问题，从而解决出整个问题\n3. 动态规划是自底向上的，从底部开始解决问题，按照顺序一步一步扩大问题的规模从而去解决整个问题\n\n通过动态规划的思路我们不难得出上面台阶算法题的另外一种解法：\n```ts\nfunction getStairsMethods(n:number):number {\n  //用于缓存 f(1)f(2)f(3)f(4)的数组 先保存f(1)f(2)的值\n  const cacheStairs = Array.from(new Array(n)).fill(0)\n  cacheStairs[0] =1\n  cacheStairs[1] =2\n  // 循环开始\n  for(let i = 3; i<=n; i++){\n    const index = i - 1\n    // 开始计算\n    cacheStairs[index] = cacheStairs[index - 1] + cacheStairs[index -2]\n  }\n  return cacheStairs[n-1]\n}\n```\n\n![alt](http://img.carrotwu.com/FoCAL7x4WvDH66Z0b7RErFoTzsLZ)\n\n### 不同路径问题\n接下来我们看下leetcode上的一道算法题：\n\n![alt](http://img.carrotwu.com/FqU_xzb4VbrDGpElbnHKub9uidTD)\n\n根据上面的动态规划的思想我们试着解决这么一道题：\n1. 因为每次只能**向右走一步或者向下走一步**，所以我们可以得出走到终点时有那么两种情况：1终点上一格的位置向下走一格到终点，2终点左一格的位置向又走一格到终点。\n2. 因此不难得出这么一条公式，对于 m x n 格的网格，路径总数**f(m,n) = f(m-1,n) + f(m, n-1)**。\n3. 其中f(1,1) = 0,f(2,1) = 1,f(1,2) = 1。\n4. 网格中的障碍物怎么办呢。假设障碍物的处在(a,b)位置，意思就是说**走到(a,b)的路径是永远不可能的，因此f(a,b) = 0**。\n5. 注意一些边界条件，如果第一行或者第一列有阻挡物的话，那么后续的方块路径都是0无法到达（第一行有个方块有阻挡物，因为只能向右或者向下，那么右边第一列的都过不去了）\n\n根据上面的思路我们可以得出路径解法如下\n```ts\nconst uniquePathsWithObstacles = function(obstacleGrid: number[][]):number {\n  //先获取m,n的大小\n  const m = obstacleGrid.length\n  const n = obstacleGrid[0].length\n\n  // 制造一个二维数组\n  const cacheArray: number[][] = Array.from({length: m}).fill(1).map(() => ([]))\n  // 其中(1,1)的值为0 (2,1)的值为1 (1,2)的值为\n\n  //如果m,n都为1 或者起点终点坐标有障碍物直接返回0\n  if(obstacleGrid[m-1][n-1] ===1 || obstacleGrid[0][0]) return 0\n  if(m === 1 && n === 1) return 1\n\n  //开始遍历\n  for(let i = 1; i <= m; i++){\n    for(let k = 1; k <= n; k++){\n      const mIndex = i -1\n      const nIndex = k -1\n      // 是否有障碍物\n      const isDisabled = obstacleGrid[mIndex][nIndex] === 1\n      if(isDisabled) {\n        // 障碍物直接给0\n        cacheArray[mIndex][nIndex] = 0\n      }else {\n        // 处理边界值\n        if(i ===1){\n          // i=1时 第一行 如果上一列为0被阻挡了那么是无法下来的 得返回0不然就返回1\n          cacheArray[mIndex][nIndex] = cacheArray[0][nIndex-1] === 0 ? 0: 1\n        }else if(k ===1){\n          // 同理\n          cacheArray[mIndex][nIndex] = cacheArray[mIndex-1][0] === 0 ? 0: 1\n        }else {\n          // 都不是的话 f(m,n) = f(m-1,n) + f(m, n-1)\n          cacheArray[mIndex][nIndex] = cacheArray[mIndex -1][nIndex] + cacheArray[mIndex][nIndex - 1]\n        }\n      }\n    }\n  }\n  return cacheArray[m-1][n-1]\n}\n```\n\n### 背包问题\n接下来我们继续看下一道题，动态规划的比之前更难的一道题就是背包问题，网上已经有很多人进行了解析，接下来我们也开始搞定这么一道题。\n>先举一个很通俗易懂的例子，也是图解算法中的例子，有一个载重量是10kg 的背包，有五个物品，a 2kg 6元，b 2kg 3元，c 6kg 5元，d 5kg 4元，e 4kg 6元。问怎么放物品，价值最高？？\n\n接下来的内容我们将通过表格来方便大家理解\n\n1. 假设我们只有a物品，对于0-10kg的背包而言，明显放下去的价值比较高，这个很好理解。所以如果背包容量足够的话，那么当前价值最高就是a物品的6元。\n![alt](http://img.carrotwu.com/Fm1a1Tk8T2SXlEenYzyjsRffe5u3)\n\n2. 假设这时候多了b物品，对于b物品而言只有两种情况：a:放进背包或者b:不放进背包。\n3. 对于a情况而言：假设放进去了b物品，这时候**剩下的背包容量=总容量-b物品的容量**,剩下了的容量我们可以去到a物品的那一行去查找相对应的价值。所以对于a情况而言，价值最高就是**b物品的价值3元加上剩余容量在上一行查找的价值k**(假设背包容器是7kg，这时候放下b物品的话，那么剩余容量就是7-2=5, 所以我们可以在上一行a物品的那一行去查找5kg对应的最大价值是6元，所以放下b物品的最高价值就是3+6=9；假设是3kg的背包的话，那么只剩下1kg的容量查找a那一行的1kg容量的包价值是0元)，这里计算出来的总价值我们为**AA**\n4. 对于b情况而言：不放进去b物品，所以我们可以直接**通过当前背包容量去上一行查找对应的最高价值为BB**\n5. 对于背包b而言放不放的两种情况总价值我们都计算出来了AA和BB，**取最大值的价值CC就是只有物品a和物品b时的最大价值**，继续填进去表格中。\n![alt](http://img.carrotwu.com/Fmn8drypGhk5De2HC5ukynUPb-Pc)\n\n6. 一次类推，我们就可以abcde的表格全部罗列出来。\n![alt](http://img.carrotwu.com/FoWZGouKKDo30Uw17MSQtE_Ey8Rq)\n\n上面中动态规划的思想就是：我们不通过直接递归求出abcde的所有价值情况。而是先从只有a物品的情况开始计算价值，加上b物品的话存在两种情况：放与不放。通过计算出放与不放的最大值求出只有ab物品时的最大价值。以此类推，在加入c物品时，计算出放入c的价值以加上剩余容量只有ab的价值以及只有不放c只有ab的价值。最终推算出一个0-10kg，所有物品价值的二维数组表格。\n\n```ts\n/**\n *\n * @param weight 物品重量数组\n * @param values 物品价值数组\n * @param maxWeight 背包最大重量\n */\nfunction getProductMaxValue(weight: number[],values: number[],maxWeight: number):Array<Array<number>> {\n  const defaultArray:Array<Array<number>> = Array.from({length: weight.length}).fill(1).map(() => ([]))\n  //获取第一件物品在 0 - maxWeight的价值\n  for(let currentWeight = 1; currentWeight<= maxWeight; currentWeight ++){\n    //第一件物品的价值‘’\n    const firstValue =  values[0]\n    // 当前物品的质量是否大于背包中粮\n    if(weight[0] > currentWeight){\n      // 大于 那么价值就为0\n      defaultArray[0][currentWeight] = 0\n    }else{\n      // 不然 价值就是当前物品的价值\n      defaultArray[0][currentWeight] = firstValue\n    }\n  }\n  // 接下来循环之后的产品\n  for(let currentWeight = 1; currentWeight<= maxWeight; currentWeight ++){\n\n    //获取第二件以及以后的产品价值\n    for(let currentItemIndex = 1; currentItemIndex <= weight.length-1; currentItemIndex++){\n      // 获取当前产品价值\n      const currentItemValue = values[currentItemIndex]\n      // 获取当前产品重量\n      const currentItemWeight = weight[currentItemIndex]\n      const remainWeight = currentWeight - currentItemWeight\n      // 接下来有两种情况 如果能够放进去当前物品的话\n      // 剩余背包的重量 remainWeight = maxWeight - currentWeight\n      // 那入背包的最高价值就是 当前背包价值 加上剩余重量的最高价值（就是上一个数组的重量价值defaultArray[currentItemIndex-1]）\n      // (currentValue + defaultArray[currentItemIndex-1][remainWeight])\n      // 那么比较加入跟不加入之前的价值 取最大即可\n\n      // 不加当前物品质量最大价值（上一个数组就是最大值）\n      const noCurrentItemMaxValue = defaultArray[currentItemIndex-1][currentWeight]\n      if(remainWeight >= 0 ){\n        //  加入当前物品最大价值\n        const addItemMaxValue = currentItemValue + defaultArray[currentItemIndex-1][remainWeight]\n        // 取最大值\n        defaultArray[currentItemIndex][currentWeight] = Math.max(noCurrentItemMaxValue, addItemMaxValue)\n      }else{\n        // 放不进去的话 那么那之前的最大值\n        defaultArray[currentItemIndex][currentWeight] = noCurrentItemMaxValue\n      }\n    }\n  }\n  return defaultArray\n}\n```\n', 1, 'algorithm', '前端学习算法：动态规划', 1, '2020-03-08 17:55:20', '2020-09-15 15:50:57', NULL, 'http://img.carrotwu.com/FqDCeoDhLGmkRe1jAfjr6veZcM5M', NULL);
INSERT INTO `article` VALUES (23, '学习算法第二弹之学习数据结构算法数组篇(慢慢更)', 32, '## 数据结构\n\n### 什么是数据结构\n\n数据结构是在计算机中组织和存储数据的一种特殊方式，使得数据可以高效地被访问和修改。更确切地说，数据结构是数据值的集合，表示数据之间的关系，也包括了作用在数据上的函数或操作\n\n### 常见的数据结构\n\n1. 数组：Array\n2. 堆栈：Stack\n3. 队列：Queue\n4. 链表：Linked Lists\n5. 树：Trees\n6. 图：Graphs\n7. 字典树：Trie\n8. 散列表（哈希表）：Hash Tables\n\n## 数组\n\n不用说，数组应该是最熟悉的数据结构，在日常的开发中都有遇到。用于按顺序存储元素的集合。但是元素可以随机存取，因为数组中的每个元素都可以通过数组索引来识别。插入和删除时要移动后续元素，还要考虑扩容问题，插入慢。数组的结构与链表十分相似，但是其实两者是有区别的。\n\n1. 数组在内存中是连续的，属于线性存储，数组通过索引的访问速度很快，但是数组的插入或者删除都要移动所有的后续元素，所以数组更适合于那种一次创建频繁访问的业务中。\n2. 链表在内存中不一定是连续的，属于链性存储。链表一般通过.next 来指向下一个元素。因为链表的非连续特性，链表的访问性能并不高（需要通过.next.next 来访问），但是对于插入和删除元素却得心应手。因为链表内存中是非连续的，插入新元素直接断开节点重新插入节点即可，后续元素并不用进行移动。\n\n### 把数组排成最小的数\n\n#### 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为 321323\n\n> 对于任意的数字 a,b 只有两种组合情况 ab 和 ba,如果 ab>ba 的话那么 ba 就排在前面，确保最小。数字的大小比较我们可以通过 js 中的 sort 函数进行比较即可。\n\n```ts\n/**\n * 把数组排成获取最小数字\n * @param {number[]} numbers\n * @returns {string}\n */\nfunction getMinNumber(numbers: number[]): string {\n  if (Array.isArray(numbers) && numbers.length) {\n    //字符串比较同列字符串大小\n    return numbers\n      .sort((a, b) => {\n        const front = String(a) + b;\n        const behind = String(b) + a;\n        return (front as any) - (behind as any);\n      })\n      .join(\"\");\n  }\n  return \"\";\n}\n```\n\n### 第一个只出现一次的字符\n\n#### 在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回-1（需要区分大小写）。\n\n> 使用一个对象保存相应字母出现的次数,再一次遍历字符串获取对象中为第一个为 1 的索引值\n\n```ts\ninterface StringMap {\n  [key: string]: number;\n}\n\n/**\n * 获取字符串中第一个只出现1次的字母\n * @param {string} str\n * @returns {number}\n */\nfunction getFirstString(str: string): number {\n  if (!str) return -1;\n  const strMap: StringMap = {};\n  for (let i = 0; i < str.length; i++) {\n    const key: keyof StringMap = str[i];\n    strMap[key] = strMap[key] ? strMap[key] + 1 : 1;\n  }\n  // 筛选出第一个1的值\n  for (let i = 0; i < str.length; i++) {\n    if (strMap[str[i]] === 1) {\n      return i;\n    }\n  }\n}\n```\n\n### 调整数组顺序使奇数位于偶数前面\n\n#### 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分\n\n> 使用双指针，首尾开始循环遍历，如有尾部遍历是查到了基数头部遍历到偶数时，进行两个位置的交换直到首尾指针到同一个位置就停止\n\n```ts\n/**\n * 排序数组基数全部在前面偶数在后面\n * @param {number[]} array\n * @returns {number[]}\n */\nfunction formatOrderArray(array: number[]): number[] {\n  let start = 0;\n  let end = array.length - 1;\n  // 不相等一直循环\n  while (start < end) {\n    while (array[start] % 2 === 1) {\n      // 如果头部查找到的是基数继续循环 偶数就退出\n      start++;\n    }\n    while (array[end] % 2 === 0) {\n      // 同理 如果尾部查找到的是偶数继续循环 基数就退出\n      end--;\n    }\n\n    // 在这里已经都找到奇偶数了，但是需要注意一点就是此时可能 start >end了 因为一直在递增所以这里多加个判断\n    if (start < end) {\n      [array[start], array[end]] = [array[end], array[start]];\n    }\n  }\n  return array;\n}\n```\n\n### 和为 S 的连续正整数序列\n\n#### 输入一个正数 S，打印出所有和为 S 的连续正数序列。例如：输入 15，有序 1+2+3+4+5 = 4+5+6 = 7+8 = 15 所以打印出 3 个连续序列 1-5，5-6 和 7-8。\n\n> 又是一个双指针的一道题\n\n1. 创建一个容器 child，用于表示当前的子序列，初始元素为 1,2.\n2. 记录子序列的开头元素 small 和末尾元素 big.(small 默认为 1 big 默认为 2)\n3. big 向右移动子序列末尾增加一个数 small 向右移动子序列开头减少一个数.\n4. 当子序列的和大于目标值，small 向右移动，子序列的和小于目标值，big 向右移动.\n   解释：先判断[1,2]的总值是否小于给定的值 S，如果小于的话说明还需要增加一个数这时候把 3 加入变成[1,2,3]。这时候再判断直到总值大于等于 S。接下来继续循环，如果总之大于 S 的话，那么就把末尾的值删除一个，直到总之值小于等于 S。最后的时候判断和是否等于 S，不是的话会继续回调到上面加数字的步骤。等于值的话保存起来，并且加上一个大数继续循环，直到大数大于等于 S 就退出循环。\n\n```ts\n/**\n * 获取和为s的连续数组\n * @param {number} sum\n * @returns {number[][]}\n * @constructor\n */\nfunction FindContinuousSequence(sum: number): number[][] {\n  // 结果二维数组\n  const result = [];\n  // 用来放置连续数据的数组\n  const child = [1, 2];\n  // 初始化最小值最大值\n  let small = child[0];\n  let big = child[1];\n  // 初始化总值\n  let total = 3;\n  // 开始循环\n  while (big < sum) {\n    while (total < sum && big < sum) {\n      // 总值小于sum，在末尾插入一个big+1的数字\n      big += 1;\n      total += big;\n      child.push(big);\n    }\n    // 大于等于sum了退出循环\n\n    while (total > sum && small < big) {\n      // 总值大于sum，把尾部的small值+1 并且删除child头部的值\n      total -= small;\n      child.shift();\n      small += 1;\n    }\n    // 这时候total值小于等于sum 如果等于的话会进入下面的判断 小于的话会重新进行total<sum的循环\n    if (total === sum && child.length > 1) {\n      // 等于值保存 拷贝新数组\n      result.push(child.concat());\n      // 插入一个值继续进行大数循环\n      big += 1;\n      total += big;\n      child.push(big);\n    }\n  }\n  return result;\n}\n```\n\n### 和为 S 的两个数字\n\n#### 输入一个递增排序的数组和一个数字 S，在数组中查找两个数，使得他们的和正好是 S，如果有多对数字的和等于 S，输出两个数的乘积最小的.\n\n> 又是双指针的经典题\n\n1. 先排序。首尾两个元素相加,这里设为 T。T 跟 S 有三种情况。\n2. 如果 T 大于 S 说明数字大了右边的指针向左边移动一个。继续比较\n3. 如果 T 小于于 S 说明数字小了做边的指针向又边移动一个。继续比较\n4. T 等于 S，命中了。保存这两个值以及乘计，然后首尾都移动一格继续比较\n5. 首部 start >= 尾部 end 退出循环\n\n```ts\n/**\n * 排序数组获取何为s的两个值\n * @param {number[]} array\n * @param {number} sum\n * @returns {number[] | null}\n */\nfunction getTotalArray(array: number[], sum: number): number[] | null {\n  // 初始化头尾\n  let start = 0;\n  let end = array.length - 1;\n  // 初始化存储数组\n  let result: number[] | null = null;\n\n  const sortArray = array.sort((a, b) => a - b);\n  while (start < end) {\n    const startVal = sortArray[start];\n    const endVal = sortArray[end];\n    const totalVal = startVal + endVal;\n    if (totalVal - sum > 0) {\n      // 数字大了 尾部向左移动一格\n      end -= 1;\n    } else if (totalVal - sum < 0) {\n      // 数字笑了， 头部向右移动一格\n      start += 1;\n    } else {\n      // 相等 保存值\n      if (Array.isArray(result)) {\n        const [start, end] = result;\n        if (startVal * endVal - start * end < 0) {\n          // 乘积比较小\n          result = [startVal, endVal];\n        }\n      } else {\n        result = [startVal, endVal];\n      }\n    }\n  }\n  return result;\n}\n```\n\n### 连续子数组的最大和\n\n#### 输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值，要求时间复杂度为 O(n)\n\n> 首先核心的部分就是如何界定数组的边界索引。假设我们从左到右开始计算和，如果和大于 0 就表明前面的边界对后面是有贡献的那么就需要保留并且记录当前索引的值为左边界以及当前和的值，继续进行累加如果累加值大于最大值 max，那么就记录累加值为 max 继续比较并且当前索引值就是右边界\n\n1. 记录一个当前连续子数组最大值 max 默认值为数组第一项，左边界索引为 0.\n2. 记录一个当前连续子数组累加值 sum 默认值为数组第一项，右边界索引为 1.\n3. 从数组第二个数开始，若 sum<0 则当前的 sum 不再对后面的累加有贡献，sum = 当前数\n4. 若 sum>0 则 sum = sum + 当前数\n5. 比较 sum 和 max ，max = 两者最大值\n\n```ts\n/**\n * 连续子数组的最大和以及最大和数组\n * @param {number[]} array\n * @returns {{max: number, maxArray: number[]}}\n */\nfunction getTotalMaxArray(\n  array: number[]\n): { max: number; maxArray: number[] } {\n  // 定义累加值\n  let sum = array[0];\n  // 定义最大值\n  let max = array[0];\n  // 定义临时变量用于保存左边界值\n  let zeroIndex = 0;\n  // 定义左边界\n  let leftIndex = 0;\n  // 定义右边界\n  let rightIndex = array.length;\n  for (let i = 1; i <= array.length - 1; i++) {\n    if (sum < 0) {\n      // 累加值小于0对于后续的数组其实是没有用的所以去掉\n      sum = array[i];\n      zeroIndex = i;\n    } else {\n      sum += array[i];\n    }\n\n    if (sum > max) {\n      // 如果累加值大于当前的最大值的话 相当于是加了个整数的话\n      max = sum;\n      // 左边界指向当前临时左边界的索引\n      leftIndex = zeroIndex;\n      // 右边界指向当前index\n      rightIndex = i + 1;\n    }\n  }\n  const maxArray = array.slice(leftIndex, rightIndex);\n  return {\n    max,\n    maxArray\n  };\n}\n```\n\n### 两数之和\n\n#### 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n\n> 好像是 leetCode 第一题，两次循环暴力穷举复杂度是 O(n2)。其实可以通过一个 map 对象来获取减法的需要值，复杂度降低到 O(n)\n\n```ts\ninterface GetTwoSumMap {\n  [keys: number]: number;\n}\n\n/**\n * 两数之和\n * @param {number[]} array\n * @param {number} sum\n * @returns {number[]}\n */\nfunction getTwoSum(array: number[], sum: number): number[] {\n  const map: GetTwoSumMap = {};\n  for (let i = 0; i < array.length; i++) {\n    const remainVal: keyof GetTwoSumMap = sum - array[i];\n    if (map[remainVal] !== undefined) {\n      // 如果map中有这个值了 返回两个索引即可\n      return [map[remainVal], i];\n    } else {\n      // map中找不到 把当前值添加进map\n      map[array[i]] = i;\n    }\n  }\n  return [];\n}\n```\n\n### 扑克牌顺子\n\n#### 扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这 5 张牌是不是连续的。2-10 为数字本身，A 为 1，J 为 11...大小王可以看成任何数字，可以把它当作 0 处理。\n\n> 核心思想就是因为大小王能够用作任意数字，所以只需要计算出剩余牌的相差值小于等于大小王的数量即可视为顺子\n\n1. 首先对牌进行排序\n2. 计算出大小王的数量，就是获取 0 的数量\n3. 循环获取剩余牌的间隔值，间隔值大于 0 的数量那么认为无法顺子\n4. 有两张牌相等就认为不能成为顺子\n\n```ts\n/**\n * 检查牌是否顺子\n * @param {number[]} array\n * @returns {boolean}\n */\nfunction isContinuePocker(array: number[]): boolean {\n  const sortArray = array.sort((a, b) => a - b);\n  let jokerNum = 0;\n  let spaceNum = 0;\n  for (let i = 0; i < sortArray.length - 1; i++) {\n    if (array[i] === 0) {\n      jokerNum += 1;\n    } else {\n      const space = array[i + 1] - array[i];\n      if (space === 0) return false;\n      spaceNum += space - 1;\n    }\n  }\n  return jokerNum >= spaceNum;\n}\n```\n\n### 三数之和\n\n### 给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。\n\n> 我们可以对数组新进行排序，然后遍历一个数 a,那么求值的操作就可以转化为上面的求和为-a 的两个数。\n\n1. 首先对牌进行排序\n2. 开始进行遍历 a，取后面的剩余数组进行遍历求和-a(这里只需要遍历后续数组的原因是因为，前面的已经计算过和了，不需要再重新进行计算)\n3. 转化为两数之和，使用双指针进行计算，如果当前 a 值与上一个值相同直接跳过。\n\n```ts\n/**\n * 三数相加\n * @param {number[]} array\n * @returns {number[][]}\n */\nfunction threeNumberSum(array: number[]): number[][] {\n  const cacheArray: number[][] = [];\n  const sortArray = array.sort((a, b) => a - b);\n  for (let i = 0; i < sortArray.length; i++) {\n    let start = i + 1;\n    let end = sortArray.length - 1;\n    if (i > 0 && sortArray[i] !== sortArray[i - 1]) {\n      //只有在i大于0 并且不等于上一个数才进行求值\n      while (start < end) {\n        //大于\n        if (sortArray[start] + sortArray[end] > -sortArray[i]) {\n          // 右边左移\n          end -= 1;\n        } else if (sortArray[start] + sortArray[end] < -sortArray[i]) {\n          //小于 左边右移\n          start += 1;\n        } else {\n          // 相等 插入 然后都移动继续循环\n          cacheArray.push([sortArray[i], sortArray[start], sortArray[end]]);\n          end -= 1;\n          start += 1;\n        }\n      }\n    }\n  }\n  return cacheArray;\n}\n```\n\n### 顺时针打印矩阵\n\n#### 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。例如，如果输入如下 4 X 4 矩阵：[[1 2 3 4],[5 6 7 8],[9 10 11 12 ], [13 14 15 16 ]]。则依次打印出数字 1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10。\n\n> 假设起点是(start, start)，那么没走完一个圈，下一个起点就是(start +1, start +1),所以循环的结束条件是 start 都大于宽高的一半，即 start*2 > row && start* 2> column\n\n![alt](http://img.carrotwu.com/FmkXmJNMqu-kOTMR-FhrwMIXN_PS)\n\n1. 设起点坐标为(start,start)，矩阵的行数为 rows，矩阵的列数为 columns,将打印一圈拆解为四部.\n2. 第一步：从左到右打印一行\n3. 第二步：从上到下打印一列\n4. 第三步：从右到左打印一行\n5. 第四步：从下到上打印一列\n6. 注意的是最后一圈会有三种情况，首先还有圈的话那么从左向右是一定有的。\n7. 如果当前 start\\*2 < 列数 column 说明还可以上到下\n8. 如果当前 start\\*2 < 行数 row 说明还可以右到左\n9. 如果当前 start\\*2 + 1 < 列数 column 说明还可以下到上  \n   ![alt](http://img.carrotwu.com/FsHdS2avBVQq6WmCk1i9rAvfLshi)\n\n```ts\n/**\n * 顺时针顺序打印矩形数组\n * @param {number[][]} matrix\n * @returns {number[]}\n */\nfunction getMatrixNum(matrix: number[][]): number[] {\n  if (!matrix.length) return [];\n  const column = matrix.length;\n  const row = matrix[0].length;\n  const result: number[] = [];\n  //初始位置\n  let start = 1;\n  // 如果start *2 > column && start *2>row的时候退出循环\n  while ((start - 1) * 2 < row && (start - 1) * 2 < column) {\n    //首先右到左肯定是有的\n    for (let i = start - 1; i <= row - start; i++) {\n      result.push(matrix[start - 1][i]);\n    }\n    // 从上到下\n    if (start * 2 <= column) {\n      for (let k = start; k <= column - start; k++) {\n        result.push(matrix[k][row - start]);\n      }\n    }\n    // 从右到左\n    if (start * 2 <= column && start * 2 <= row) {\n      for (let i = row - start; i >= start; i--) {\n        result.push(matrix[column - start][i - 1]);\n      }\n      // 从上到下\n      if (start * 2 + 1 <= column) {\n        for (let i = column - start; i > start; i--) {\n          result.push(matrix[i - 1][start - 1]);\n        }\n      }\n    }\n\n    start += 1;\n  }\n  return result;\n}\n```\n', 1, 'algorithm', '数据结构与相应的算法题1(数组篇)', 1, '2020-03-12 19:09:34', '2021-01-27 14:21:47', NULL, 'http://img.carrotwu.com/FmdOlwdj5XD5BN0UiZgOSOVvr9yd', NULL);
INSERT INTO `article` VALUES (24, '周末在家仔细研读react-hook的源码，在这里浅析一下react hook的源码实现', 27, '>当前我看的源码是3/15最新的16.13.0的源码，参考文献的文章源码比较旧了，所以一些参考文章的代码跟我的不一样，比如firstWorkInProgressHook这个属性在最新版是没有了的直接废弃掉了。以及deps改变所打上的tag也是进行了修改，获取update阶段的链表逻辑也发生了改变。最新代码的话请以我这边文章为主。\n## react hooks源码剖析\n1. React是内部是怎么调用hooks的\n2. React是如何在每次重新渲染之后都能返回最新的状态\n3. 状态究竟存放在哪？为什么只能在函数顶层使用Hooks而不能在条件语句等里面使用Hooks\n\n## hooks的两种调用阶段mount和update\n> hooks的源码是放在https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberHooks.js这里\n\n从源码可以看出，react把所有的hooks分成了两个阶段的hooks\n1. mount阶段对应第一次渲染初始化时候调用的hooks方法,分别对应了`mountState`,`mountEffect`,`mountReducer`, `mountLayoutEffect`以及其他hooks。\n2. update阶段对应setXXX函数触发更新重新渲染的更新阶段,分别对应了`updateEffect`,`updateReducer`,`updateState`, `updateLayoutEffect`以及其他hooks\n\n```ts\n// react-reconciler/src/ReactFiberHooks.js\n// Mount 阶段Hooks的定义\nconst HooksDispatcherOnMount: Dispatcher = {\n  useEffect: mountEffect,\n  useReducer: mountReducer,\n  useState: mountState,\n  useLayoutEffect: mountLayoutEffect,\n // 其他Hooks\n};\n\n// Update阶段Hooks的定义\nconst HooksDispatcherOnUpdate: Dispatcher = {\n  useEffect: updateEffect,\n  useReducer: updateReducer,\n  useState: updateState,\n  useLayoutEffect: updateLayoutEffect,\n  // 其他Hooks\n};\n```\nhooks在mount阶段和update阶段所调用的逻辑是不一样的，接下来我们将首先截杀mount阶段时的hooks逻辑\n\n## 第一次mount阶段\n\n### 创建hook链表保存在fiberNode.memoizedState\n1. 在第一次mount阶段时，会调用`mountWorkInProgressHook`方法生成一个新的hooks对象（具体的hook属性可以看下面的注释），如果当前没有hooks的话会把当前hooks作为第一个hooks，有的话之后把当前hooks通过链表串联在上一个hooks的后面。同时，全局有一个`workInProgressHook`的变量指向当前hook链表中最新的hook对象，并且把当前hooks返回出来。\n2. `currentlyRenderingFiber.memoizedState = workInProgressHook = hook;`从这里可以看出hook链表是保存在fiberNode的`memoizedState`属性上的,并且第一个值作为链的表头。\n3. 最后通过.next来进行链表的串联。其中`workInProgressHook`指向的是当前创建的hook对象，最后会返回出去。\n\n```ts\n// [react-reconciler/src/ReactFiberHooks.js](https://github.com/facebook/react/blob/730389b9d3865cb6d5c85e94b9b66f96e391718e/packages/react-reconciler/src/ReactFiberHooks.js#L562)\nfunction mountWorkInProgressHook(): Hook {\n  const hook: Hook = {\n    // hooks的当前值 对于useState来说就是最新的值\n    // 对于useEffect等副作用函数就是一个链表，保存的是一个个effect对象\n    memoizedState: null,\n    baseState: null,\n    baseQueue: null,\n    // 用于useState进行更新数据的queue单向新欢链表，里面保存的是每一次setXXX的updateAction对象\n    queue: null,\n    // 指向下一个hooks\n    next: null,\n  };\n\n  if (workInProgressHook === null) {\n    // This is the first hook in the list\n    // 从这里可以清晰看到 hook链表是保存在fiberNode的memoizedState属性上的\n    // 第一个hook当做表头\n    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;\n  } else {\n    // Append to the end of the list\n    // 因为memoizedState保留的是workInProgressHook的引用 所以这里.next其实是设置memoizedState的链表\n    // 最后返回的workInProgressHook为当前创建的hook对象\n    workInProgressHook = workInProgressHook.next = hook;\n  }\n  return workInProgressHook;\n}\n```\n\n![alt](http://img.carrotwu.com/Fi-_5Hb4C4lSLJIwvZxrOYq-Rhi6)\n\n### hook内创建一个queue链表\n1. 同时呢会在当前hooks里通过initialState保存当前值在`memoizedState`。并且会创建一个`queue`链表，这是一个单向循环链表（环）。因为mount阶段时是第一次渲染，没有action对象所以返回出去的是初始值，以及一个`dispatchAction`方法这个后面说。这个queue链表跟上面的hooks链表有点像，不过有两个不同点。\n 1. queue的链表有个last属性永远指向最新的updateAction对象，这个属性是为了方便拿到最新`updateAction`对象（因为多次setXXX都会需要一直拿到最新的updateAction对象，跟上面的hooks不太一样）。\n 2. queue是一个单向循环链表(环)，什么意思呢？就是queue的最后一个`updateAction`对象.next指向的是第一个updateAction对象，形成一个环。所以呢他们可以通过`queue.last`获取最新的updateAction对象,`queue.last.next`获取第一个updateAction对象。\n\n```ts\n//首次render时执行mountState\nfunction mountState(initialState) {\n  // 从当前Fiber生成一个新的hook对象，将此hook挂载到Fiber的hook链尾，并返回这个hook\n  var hook = mountWorkInProgressHook();\n\n  hook.memoizedState = hook.baseState = initialState;\n\n  var queue = hook.queue = {\n    last: null,\n    dispatch: null,\n    lastRenderedReducer: (state, action) => isFn(state) ? action(state) : action,\n    lastRenderedState: initialState\n  };\n  // currentlyRenderingFiber$1保存当前正在渲染的Fiber节点\n  // 将返回的dispatch和调用hook的节点建立起了连接，同时在dispatch里边可以访问queue对象\n  var dispatch = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue);\n  return [hook.memoizedState, dispatch];\n}\n```\n![alt](http://img.carrotwu.com/FsN5wDfcZOdCWF3SpA0UR4aKb1lh) \n\n 简单说就是mount的时候通过`workInProgressHook`来保存当前的hooks，然后通过.next来保存hooks，形成一个hooks的单向链表。同时呢，在每一个hooks的内部会维护一个queue的单向循环链表。并且hooks的单向链表保存在相对应的fiberNode的`memoizedState`，这样子在update阶段的时候我们就可以直接通过fiberNode的`memoizedState`属性获取hook链表了\n\n\n## updateState阶段\n>updateState阶段指的是setXXX之后触发重新渲染的阶段\n\n### setXXX函数做的事情\n1. 执行setXXX函数的时候，其实就是执行上文的`dispatchAction`函数\n\n```ts\n  // currentlyRenderingFiber$1保存当前正在渲染的Fiber节点\n  // 将返回的dispatch和调用hook的节点建立起了连接，同时在dispatch里边可以访问queue对象\n  var dispatch = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue);\n  return [hook.memoizedState, dispatch];\n```\n2. `dispatchAction`其实就是生成一个新的updateAction对象，其中action就是传入的值。如果`queue.last`没有值说明queue链表为空，把当前updateAction对象当做表头。并且下一个.next指向自己，同时queue.last指向当前最新的updateAction对象。最后会调用react的`scheduleWork`更新调度。\n\n```ts\n//// 功能相当于setState！\nfunction dispatchAction(fiber, queue, action) {\n  ...\n  var update = {\n    action, // 接受普通值，也可以是函数\n    next: null,\n  };\n  var last = queue.last;\n\n  //如果last为空 说明该hook是第一次setXXX 直接把当前updateAction对象当成表头\n  if (last === null) {\n    update.next = update;\n  } else {\n    // 不是的话拼接在最新action的末尾\n    last.next = update;\n  }\n\n  // 略去计算update的state过程\n  queue.last = update;\n  ...\n  // 触发React的更新调度，scheduleWork是schedule阶段的起点\n  scheduleWork(fiber, expirationTime);\n}\n\n```\n![alt](http://img.carrotwu.com/FsN5wDfcZOdCWF3SpA0UR4aKb1lh) \n\n### update阶段（state改变、父组件re-render等都会引起组件状态更新）useState()更新状态：\n1. 在updateState的过程中会判断传入的action，如果是函数那么执行返回（setState也可以是一个函数）。\n\n```ts\nfunction updateState(initialState) {\n  return updateReducer(basicStateReducer, initialState);\n}\n\nfunction basicStateReducer(state, action){\n  return typeof action === \'function\' ? action(state) : action;\n}\n\n```\n2. update的时候如何获取当前的hooks链表呢，因为我们知道hooks链表是保存在fiberNode上的`memoizedState`属性上。如果是`currentHook`为null说明是第一次拿hook链表那么直接返回fiberNode的`memoizedState`即可，第二个hooks通过.next获取就可以了。最终会把解构一个新的newHook拼接在`workInProgressHook`链表上即可。这样子就能拿到更新时的hooks了。\n\n```ts\n// react-reconciler/src/ReactFiberHooks.js\nfunction updateWorkInProgressHook() {\n  let nextCurrentHook: null | Hook;\n  // 当前hook链表为空 那么久直接拿fiberNode上的memoizedState属性\n  if (currentHook === null) {\n     // 获取fiberNode节点\n    let current = currentlyRenderingFiber.alternate;\n    if (current !== null) {\n      nextCurrentHook = current.memoizedState;\n    } else {\n      nextCurrentHook = null;\n    }\n  } else {\n    // 不为空 那么下一个hook就是 currentHook.next的下一个hook\n    nextCurrentHook = currentHook.next;\n  }\n\n\n  currentHook = nextCurrentHook;\n\n   // 创建一个新的hooks链表 结构\n  const newHook: Hook = {\n    memoizedState: currentHook.memoizedState,\n\n    baseState: currentHook.baseState,\n    baseQueue: currentHook.baseQueue,\n    queue: currentHook.queue,\n\n    next: null,\n  };\n  if (workInProgressHook === null) {\n    // This is the first hook in the list.\n      // 老的hooks对象直接抛弃 解构一个新的hooks对象返回给当前的memoizedState上 不复用之前的hooks对象了\n    currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;\n  } else {\n    // Append to the end of the list.\n    workInProgressHook = workInProgressHook.next = newHook;\n  }\n  return workInProgressHook;\n}\n```\n3. 接下来呢通过`updateWorkInProgressHook`获取当前的hooks，然后获取queue链表，其中`queue.last`为最新的action, `queue.last.next`为第一个action。这样子我们就可以获取setXXX函数传的所有updateAction对象了\n4. 从第一个action开始，循环到最新的action位置。调用reducer函数获取最新的state值，最后进行返回即可。\n\n```ts\nfunction updateReducer(reducer,initialArg,init) {\n  const hook = updateWorkInProgressHook();\n  const queue = hook.queue;\n\n  // 拿到更新列表的表头\n  const last = queue.last;\n\n  // 获取最早的那个update对象\n  first = last !== null ? last.next : null;\n\n  if (first !== null) {\n    let newState;\n    let update = first;\n    do {\n      // 执行每一次更新，去更新状态\n      const action = update.action;\n      newState = reducer(newState, action);\n      update = update.next;\n    } while (update !== null && update !== first);\n\n    hook.memoizedState = newState;\n  }\n  const dispatch = queue.dispatch;\n  // 返回最新的状态和修改状态的方法\n  return [hook.memoizedState, dispatch];\n}\n```\n![alt](http://img.carrotwu.com/Fhf7rFFSkP7mvIRAsbUednwbgC7x)\n\n## useEffect\n> useEffect其实前面跟useState类似，都是创建hooks，拼接hooks链表，不同的是effect的回调而已\nuseEffect其实跟useState一样，分成了`mountEffect`和`updateEffect`\n\n```ts\nfunction mountEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  return mountEffectImpl(\n    UpdateEffect | PassiveEffect,\n    HookPassive,\n    create,\n    deps,\n  );\n}\n\nfunction updateEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  return updateEffectImpl(\n    UpdateEffect | PassiveEffect,\n    HookPassive,\n    create,\n    deps,\n  );\n}\n```\n### mountEffect\n1. 跟useState一样，通过`mountWorkInProgressHook`创建一个新的hooks，拼接在fiberNode的`memoizedState`链表上\n2. 通过`pushEffect`方法生成一个effect的单向链表保存在`hooks.memoizedState`属性上，这个是每一次的effect链表。`hooks.memoizedStated`的保存的是每一个useEffect自身的effect对象。\n3. 但是有时候**一个组件中会有多个useEffect**，所以需要一个`componentUpdateQueue`单向循环链表来收集所有的useEffect的effect的对象。\n4. `componentUpdateQueue`的引用指向的是fiberNode的`updateQueue`属性，后续对`componentUpdateQueue`的修改其实就是修改fiberNode的`updateQueue`属性\n5. `componentUpdateQueue`收集的是当前fiberNode所有的effect节点。\n6. 因为mount阶段的useEffect都会执行，所以mount阶段的effect都会被打上`HookHasEffect`的tag标记。\n7. `HookHasEffect`指的是后续需要执行的effect，其中`hookEffectTag`标记的是不需要执行的effect（update阶段会解释）\n\n```ts\nfunction mountEffectImpl(fiberEffectTag, hookEffectTag, create, deps): void {\n  //创建新的hooks进行拼接\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  currentlyRenderingFiber.effectTag |= fiberEffectTag;\n  // 创建一个effect链表 跟useState的queue链表差不多。是一个单向链表，hook.memoizedState保存的都是自身useEffect的effect对象\n  //不过属性不一样具体effect可以看pushEffect\n  hook.memoizedState = pushEffect(\n    HookHasEffect | hookEffectTag,\n    create,\n    // mount阶段没有需要先执行的destory函数\n    undefined,\n    nextDeps,\n  );\n}\nfunction pushEffect(tag, create, destroy, deps) {\n  // effect会保存在\n  const effect: Effect = {\n    tag,\n    // 渲染后执行的回调 对应useEffect的回调函数\n    create,\n    // 下一次渲染前执行的回调 对应useEffect的return的函数\n    destroy,\n    // 依赖\n    deps,\n    // Circular\n    next: (null: any),\n  };\n\n  // 获取当前fiberNode的updateQueue链表  currentlyRenderingFiber.updateQueue\n  let componentUpdateQueue: null | FunctionComponentUpdateQueue = (currentlyRenderingFiber.updateQueue: any);\n\n  // 有时候**一个组件中会有多个useEffect**，所以componentUpdateQueue收集的是当前fiberNode所有的effect节点\n\n  // componentUpdateQueue为空 说明是第一个useEffect\n  if (componentUpdateQueue === null) {\n    // 收集第一个useEffect的第一个effect对象\n    componentUpdateQueue = createFunctionComponentUpdateQueue();\n    // 这里把componentUpdateQueue的引用指向updateQueue 下次就可以通过fiberNode的updateQueue属性拿到了\n    currentlyRenderingFiber.updateQueue = (componentUpdateQueue: any);\n    // lastEffect指向最新的effect 单向循环链表\n    componentUpdateQueue.lastEffect = effect.next = effect;\n  } else {\n    // 不是第一个useEffect了\n    const lastEffect = componentUpdateQueue.lastEffect;\n    if (lastEffect === null) {\n      componentUpdateQueue.lastEffect = effect.next = effect;\n    } else {\n     // 末尾设置最新的effect对象\n      const firstEffect = lastEffect.next;\n      // lastEffec为上一次最新的effect， 把当前最新的effect拼接到末尾\n      lastEffect.next = effect;\n      // 末尾最新的effect又指向到第一个effect形成环\n      effect.next = firstEffect;\n      componentUpdateQueue.lastEffect = effect;\n    }\n  }\n  return effect;\n}\n\n// 创建新的ComponentUpdateQueue单向循环链表\nfunction createFunctionComponentUpdateQueue(): FunctionComponentUpdateQueue {\n  return {\n    lastEffect: null,\n  };\n}\n\n```\n\n![alt](http://img.carrotwu.com/FlnfsZPKsVRCQ5yJlV_kXIrCKmK-)\n\n### updateEffect\n> updateEffect最重要的就是会给那些deps没有发生改变的effect搭上hookEffectTag标记，后续的循环执行回调时会跳过执行。\n\n1. 通过`areHookInputsEqual`函数判断deps是否有改变，没改变的话打上`hookEffectTag`的tag，后续的循环不会执行回调\n2. 如果deps改变那么就会打上`HookHasEffect`的tag ，并且更新当前hooks的`memoizedState`属性为effect新的链表\n\n```ts\nfunction updateEffectImpl(fiberEffectTag, hookEffectTag, create, deps): void {\n  // 跟useState一样获取当前的hook对象\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  let destroy = undefined;\n\n  if (currentHook !== null) {\n    const prevEffect = currentHook.memoizedState;\n         // 获取上一次effect的destroy回调\n    destroy = prevEffect.destroy;\n    if (nextDeps !== null) {\n     // 获取上一次effect的deps\n      const prevDeps = prevEffect.deps;\n      // 如果deps相同 打上hookEffectTag标记 后续循环的时候不会执行\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        pushEffect(hookEffectTag, create, destroy, nextDeps);\n        return;\n      }\n    }\n  }\n\n  currentlyRenderingFiber.effectTag |= fiberEffectTag;\n\n// 如果deps不想同 打上HookHasEffect标记 下次会执行\n// 同时 会更新当前hooks的memoizedState树形\n  hook.memoizedState = pushEffect(\n    HookHasEffect | hookEffectTag,\n    create,\n    destroy,\n    nextDeps,\n  );\n}\n\n// 浅比较dep的函数\nfunction areHookInputsEqual(\n  nextDeps: Array<mixed>,\n  prevDeps: Array<mixed> | null,\n) {\n  if (prevDeps === null) {\n    return false;\n  }\n\n  // 浅比较\n  for (let i = 0; i < prevDeps.length && i < nextDeps.length; i++) {\n    if (is(nextDeps[i], prevDeps[i])) {\n      continue;\n    }\n    return false;\n  }\n  return true;\n}\n```\n\n![alt](http://img.carrotwu.com/FibJc6mz5z8QIanntbMXWH3qmNRy)\n\n给fiberNode.updateQueue添加完相对应的effect之后，最后我们就需要循环执行相应的effect副作用函数。\n1. 在`commitHookEffectListUnmount`和`commitHookEffectListMount`中遍历执行相应的`destory`或者`create`副作用方法。\n2. 获取fiberNode节点上的`updateQueue`，其实就是获取之前保存的`componentUpdateQueue`(同一个引用)，\n3. 可以发现只有当**if ((effect.tag & tag) === tag)**的时候才会执行相应的回调函数，发现tag是传进来的参数具体是什么值呢。\n4. 从上面可以知道的是：1 初次渲染传的tag是`HookHasEffect`，deps发生改变传的也是`HookHasEffect`。deps没发生改变传的是`HooktagEffect`\n\n```ts\n// 组件卸载时执行的副作用函数\nfunction commitHookEffectListUnmount(tag: number, finishedWork: Fiber) {\n  const updateQueue: FunctionComponentUpdateQueue | null = (finishedWork.updateQueue: any);\n  // 取fiberNode节点上的updateQueue\n  let lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n  if (lastEffect !== null) {\n    // 记得上面说的循环链表吗\n    const firstEffect = lastEffect.next;\n    let effect = firstEffect;\n    // 从第一个effect开始执行直到最后一个effect\n    do {\n      // effect.tag就是我们赋值的tag 从上面可以知道的是\n      if ((effect.tag & tag) === tag) {\n        // Unmount\n        // 获取destory方法并且执行\n        const destroy = effect.destroy;\n        effect.destroy = undefined;\n        if (destroy !== undefined) {\n          destroy();\n        }\n      }\n      effect = effect.next;\n    } while (effect !== firstEffect);\n  }\n}\n\n//组件渲染是执行的副作用函数 其实就是执行create\nfunction commitHookEffectListMount(tag: number, finishedWork: Fiber) {\n  const updateQueue: FunctionComponentUpdateQueue | null = (finishedWork.updateQueue: any);\n  let lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n  if (lastEffect !== null) {\n    const firstEffect = lastEffect.next;\n    let effect = firstEffect;\n    do {\n      if ((effect.tag & tag) === tag) {\n        // Mount\n        const create = effect.create;\n        // create方法执行后return的函数就是卸载的方法\n        effect.destroy = create();\n      }\n      effect = effect.next;\n    } while (effect !== firstEffect);\n  }\n}\n```\n\n### commitWork中调用的commitHookEffectListUnmount方法\n>这段代码的出处https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberCommitWork.js#L1564\n\n1. 最终我们在commitWork中发现了传入的tag值 `commitHookEffectListUnmount(HookLayout | HookHasEffect, finishedWork)`\n2. 以及` commitHookEffectListUnmount(HookLayout | HookHasEffect, finishedWork)`这两个调用函数接收`HookHasEffect`以及`HookLayout`，对应我们上面deps发生改变时候的tag\n3. `HookLayout`值的是useLayoutEffect，`HookHasEffect`指的是useEffect的tag，这就解释了我们上面deps没改变传入的HookTagEffect并不会进行执行。\n\n```ts\nfunction commitWork(current: Fiber | null, finishedWork: Fiber): void {\n  if (!supportsMutation) {\n    switch (finishedWork.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case MemoComponent:\n      case SimpleMemoComponent:\n      case Block: {\n        if (\n          enableProfilerTimer &&\n          enableProfilerCommitHooks &&\n          finishedWork.mode & ProfileMode\n        ) {\n          try {\n            startLayoutEffectTimer();\n            commitHookEffectListUnmount(\n              HookLayout | HookHasEffect,\n              finishedWork,\n            );\n          } finally {\n            recordLayoutEffectDuration(finishedWork);\n          }\n        } else {\n          commitHookEffectListUnmount(HookLayout | HookHasEffect, finishedWork);\n        }\n        return;\n      }\n    }\n\n    commitContainer(finishedWork);\n    return;\n  }\n\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent:\n    case Block: {\n      if (\n        enableProfilerTimer &&\n        enableProfilerCommitHooks &&\n        finishedWork.mode & ProfileMode\n      ) {\n        try {\n          startLayoutEffectTimer();\n          commitHookEffectListUnmount(HookLayout | HookHasEffect, finishedWork);\n        } finally {\n          recordLayoutEffectDuration(finishedWork);\n        }\n      } else {\n        commitHookEffectListUnmount(HookLayout | HookHasEffect, finishedWork);\n      }\n      return;\n    }\n\n}\n```\n## useLayoutEffect\nuseLayoutEffect其实跟useEffect流程一样，不同的地方在于打上的tag标记。useLayoutEffect的是HookLayout，useEffect的tag标记是HookHasEffect。\n\n## 完整流程图\n\n![alt](http://img.carrotwu.com/FspIG1c8XiPWHChOe-jwOwsfDsla)\n\n## 参考\n>当前我看的源码是3/15最新的16.13.0的源码，参考文献的文章源码比较旧了，所以一些参考文章的代码跟我的不一样，比如firstWorkInProgressHook这个属性在最新版是没有了的直接废弃掉了。以及deps改变所打上的tag也是进行了修改，获取update阶段的链表逻辑也发生了改变。最新代码的话请以我这边文章为主。\n\n[React Hooks源码解析，原来这么简单～](https://juejin.im/post/5e5e66d6e51d4526e651c796)\n\n', 1, 'react,reactHooks', 'react hook源码解析', 1, '2020-03-15 21:36:44', '2021-01-20 16:18:25', NULL, 'http://img.carrotwu.com/FnFfNrtqMVJu3_JSUTMJNmnIZhMC', NULL);
INSERT INTO `article` VALUES (25, '学习算法第二弹之学习数据结构算法链表(慢慢更)', 0, '> 本文是在[**ConardLi 的【前端该如何准备数据结构和算法？】总结而来**](https://juejin.im/post/5d5b307b5188253da24d3cd1 \"Markdown\"),代码实现上是我自己使用 ts 编写，题目均是跟着上文编写。\n\n## 数据结构\n\n### 什么是数据结构\n\n数据结构是在计算机中组织和存储数据的一种特殊方式，使得数据可以高效地被访问和修改。更确切地说，数据结构是数据值的集合，表示数据之间的关系，也包括了作用在数据上的函数或操作\n\n### 常见的数据结构\n\n1. 数组：Array\n2. 堆栈：Stack\n3. 队列：Queue\n4. 链表：Linked Lists\n5. 树：Trees\n6. 图：Graphs\n7. 字典树：Trie\n8. 散列表（哈希表）：Hash Tables\n\n## 链表\n链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。下图展 示了一个链表的结构。\n相对于传统的数组，链表的一个好处在于，添加或移除元素的时候不需要移动其他元素。然而，链表需要使用指针，因此实现链表时需要额外注意。在数组中，我们可以直接访问任何位置 的任何元素，而要想访问链表中间的一个元素，则需要从起点（表头）开始迭代链表直到找到所需的元素。  \n\n![alt](http://img.carrotwu.com/Fs-JoZqQn23hhaLKRdrZEENMsxYN) \n\n在react fiber和react hooks中用到的大量的链表结构，其中fiber node是一条双向链表（通过child指向子节点，sibling指向兄弟节点，通过return返回父节点）。react hooks是单向链表，hooks内部的update对象queue则是单向循环链表。\n\n### 从尾到头打印链表\n#### 输入一个链表，按链表值从尾到头的顺序返回一个ArrayList\n>通过递归.next获取下一个链表，直到.next为null\n\n```ts\ninterface List {\n  next: List | null,\n  val: string\n}\n\n/**\n * 从尾部到头部打印链表\n * @param {List} list\n * @returns {string[]}\n */\nfunction printList(list: List) {\n  const array = []\n  while (list) {\n    array.unshift(list.val)\n    list = list.next\n  }\n  return array\n}\n```\n\n### 反转链表\n#### 输入一个链表，反转链表后，输出新链表的表头。\n\n1. 每一次循环的本质就是一直保留头部第一个链表head（这里是a1）,每次循环的时候把第二个之后的链表拿出来currentNode (这里是a2-n)拿出来,之后把头部head（a1）链表执向a2-n的下一个即a3-n所以头部链表head就变成了(a1.next => a3-n)。这时候注意因为一开始headNode跟head的引用是相同的所以这时候headNode也是(a1.next => a3-n)。最后把currentNode.next执向headNode所以就变成了(a2.next=>a1.next => a3-n)\n2. head == a1.next =>a3.next.... currentNode === headNode === a2.next => a1.next => a3.next...\n3. 从上面可以看出headNode跟head之间是有引用关系的即(headNode.next === head),两者引用是相同的。所以修改head的引用值也会改变headNode.next的引用值\n2. 继续循环,注意下面两句\n\n```js\n  // 第三点 headNodg跟head的引用是有联系的\n  let headNode = head;\n  // 这里修改了head引用，所以headNode也会发生改变\n  // a1.next => a4.next =>a5\n  // 所以 headNode.next === a1.next => a4.next =>a5 最终就是 a3.next =>a2.next =>a1.next => a4.next =>a5\n  head.next = currentNode.next;\n  currentNode.next = headNode;\n\n```\n解答:   \n\n```ts\nfunction reverseList(head: List): List {\n  let headNode = head\n  let currentNode = null\n  while (head && head.next) {\n    // 获取第二个链表\n    currentNode = head.next\n    //head的下一个链表指向下下一个即第三个\n    head.next = currentNode.next\n    // 第二个链表指向头部链表\n    currentNode.next = headNode\n\n    headNode = currentNode\n  }\n  return headNode\n}\n```\n\n#### 输入一个链表，输出该链表中倒数第k个结点。\n>如果先循环出链表的所有长度在进行求值的话，需要循环两次复杂度为2n。可以使用双指针进行优化\n1. 初始指针a,第二个指针b与指针a间隔为k\n2. 这时候两个指针都进行循环，如果b指针到达终点了，那么a指针当前位置就是倒数第k个节点位置\n\n```ts\n * 获取倒数第n个节点的链表\n * @param {List} list\n * @param {number} k\n * @returns {string | null}\n */\nfunction getLastListVal(list: List, k: number): string | null {\n  if (Number(k) > 0) {\n    let slow = list\n    let fast = list\n    let index = 1\n    while (fast && fast.next) {\n      fast = fast.next\n      if (index >= k) {\n        slow = slow.next\n      }\n      index++\n    }\n    return index < k ? null : slow.val\n  } else {\n    return null\n  }\n}\n```\n\n### 链表中环的入口节点（查找链表是否有环）\n#### 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。\n>问题可以拆分成两部分1如果判断链表是否有环，第二个如何查找环的起点。\n1. 如何判断链表是否有环：我们只需要两个指针，一个走一步，一个走两步，只要指针有相遇的话那么就是有环。（假设链表没有环的话，那么因为快指针走的越来越远那么两个指针永远不可能相遇。如果链表有环，假设快慢指针都在环里面，如果以慢指针作为参考物，那么快指针每次走一步，如果有环的话，那么两个指针最终一定会相遇）\n2. 如何判断环的起点。首先我们假设有两个指针都在环的起点，如果让某一个指针先走环的长度K，那么该指针还是会回到环的起点与另一个指针相遇。这时候快的指针相对于慢的指针其实是先走了K步，这时候快的指针相对于慢的指针先走了环的长度k步。我们再把两个指针平移同样的步数直到慢的起点。所以最终判断环的起点问题可以转化为：两个指针a,b。a在起点，b先走环的长度，如果a和b相遇了那么当前位置就是环的起点入口。\n3. 环的长度可以通过在环内的一点每次走一步又走到当前点的话，那么走的步数就是环的长度。\n\n```ts\nfunction getListStart(list: List): List | null {\n  // 首先判断链表是否有环\n  // 慢的先走1步\n  let slow = list.next\n  // 快的先走两步\n  let fast = list.next.next\n\n  // 初始化环的长度\n  let squareLength = 0\n  while(fast !== slow) {\n    if(fast && fast.next){\n      fast = fast.next.next\n      slow = slow.next\n    }else {\n      // 快指针已经到终点了还没遇到那么久没有环\n      return null\n    }\n  }\n  \n  // 有环 这里需要拿环的长度 此时 fast和slow必定在环内\n  slow = slow.next\n  squareLength +=1\n  while(slow !== fast) {\n    slow = slow.next\n    squareLength +=1\n  }\n  // 都回到原点\n  slow = list\n  fast = list\n  // 快指针先走环的长度步数\n  for(let i =1; i <= squareLength; i++){\n    fast = fast.next\n  }\n  //获取环的起点\n  while(slow !== fast) {\n    slow = slow.next\n    fast = fast.next\n  }\n  return slow\n}\n```\n\n### 两个链表的第一个公共节点\n#### 输入两个链表，找出它们的第一个公共结点。\n>假设两个公共链表有公共节点，那么从这节点开始后续的元素位置相同并且长度必须相等合并成一条线，所以我们两条链表的尾部对齐，长一点的链表pass掉差异的长度，然后依次比较是否相等即可。\n1. 通过循环获取链表的长度。\n2. 获取长的链表先走长度的差异值步\n3. 同时循环查找是否有相等的节点，有的话就是公共节点\n\n```ts\nfunction getFirstCommonNode(a: List, b: List): List | null {\n  if (!a || !b) {\n    return null;\n  }\n\n  //获取链表长度\n  function getListLength(list: List) {\n    let listLength = 0;\n    while (list) {\n      listLength += 1;\n      list = list.next;\n    }\n    return listLength;\n  }\n  const aLength = getListLength(a);\n  const bLength = getListLength(b);\n\n  let long = aLength > bLength ? a : b;\n  let short = aLength > bLength ? b : a;\n\n  // 长的链表跳过长度差异\n  for (let i = 0; i < Math.abs(aLength - bLength); i++) {\n    long = long.next;\n  }\n\n  while (short && long) {\n    if (short === long) {\n      return short;\n    }\n    short = short.next;\n    long = long.next;\n  }\n  return null;\n}\n```\n\n### 约瑟夫环\n#### 0,1,...,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。\n>约瑟夫环总共有三种做法：1通过链表循环删除对应的节点，2通过数组取值使用索引，3通过递归。\n1. 使用链表，我们只需要把元素组装成一个链表，然后通过循环没过m个节点删除元素即可，直到只剩下一个元素\n2. 通过描述我们可以得出一条规律：从当前某个元素开始数，下一个被删除的数字等于m除以总人数的余数，假设第1次删除的数字是：第一个数字0开始数起的第m个数。举个例子：假设m是2，总人数是10,那么第(2 % 10) = 2第二个数字要被删除。对应索引的话就得到删除的索引Index = ((m)% n) -1。我们可以通过数组去循环即可。\n3. d动态规划: \n 1. 第一轮的时候第一个被删除索引是(m-1)%n。所以第二轮的开始（0）位置索引就是m%n,所以推导出第二轮第k个位置在第1轮的索引就是(m+k)%n。\n 2. 假设在第n轮时候的某个人位置是f(n)，那么第n-1轮的时候位置其实就是f(n-1) = (m+f(n))%n。即第7轮某个人位置是2 那么第6轮他的位置就是(m+ 2)%n, 那么第五轮他的位置就是(m + ((m+ 2)%n))%n。\n 3. 现在我们知道8个人时，最后一轮就是第七轮因为每一轮走一个人此时剩下的人索引就是0，所以上一轮他的位置就是(m+2)%8,因此我们可以一直循环上去直到第一轮就是他获取的位置。\n\n```ts\n//链表解决\nfunction getRemainPeopleIndexByList(total: number, space: number): number{\n  interface List {\n    next?: List ;\n    val: number;\n  }\n  const head:List = {val : 0}\n  let current: List = head\n  for(let i=1; i<total; i++){\n    current.next = {val: i}\n    current = current.next\n  }\n  current.next = head\n  while (current.next != current) {\n    for (let i = 0; i < m - 1; i++) {\n      current = current.next;\n    }\n    current.next = current.next.next;\n  }\n  return current.val;\n}\n\n// 数组\nfunction getRemainPeopleIndexByArray(total: number, space: number): number{\n  if (total < 1 || space < 1) {\n    return -1;\n  }\n  const array = [];\n  let index = 0;\n  for (let i = 0; i < total; i++) {\n    array[i] = i;\n  }\n  while (array.length > 1) {\n    index = (index + space) % array.length - 1;\n    if (index >= 0) {\n      array.splice(index, 1);\n    } else {\n      array.splice(array.length - 1, 1);\n      index = 0;\n    }\n  }\n  return array[0];\n}\n\n//动态规划\nfunction getRemainPeopleIndex(total: number, space: number): number {\n  // 总共要进行的轮数才剩一人\n  let totalLunshu = total - 1\n  // 最后第totalLunshu轮时胜利人的索引是0\n  let lastPeopleIndex = 0\n  // 1. 第一轮的时候第一个被删除索引是(m-1)%n。所以第二轮的开始（0）位置索引就是m%n,所以推导出第二轮第k个位置在第1轮的索引就是(m+k)%n。\n  // 2. 假设在第n轮时候的某个人位置是f(n)，那么第n-1轮的时候位置其实就是f(n-1) = (m+f(n))%(total - n)。即第7轮某个人位置是2 那么第6轮他的位置就是(m+ 2)%(total - 6), 那么第五轮他的位置就是(m + ((m+ 2)%n))%n。\n  // 3. 现在我们知道8个人时，最后一轮就是第七轮因为每一轮走一个人此时剩下的人索引就是0，所以上一轮他的位置就是(m+2)%8,因此我们可以一直循环上去直到第一轮就是他获取的位置。\n\n  // 一直循环到00位置 走totalLunshu轮\n  while(totalLunshu > 0){\n    //上一轮的索引 f(n-1) = f(n-1) = (m+f(n))%（每一轮的人数）\n    lastPeopleIndex = (space+ lastPeopleIndex) % (total - totalLunshu + 1)\n    totalLunshu -=1\n  }\n  return lastPeopleIndex\n}\n```\n\n### 合并两个排序的链表\n\n#### 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。\n\n> 核心在于比较两个表头，把比较小的值塞进一个链表中，然后大的值继续与小的值的链表继续比较\n\n1. 假设有 p1 和 p2 两个链表, 比较 p1 和 p2 的值。\n2. 如果 p1 小于 p2，那么把 p1 的值保存起来，然后 p1 的下一个值继续与 p2 进行比较\n3. 如果 p1 大于 p2，那么把 p2 的值保存起来，然后 p2 的下一个值继续与 p1 进行比较\n\n```ts\n/**\n * 合并两个单调递增的链表\n * @param first\n * @param second\n */\nfunction sortTwoList(p1: List, p2: List): List {\n  if (!p1) return p2;\n  if (!p2) return p1;\n  let head;\n  if (p1.val < p2.val) {\n    head = p1;\n    head.next = sortTwoList(p1.next, p2);\n  } else if (p1.val > p2.val) {\n    head = p2;\n    head.next = sortTwoList(p1, p2.next);\n  } else {\n    head = p1;\n    head.next = sortTwoList(p1.next, p2.next);\n  }\n  return head;\n}\n```\n\n\n\n', 1, 'algorithm', '数据结构与相应的算法题2(链表篇)', 1, '2020-03-18 18:31:12', '2020-03-18 18:31:12', '2020-03-18 18:32:32', 'http://img.carrotwu.com/FnFfNrtqMVJu3_JSUTMJNmnIZhMC', NULL);
INSERT INTO `article` VALUES (26, '学习算法第二弹之学习数据结构算法链表(慢慢更)', 11, '> 本文是在[**ConardLi 的【前端该如何准备数据结构和算法？】总结而来**](https://juejin.im/post/5d5b307b5188253da24d3cd1 \"Markdown\"),代码实现上是我自己使用 ts 编写，题目均是跟着上文编写。\n\n## 数据结构\n\n### 什么是数据结构\n\n数据结构是在计算机中组织和存储数据的一种特殊方式，使得数据可以高效地被访问和修改。更确切地说，数据结构是数据值的集合，表示数据之间的关系，也包括了作用在数据上的函数或操作\n\n### 常见的数据结构\n\n1. 数组：Array\n2. 堆栈：Stack\n3. 队列：Queue\n4. 链表：Linked Lists\n5. 树：Trees\n6. 图：Graphs\n7. 字典树：Trie\n8. 散列表（哈希表）：Hash Tables\n\n## 链表\n链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。下图展 示了一个链表的结构。\n相对于传统的数组，链表的一个好处在于，添加或移除元素的时候不需要移动其他元素。然而，链表需要使用指针，因此实现链表时需要额外注意。在数组中，我们可以直接访问任何位置 的任何元素，而要想访问链表中间的一个元素，则需要从起点（表头）开始迭代链表直到找到所需的元素。  \n\n![alt](http://img.carrotwu.com/Fs-JoZqQn23hhaLKRdrZEENMsxYN) \n\n在react fiber和react hooks中用到的大量的链表结构，其中fiber node是一条双向链表（通过child指向子节点，sibling指向兄弟节点，通过return返回父节点）。react hooks是单向链表，hooks内部的update对象queue则是单向循环链表。\n\n### 从尾到头打印链表\n#### 输入一个链表，按链表值从尾到头的顺序返回一个ArrayList\n>通过递归.next获取下一个链表，直到.next为null\n\n```ts\ninterface List {\n  next: List | null,\n  val: string\n}\n\n/**\n * 从尾部到头部打印链表\n * @param {List} list\n * @returns {string[]}\n */\nfunction printList(list: List) {\n  const array = []\n  while (list) {\n    array.unshift(list.val)\n    list = list.next\n  }\n  return array\n}\n```\n\n### 反转链表\n#### 输入一个链表，反转链表后，输出新链表的表头。\n\n1. 每一次循环的本质就是一直保留头部第一个链表head（这里是a1）,每次循环的时候把第二个之后的链表拿出来currentNode (这里是a2-n)拿出来,之后把头部head（a1）链表执向a2-n的下一个即a3-n所以头部链表head就变成了(a1.next => a3-n)。这时候注意因为一开始headNode跟head的引用是相同的所以这时候headNode也是(a1.next => a3-n)。最后把currentNode.next执向headNode所以就变成了(a2.next=>a1.next => a3-n)\n2. head == a1.next =>a3.next.... currentNode === headNode === a2.next => a1.next => a3.next...\n3. 从上面可以看出headNode跟head之间是有引用关系的即(headNode.next === head),两者引用是相同的。所以修改head的引用值也会改变headNode.next的引用值\n2. 继续循环,注意下面两句\n\n```js\n  // 第三点 headNodg跟head的引用是有联系的\n  let headNode = head;\n  // 这里修改了head引用，所以headNode也会发生改变\n  // a1.next => a4.next =>a5\n  // 所以 headNode.next === a1.next => a4.next =>a5 最终就是 a3.next =>a2.next =>a1.next => a4.next =>a5\n  head.next = currentNode.next;\n  currentNode.next = headNode;\n\n```\n解答:   \n\n```ts\nfunction reverseList(head: List): List {\n  let headNode = head\n  let currentNode = null\n  while (head && head.next) {\n    // 获取第二个链表\n    currentNode = head.next\n    //head的下一个链表指向下下一个即第三个\n    head.next = currentNode.next\n    // 第二个链表指向头部链表\n    currentNode.next = headNode\n\n    headNode = currentNode\n  }\n  return headNode\n}\n```\n\n#### 输入一个链表，输出该链表中倒数第k个结点。\n>如果先循环出链表的所有长度在进行求值的话，需要循环两次复杂度为2n。可以使用双指针进行优化\n1. 初始指针a,第二个指针b与指针a间隔为k\n2. 这时候两个指针都进行循环，如果b指针到达终点了，那么a指针当前位置就是倒数第k个节点位置\n\n```ts\n * 获取倒数第n个节点的链表\n * @param {List} list\n * @param {number} k\n * @returns {string | null}\n */\nfunction getLastListVal(list: List, k: number): string | null {\n  if (Number(k) > 0) {\n    let slow = list\n    let fast = list\n    let index = 1\n    while (fast && fast.next) {\n      fast = fast.next\n      if (index >= k) {\n        slow = slow.next\n      }\n      index++\n    }\n    return index < k ? null : slow.val\n  } else {\n    return null\n  }\n}\n```\n\n### 链表中环的入口节点（查找链表是否有环）\n#### 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。\n>问题可以拆分成两部分1如果判断链表是否有环，第二个如何查找环的起点。\n1. 如何判断链表是否有环：我们只需要两个指针，一个走一步，一个走两步，只要指针有相遇的话那么就是有环。（假设链表没有环的话，那么因为快指针走的越来越远那么两个指针永远不可能相遇。如果链表有环，假设快慢指针都在环里面，如果以慢指针作为参考物，那么快指针每次走一步，如果有环的话，那么两个指针最终一定会相遇）\n2. 如何判断环的起点。首先我们假设有两个指针都在环的起点，如果让某一个指针先走环的长度K，那么该指针还是会回到环的起点与另一个指针相遇。这时候快的指针相对于慢的指针其实是先走了K步，这时候快的指针相对于慢的指针先走了环的长度k步。我们再把两个指针平移同样的步数直到慢的起点。所以最终判断环的起点问题可以转化为：两个指针a,b。a在起点，b先走环的长度，如果a和b相遇了那么当前位置就是环的起点入口。\n3. 环的长度可以通过在环内的一点每次走一步又走到当前点的话，那么走的步数就是环的长度。\n\n```ts\nfunction getListStart(list: List): List | null {\n  // 首先判断链表是否有环\n  // 慢的先走1步\n  let slow = list.next\n  // 快的先走两步\n  let fast = list.next.next\n\n  // 初始化环的长度\n  let squareLength = 0\n  while(fast !== slow) {\n    if(fast && fast.next){\n      fast = fast.next.next\n      slow = slow.next\n    }else {\n      // 快指针已经到终点了还没遇到那么久没有环\n      return null\n    }\n  }\n  \n  // 有环 这里需要拿环的长度 此时 fast和slow必定在环内\n  slow = slow.next\n  squareLength +=1\n  while(slow !== fast) {\n    slow = slow.next\n    squareLength +=1\n  }\n  // 都回到原点\n  slow = list\n  fast = list\n  // 快指针先走环的长度步数\n  for(let i =1; i <= squareLength; i++){\n    fast = fast.next\n  }\n  //获取环的起点\n  while(slow !== fast) {\n    slow = slow.next\n    fast = fast.next\n  }\n  return slow\n}\n```\n\n### 两个链表的第一个公共节点\n#### 输入两个链表，找出它们的第一个公共结点。\n>假设两个公共链表有公共节点，那么从这节点开始后续的元素位置相同并且长度必须相等合并成一条线，所以我们两条链表的尾部对齐，长一点的链表pass掉差异的长度，然后依次比较是否相等即可。\n1. 通过循环获取链表的长度。\n2. 获取长的链表先走长度的差异值步\n3. 同时循环查找是否有相等的节点，有的话就是公共节点\n\n```ts\nfunction getFirstCommonNode(a: List, b: List): List | null {\n  if (!a || !b) {\n    return null;\n  }\n\n  //获取链表长度\n  function getListLength(list: List) {\n    let listLength = 0;\n    while (list) {\n      listLength += 1;\n      list = list.next;\n    }\n    return listLength;\n  }\n  const aLength = getListLength(a);\n  const bLength = getListLength(b);\n\n  let long = aLength > bLength ? a : b;\n  let short = aLength > bLength ? b : a;\n\n  // 长的链表跳过长度差异\n  for (let i = 0; i < Math.abs(aLength - bLength); i++) {\n    long = long.next;\n  }\n\n  while (short && long) {\n    if (short === long) {\n      return short;\n    }\n    short = short.next;\n    long = long.next;\n  }\n  return null;\n}\n```\n\n### 约瑟夫环\n#### 0,1,...,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。\n>约瑟夫环总共有三种做法：1通过链表循环删除对应的节点，2通过数组取值使用索引，3通过递归。\n1. 使用链表，我们只需要把元素组装成一个链表，然后通过循环没过m个节点删除元素即可，直到只剩下一个元素\n2. 通过描述我们可以得出一条规律：从当前某个元素开始数，下一个被删除的数字等于m除以总人数的余数，假设第1次删除的数字是：第一个数字0开始数起的第m个数。举个例子：假设m是2，总人数是10,那么第(2 % 10) = 2第二个数字要被删除。对应索引的话就得到删除的索引Index = ((m)% n) -1。我们可以通过数组去循环即可。\n3. d动态规划: \n 1. 第一轮的时候第一个被删除索引是(m-1)%n。所以第二轮的开始（0）位置索引就是m%n,所以推导出第二轮第k个位置在第1轮的索引就是(m+k)%n。\n 2. 假设在第n轮时候的某个人位置是f(n)，那么第n-1轮的时候位置其实就是f(n-1) = (m+f(n))%n。即第7轮某个人位置是2 那么第6轮他的位置就是(m+ 2)%n, 那么第五轮他的位置就是(m + ((m+ 2)%n))%n。\n 3. 现在我们知道8个人时，最后一轮就是第七轮因为每一轮走一个人此时剩下的人索引就是0，所以上一轮他的位置就是(m+2)%8,因此我们可以一直循环上去直到第一轮就是他获取的位置。\n\n```ts\n//链表解决\nfunction getRemainPeopleIndexByList(total: number, space: number): number{\n  interface List {\n    next?: List ;\n    val: number;\n  }\n  const head:List = {val : 0}\n  let current: List = head\n  for(let i=1; i<total; i++){\n    current.next = {val: i}\n    current = current.next\n  }\n  current.next = head\n  while (current.next != current) {\n    for (let i = 0; i < m - 1; i++) {\n      current = current.next;\n    }\n    current.next = current.next.next;\n  }\n  return current.val;\n}\n\n// 数组\nfunction getRemainPeopleIndexByArray(total: number, space: number): number{\n  if (total < 1 || space < 1) {\n    return -1;\n  }\n  const array = [];\n  let index = 0;\n  for (let i = 0; i < total; i++) {\n    array[i] = i;\n  }\n  while (array.length > 1) {\n    index = (index + space) % array.length - 1;\n    if (index >= 0) {\n      array.splice(index, 1);\n    } else {\n      array.splice(array.length - 1, 1);\n      index = 0;\n    }\n  }\n  return array[0];\n}\n\n//动态规划\nfunction getRemainPeopleIndex(total: number, space: number): number {\n  // 总共要进行的轮数才剩一人\n  let totalLunshu = total - 1\n  // 最后第totalLunshu轮时胜利人的索引是0\n  let lastPeopleIndex = 0\n  // 1. 第一轮的时候第一个被删除索引是(m-1)%n。所以第二轮的开始（0）位置索引就是m%n,所以推导出第二轮第k个位置在第1轮的索引就是(m+k)%n。\n  // 2. 假设在第n轮时候的某个人位置是f(n)，那么第n-1轮的时候位置其实就是f(n-1) = (m+f(n))%(total - n)。即第7轮某个人位置是2 那么第6轮他的位置就是(m+ 2)%(total - 6), 那么第五轮他的位置就是(m + ((m+ 2)%n))%n。\n  // 3. 现在我们知道8个人时，最后一轮就是第七轮因为每一轮走一个人此时剩下的人索引就是0，所以上一轮他的位置就是(m+2)%8,因此我们可以一直循环上去直到第一轮就是他获取的位置。\n\n  // 一直循环到00位置 走totalLunshu轮\n  while(totalLunshu > 0){\n    //上一轮的索引 f(n-1) = f(n-1) = (m+f(n))%（每一轮的人数）\n    lastPeopleIndex = (space+ lastPeopleIndex) % (total - totalLunshu + 1)\n    totalLunshu -=1\n  }\n  return lastPeopleIndex\n}\n```\n\n### 合并两个排序的链表\n\n#### 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。\n\n> 核心在于比较两个表头，把比较小的值塞进一个链表中，然后大的值继续与小的值的链表继续比较\n\n1. 假设有 p1 和 p2 两个链表, 比较 p1 和 p2 的值。\n2. 如果 p1 小于 p2，那么把 p1 的值保存起来，然后 p1 的下一个值继续与 p2 进行比较\n3. 如果 p1 大于 p2，那么把 p2 的值保存起来，然后 p2 的下一个值继续与 p1 进行比较\n\n```ts\n/**\n * 合并两个单调递增的链表\n * @param first\n * @param second\n */\nfunction sortTwoList(p1: List, p2: List): List {\n  if (!p1) return p2;\n  if (!p2) return p1;\n  let head;\n  if (p1.val < p2.val) {\n    head = p1;\n    head.next = sortTwoList(p1.next, p2);\n  } else if (p1.val > p2.val) {\n    head = p2;\n    head.next = sortTwoList(p1, p2.next);\n  } else {\n    head = p1;\n    head.next = sortTwoList(p1.next, p2.next);\n  }\n  return head;\n}\n```\n\n\n\n', 1, 'algorithm', '数据结构与相应的算法题2(链表篇)', 1, '2020-03-18 18:32:14', '2020-04-28 14:30:41', NULL, 'http://img.carrotwu.com/FmdOlwdj5XD5BN0UiZgOSOVvr9yd', NULL);
INSERT INTO `article` VALUES (27, '学习算法第二弹之学习数据结构算法二叉树篇(慢慢更)', 17, '> 本文是在[**ConardLi 的【前端该如何准备数据结构和算法？】总结而来**](https://juejin.im/post/5d5b307b5188253da24d3cd1 \"Markdown\"),代码实现上是我自己使用 ts 编写，题目均是跟着上文编写。\n\n## 数据结构\n\n### 什么是数据结构\n\n数据结构是在计算机中组织和存储数据的一种特殊方式，使得数据可以高效地被访问和修改。更确切地说，数据结构是数据值的集合，表示数据之间的关系，也包括了作用在数据上的函数或操作\n\n### 常见的数据结构\n\n1. 数组：Array\n2. 堆栈：Stack\n3. 队列：Queue\n4. 链表：Linked Lists\n5. 树：Trees\n6. 图：Graphs\n7. 字典树：Trie\n8. 散列表（哈希表）：Hash Tables\n\n## 二叉树\n\n### 树\n\n树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个 节点）以及零个或多个子节点,在前端中最常见的树形结构就是 html 的 dom 节点，从 html 节点开始到最深层次的 div 节点就是一个典型的树形结构。\n\n### 二叉树\n\n二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。这个定义有助于我们写出更高效地在树中插入、查找和删除节点的算法。\n\n和链表一样，我们将通过指针（引用）来表示节点之间的关系（树相关的术语称其为边）。 在双向链表中，每个节点包含两个指针，一个指向下一个节点，另一个指向上一个节点。对于树， 使用同样的方式（也使用两个指针），但是一个指向左侧子节点，另一个指向右侧子节点。因此， 将声明一个 Node 类来表示树中的每个节点。值得注意的一个小细节是，不同于在之前的章节中 将节点本身称作节点或项，我们将会称其为键。键是树相关的术语中对节点的称呼。\n![alt](http://img.carrotwu.com/FkW6s-Pgp-ejwKzYZf44k9JxGEop)\n\n### 二叉树的基本操作\n\n### 二叉树的遍历（中序遍历，先序遍历，后序遍历）\n\n1. 中序遍历是一种以上行顺序访问二叉树所有节点的遍历方式，也就是以从最小到最大的顺序访问所有节点,中序遍历的一种应用就是对树进行排序操作。可以理解为，左=>自身=>右。分为递归和循环两个版本\n2. 递归的版本很好理解，主要是循环的方式\n3. 循环的话，创建一个栈。循环左键进栈，直到为空。\n4. 这时候取出栈的最后一个节点（最开始其实就是最小的键），保存值。\n5. 这时候以右键作为目标节点，继续上述的步奏（这时候.right 为空， 会跳过左节点入栈的 2 步奏，取出来的下一个就是最小键的父键）\n\n```ts\n//中序遍历\n// 递归\nfunction inorderTraversal(root: TreeNode): number[] {\n  let arr: number[] = [];\n  function traversersal(node: TreeNode) {\n    if (node) {\n      // 先打印node.left\n      traversersal(node.left);\n      // 在打印当前node\n      arr.push(node.val);\n      // 最后打印node.right\n      traversersal(node.right);\n    }\n  }\n  traversersal(root);\n  return arr;\n}\n// 循环解法\nfunction inorderTraversal2(node: TreeNode): number[] {\n  const result = [];\n  const stack = [];\n  let current = node;\n  while (current && stack.length) {\n    while (current) {\n      // 左键入栈\n      stack.push(current);\n      current = current.left;\n    }\n    // 取出最后一个保存值\n    current = stack.pop();\n    result.push(current.val);\n    //取右键继续循环\n    current = current.right;\n  }\n  return result;\n}\n```\n![alt](http://img.carrotwu.com/FtIh6zC7WbtKm7GqBnUJcQXzCADw)\n\n2. 先序遍历是以优先于后代节点的顺序访问每个节点的。先序遍历的一种应用是打印一个结构化的文档，可以理解为自身=>左=>右，也分为递归和循环版本。\n   1. 递归的版本很好理解，主要是循环的方式.\n   2. 先序的循环解法跟中序基本一样，区别在于，循环左键进栈的时候就需要把当前节点值保存起来了\n\n```ts\n// 先序遍历\nfunction preorderTraversal(root: TreeNode): number[] {\n  let arr: number[] = [];\n  function traversersal(node: TreeNode) {\n    if (node) {\n      // 先保存自身的值\n      arr.push(node.val);\n      // 在报错left\n      traversersal(node.left);\n      // 最后保存node.right\n      traversersal(node.right);\n    }\n  }\n  traversersal(root);\n  return arr;\n}\n//循环\nfunction preorderTraversal2(root: TreeNode): number[] {\n  const result: number[] = [];\n  const stack: TreeNode[] = [];\n  let current = root;\n  while (current || stack.length) {\n    while (current) {\n      stack.push(current);\n      result.push(current.val);\n      current = current.left;\n    }\n    current = stack.pop();\n    current = current.right;\n  }\n  return result;\n}\n```\n![alt](http://img.carrotwu.com/Fpd1_oTf6EkOu91L2AN8PjxOi4vK)\n\n3. 后序遍历则是先访问节点的后代节点，再访问节点本身。后序遍历的一种应用是计算一个目录及其子目录中所有文件所占空间的大小。可以理解为左=>右=>自身.\n1. 递归的版本很好理解，主要是循环的方式.\n1. 先序的循环解法跟中序有点类似，区别在于访问完左键了这时候要先访问右键才能出栈。父键的出栈时机是 k.right 已经被访问了，这样子我们可以存储一个变量用于保存被访问的键\n\n```ts\n// 后续遍历\nfunction lastorderTraversal(root: TreeNode): number[] {\n  let arr: number[] = [];\n  function traversersal(node: TreeNode) {\n    if (node) {\n      traversersal(node.left);\n      traversersal(node.right);\n      arr.push(node.val);\n    }\n  }\n  traversersal(root);\n  return arr;\n}\n\n//循环\nfunction lastorderTraversal2(root: TreeNode): number[] {\n  const result: number[] = [];\n  const stack: TreeNode[] = [];\n  // 保留一个变量作为最后的访问点\n  let last = null;\n  let current = root;\n  while (current || stack.length) {\n    while (current) {\n      stack.push(current);\n      // 可以出栈\n      current = current.left;\n    }\n    // 获取当前最末尾的栈\n    current = stack[stack.length - 1];\n    if (!current.right || current.right === last) {\n      // 没有子健 或者 子健的right已经访问过了 那么可以出栈保存值\n      current = stack.pop();\n      result.push(current.val);\n      // 最后访问点更新\n      last = current;\n      current = null;\n    } else {\n      // 右键还没访问 不允许出栈 先访问右边的键\n      current = current.right;\n    }\n  }\n  return result;\n}\n```\n\n![alt](http://img.carrotwu.com/FvwomIVTwOhUYwV1-2614fUdmV7M)\n\n### 二叉树的最大深度以及最小深度\n\n> 最大深度很好理解，递归就可以了，但是最小深度的话有可能出现左键右键为空的情况，就不用进行比较了\n\n```ts\n// 获取最大深度\nfunction getMaxDepth(node: TreeNode): number {\n  if (!node) return 0;\n  return Math.max(getMaxDepth(node.left), getMaxDepth(node.right) + 1);\n}\n\n// 获取最小深度\nfunction getMinDepth(node: TreeNode): number {\n  if (!node) return 0;\n  // 只有双键存在才能比较\n  if (node.left && node.right) {\n    return Math.min(getMaxDepth(node.left), getMaxDepth(node.right) + 1);\n  } else if (node.left) {\n    // 右键为空 那么不用比较右键了\n    return 1 + getMinDepth(node.left);\n  } else if (node.right) {\n    // 左键为空 那么不用比较左键了\n    return 1 + getMinDepth(node.right);\n  } else {\n    // 当前节点就是叶子节点\n    return 1;\n  }\n}\n```\n\n### 判断是否对称二叉树\n\n> 对称二叉树指的是两颗二叉树根结点相同，但他们的左右两个子节点交换了位置。\n\n1. 核心就是递归判断两个键(node1, node2)是否相等，如果有一个为 null 或者值不相等那么就不是.\n2. 这时候需要判断(node1, node2)的子健是否相等，比对条件是**node1.left 比对 node2.right node1.right 比对 node2.left**\n3. 2 的方法继续进行继续递归\n\n```ts\n// 判断是否对称二叉树\nfunction isSymmetrical(node: TreeNode): boolean {\n  if (!node) return true;\n  function checkIsSymmetrical(\n    node1: TreeNode | null,\n    node2: TreeNode | null\n  ): boolean {\n    if (!node1 && !node2) {\n      // 都为空\n      return true;\n    }\n    if (!node1 || !node2) {\n      // 一个为空\n      return false;\n    }\n    if (node1.val !== node2.val) {\n      return false;\n    }\n    // 比对子健 这时候是 node1.left 比对node2.right  node1.right比对node2.left\n    return (\n      checkIsSymmetrical(node1.left, node2.right) &&\n      checkIsSymmetrical(node1.right, node2.left)\n    );\n  }\n\n  return checkIsSymmetrical(node.left, node.right);\n}\n```\n\n### 二叉树的镜像\n\n#### 操作给定的二叉树，将其变换为源二叉树的镜像。\n\n> 其实很上面的判断是否对称二叉树差不多，就是从上到下替换两个键的引用\n\n```js\n       源二叉树\n    	    8\n    	   /  \\\n    	  6   10\n    	 / \\  / \\\n    	5  7 9 11\n    	镜像二叉树\n    	    8\n    	   /  \\\n    	  10   6\n    	 / \\  / \\\n    	11 9 7  5\n```\n\n#### 解答\n\n```ts\nfunction mirrorNode(root: TreeNode): TreeNode {\n  if (root) {\n    const temp = root.left;\n    root.left = root.right;\n    root.right = temp;\n    // 递归\n    mirrorNode(root.left);\n    mirrorNode(root.right);\n  }\n  return root;\n}\n```\n\n### 二叉树的第 k 小的节点\n\n> 给定一棵二叉搜索树，请找出其中的第 k 小的结点。 例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为 4。\n\n1. 从上面得出的是，中序遍历得出的是从小到达的值，然后加上索引即可求出\n\n```ts\n//获取第k小的值\nfunction KthNode(root:TreeNode, k:number){\n	if(!root) return null\n	const result = []\n	const stack = []\n	let current = root\n	while(current || stack.length){\n		while(current){\n			stack.push(current)\n			current = current.left\n		}\n\n		current = stack.pop()\n		result.push(current.val)\n		current = current.right\n	}\n	return k-1 > result.length ? null : result[k-1] \n}\n```\n\n### 获取二叉树所有的路径\n\n> 其实跟之前做的获取 dom 节点的所有树形结构相类似，通过第二个参数进行维护父级的树形结构，不需要额外的一个数组来保存栈结构\n\n```ts\nvar binaryTreePaths = function(root) {\n  const result = [];\n  function getTreePaths(node, parentPath) {\n    if (!node) return;\n    const currentPath = parentPath\n      ? `${parentPath}->${node.val}`\n      : String(node.val);\n    if (!node.left && !node.right) {\n      result.push(currentPath);\n    }\n    getTreePaths(node.left, currentPath);\n    getTreePaths(node.right, currentPath);\n  }\n  getTreePaths(root);\n  return result;\n};\n```\n\n### 二叉树中和为某一值的路径\n\n#### 输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。\n\n> 跟上面的获取所有路径有点相似，理论上也可以通过传入第二个参数的形式保存调用栈，但是这次我们通过保存调用栈的形式来做\n\n1. 数组 result 来存储所有符合条件的路径，栈 stack 来存储当前路径中的节点，sum 来标识当前路径之和。\n2. 记住的是 stack 的站路径和 sum 必须在每次执行完之后回溯\n\n```ts\n// 获取值为sum的二叉树路径\nfunction findPath(root: TreeNode, sum: number): number[][] {\n  const result: number[][] = [];\n  let toal = 0;\n  const stack: number[] = [];\n\n  function getPath(node: TreeNode) {\n    if (!node) return;\n    toal += node.val;\n    stack.push(node.val);\n    if (!node.left && !node.right) {\n      // 叶子节点了\n      if (sum === toal) {\n        result.push(stack.slice());\n      }\n    }\n\n    getPath(node.left);\n    getPath(node.right);\n    // 执行完成出栈以及减值\n    stack.pop();\n    toal -= node.val;\n  }\n  getPath(root);\n  return result;\n}\n```\n\n### 验证二叉搜索树\n\n#### 给定一个二叉树，判断其是否是一个有效的二叉搜索树。\n\n> 其实简单一点的方法就是用中序遍历,我们知道的是中序遍历会返回一个从小到大的数组，判断当前值是否大于上一个值即可。\n\n```ts\n// 判断是否合法的二叉树\nfunction isValidBST(root: TreeNode): boolean {\n  if (!root) return false;\n  // 不用数组存 而是通过保存上一次的值会更快一点点\n  const result = [];\n  const stack = [];\n  let current = root;\n  while (current || stack.length) {\n    while (current) {\n      stack.push(current);\n      current = current.left;\n    }\n\n    current = stack.pop();\n    if (current.val <= result[result.length - 1]) {\n      // 小于等于值 直接返回false\n      return false;\n    }\n    result.push(current.val);\n    current = current.right;\n  }\n  return true;\n}\n```\n\n\n\n', 1, 'algorithm', '数据结构与相应的算法题3(二叉树篇)', 1, '2020-03-18 18:45:33', '2020-09-16 19:19:59', NULL, 'http://img.carrotwu.com/FmdOlwdj5XD5BN0UiZgOSOVvr9yd', NULL);
INSERT INTO `article` VALUES (28, '这段时间在用 ts + node 开发一个属于我自己的命令行工具 wcli。这个工具集成了插件化的模式，允许通过安装插件对项目进行开发模式化的编辑，以及自动化的构建并且代码推送。这篇文章是对编写 wcli 过程中的总结以及一些心得', 13, '> 这段时间在用 ts + node 开发一个属于我自己的命令行工具 wcli。这个工具集成了插件化的模式，允许通过安装插件对项目进行开发模式化的编辑，以及自动化的构建并且代码推送。这篇文章是对编写 wcli 过程中的总结以及一些心得。\n\n![alt](http://img.carrotwu.com/FjmnlcoUe9m5M9XEh2eTeJHzmdRF)\n\n## 为什么要开发这么一个命令行\n\n1. 第一点就是。现在公司的项目虽然做到了自动化的部署，但是这个并没有做到自动化的构建。公司的上线流程依然是本地手动构建把打包好的文件手动推送到某个仓库，然后通过 jenkins 手动触发拉取静态文件生成镜像。后续通过 k8s 或者 swam 的形式部署到各台机器上。\n   现在业界更流行的自动化构建部署方案应该是直接推送代码，通过 web hooks 的触发或者容器镜像服务拉取文件然后在服务器上自动进行构建然后再触发自动部署（我的博客就是这么做的，包括前后台）。\n   但是没办法，每次手动构建需要选择各种环境，然后还要复制删除代码。一不小心就很容易打错生产环境变量的包，所以我想着通过命令行的方式来把这些工作交给机器，用户进行选择就好了。\n   简单一点的话，其实在项目 package.json 添加一个 bin 属性引入相关的 node.js 代码即可进行。不过如果新增一个项目我就要引入相应的 node.js 代码实在是太麻烦了，所以最终还是决定通过编写一个全局命令行的包类似于 vue-cli 这样子的脚手架工具。\n\n2. 第二点就是因为公司项目太老的关系，打包所有的路由等待时间实在是太久了，所以通过命令行的方式选择当前需要开发的路由减小路由的引入。这样子能够极大地减小开发效率，我司的一个项目原先每次热刷新要将近两分钟，通过 dev 的形式修改路由每次热刷新减小到 2s。\n\n3. 写这么一个脚手架的另外一个好处就是，脚手架支持通过 git 或者 npm 的方式下载相应的插件，完全可以把所有的开发或者发布逻辑解耦到插件中，对于普通开发人员完全不会有任何心肌负担，只需要下载脚手架安装相应的项目插件即可。插件的开发可以交给项目特定人员。相比于在项目编写 bin 命令行把逻辑放入项目中，wcli 脚手架能无侵入式开发。\n\n## 一些用到的库\n\n接下来将列举一些脚手架开发过程中用到的库。\n\n1. [**commander**](https://github.com/tj/commander.js): node.js 命令行界面的完整解决方案。允许你使用 node.js 快速方便的编写命令行工具。\n2. [**colors**](https://github.com/Marak/colors.js): colors.js 是 NodeJS 终端着色 colors 插件能够美化终端打印出来的信息。\n3. [**enquirer**](https://github.com/enquirer/enquirer): 一个可嵌入式的美观的命令行界面，交互式命令行工具。\n4. [**compressing**](https://www.npmjs.com/package/compressing): 一个能够在 node 环境上进行压缩和解压缩的库，我主要是用来解压`npm pack`时下载的 tgz 文件\n5. [**download-git-repo**](https://www.npmjs.com/package/download-git-repo): 一个下载 github 或者 gitlab 远程仓库的库。\n6. [**simple-git**](https://www.npmjs.com/package/simple-git): 一个支持在 node 环境上支持使用 git 命令的库。\n7. [**fs-extra**](https://www.npmjs.com/package/fs-extra): 对于 node 原生的 fs 进行了封装，类似于 jq 的作用。\n\n在 wcli 中暂时提供了三个命令**publish plugin dev**\n\n## wcli publish\n\n顾名思义，publish 就是允许你通过提前配置好一些项目配置，只需要你执行一条命令。那么插件会按照你与写的逻辑进行打包然后对打包的代码进行推送到你制定的仓库。当然你也可以通过一些交互选择打包的变量以及输入 commit 的 message 做到自定义的打包推送。\n只需在 wcliconfig.json 文件夹中对 publish 变量进行一些相关的配置即可。\n\n```ts\nexport interface PublishConfig {\n  // git地址\n  git: string;\n  // 仓库名\n  repository: string;\n  // 分支\n  branch: string;\n  // 替换的文件路径\n  target: string;\n  // 静态资源地址 默认是\'dist\'\n  dist?: string;\n  // 提交时的本地仓库路径 github的话必须提供 gitlab可以不用\n  publishGitDir?: string;\n}\n```\n\n调用这条命令的过程中，wcli 会查找插件首页的 publish.js 并且进行执行。同时 wcli 提供了通用的上传仓库方法（当然你可以自己写），所以你可以先处理打包后的逻辑在执行相应提供的**publishFilwTithGit**方法即可快速的实现构建提交的逻辑。\n\n![alt](http://img.carrotwu.com/FnmihSOW7a8cC4j96LzeajTYC74t)\n\n```js\n// publish.js\nmodule.exports = async function(context) {\n  const {\n    config: {\n      wcliConfigJson,\n      isDebug: debug,\n      token: publishToken,\n      publishCommitMsg\n    },\n    utils: {\n      getCurrentBinFilePath,\n      publishFileWithGitlabCommit,\n      publishFileWithGit\n    }\n  } = context;\n\n  // 处理打包的逻辑 通过交互进行环境的选择 生成了静态文件之后\n  // 调用提供的publishFileWithGit方法即可进行推送\n  const publishParams = {\n    publishConfig: wcliConfigJson.publish,\n    commitMsg: publishCommitMsg,\n    token: publishToken\n  };\n  publishFileWithGit(publishParams);\n};\n```\n\n## wcli plugin\n\n### wcli plugin install\n\n安装插件的操作，目前支持通过 npm 包的形式或者通过 github 或者 gitlab 的地址进行下载\n\n1. 对于 git 地址的形式，wcli 会直接通过`download-git-repo`直接把库下载到目录的 plugin 目录下。\n2. 对于 npm 包的话。最开始想着通过 node_modules 的形式管理插件，但是因为一些原因还是没有选择，通过`npm pack xxx`的形式直接把项目源码下下来之后进行解压缩放进 plugin 目录下。\n3. 对于下下来的插件会自动进行 install（默认使用 yarn）\n\n### wcli plugin list\n\n通过表格显示安装的插件列表，包含插件名，是否 npm，插件的本地目录地址以及插件版本。\n\n![alt](http://img.carrotwu.com/Fu4G3Yl1z_3gsoK0GaoSW5HIxFX1)\n\n### wcli plugin remove\n\n可以删除插件,默认没有指定插件的话会删除 plugin 下所有目录，指定插件的话会删除指定的插件\n\n### wcli plugin upgrade\n\n**待开发中**，通过插件的版本号来判断是否需要更新，暂时还没开发。\n\n## wcli dev\n\n跟`wcli plugin`挺像，也是通过一些命令行的配置参数，比如说获取当前开发的路由，当前开发的调试环境以及代理地址等等你想自定义的事情，最后可以手动启动一个 devServer 方便开发（本质上还是通过项目 package.json 文件中的 script 命令进行执行）\n\n', 1, 'nodeJs,typescript', 'wcli-一个支持自定义打包部署开发的全局命令行工具', 1, '2020-03-22 12:13:57', '2020-04-21 21:22:25', '2020-04-21 21:22:37', 'http://img.carrotwu.com/Fljiy_5XGEakMCr9xTc7hzI9MPN3', NULL);
INSERT INTO `article` VALUES (29, '浅入浅出web安全XSS和CSRF', 5, '# XSS\n\n## 什么是xss\nCross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。\n> XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。\n\n## xss的分类\n根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种。\n\n### 存储型 XSS\n1. 攻击者将恶意代码提交到目标网站的数据库中。\n2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。\n3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。\n4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\n\n这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等\n\n### 反射性Xss\n1. 攻击者构造出特殊的 URL，其中包含恶意代码。\n2. 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。\n3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。\n4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\n\n### DOM 型 XSS\n1. 攻击者构造出特殊的 URL，其中包含恶意代码。\n2. 用户打开带有恶意代码的 URL。\n3. 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。\n4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\n\n### 总结\n简单说就是，存储型是通过输入（评论，私信）等形式把恶意代码保存在服务端，反射性和dom型是通过拼接恶意代码到url上进行攻击。\n\n## xss的预防\n从上面可以得到的是xss的攻击需要两个步骤：\n1. 攻击者提交恶意代码。\n2. 浏览器执行恶意代码。\n\n### 输入过滤\n首先确认的是服务端需要对客户端提交的数据进行转义，客户端对输入转义并没有用因为可以直接伪造请求。客户端能做的是，对服务端的内容做转义然后进行执行,同时对html进行转义。\n\n### Content Security Policy\n严格的 CSP 在 XSS 的防范中可以起到以下的作用：\n\n1. 禁止加载外域代码，防止复杂的攻击逻辑。\n2. 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。\n3. 禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。\n4. 禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。\n5. 合理使用上报可以及时发现 XSS，利于尽快修复问题。\n\n### 输入内容长度控制\n对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度\n\n### 对于一些敏感的内容以及操作做一些额外的安全处理\n1. HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。\n2. 验证码：防止脚本冒充用户提交危险操作。\n\n# CSRF\n\n## 什么是CSRF\nCSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。\n一个典型的CSRF攻击有着如下的流程：\n\n1. 受害者登录a.com，并保留了登录凭证（Cookie）。\n2. 攻击者引诱受害者访问了b.com。\n3. b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会…\n4. a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。\n5. a.com以受害者的名义执行了act=xx。\n6. 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。\n\n###  CSRF的特点\n攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。\n攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。\n整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。\n跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。\n\n简单说就是XSS是通过注入恶意代码的形式执行一些代码，可以做任何操作，是在受害者的网站上进行。CSRF是在第三方网站，通过已经验证过的信息（只能使用，并不能获取）进行冒充请求。\n\n## 防护策略\nCSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性。\n上文中讲了CSRF的两个特点：\n\n1. CSRF（通常）发生在第三方域名。\n2. CSRF攻击者不能获取到Cookie等信息，只是使用。\n\n针对这两点，我们可以专门制定防护策略，如下：\n\n1. 阻止不明外域的访问\n 1. 同源检测 （通过refer禁止外域的请求，不靠谱，因为客户端可以伪造请求头）\n 2. Samesite Cookie（敏感信息登录凭证，禁止不明域的访问）\n\n\n2. 提交时要求附加本域才能获取的信息（因为CSRF不能获取本域的信息，所以可以再请求上添加只有本域才可以获取的信息比如token）\n  1. CSRF Token\n  2. 双重Cookie验证\n\n\n### 同源检测\n在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：\n1. Origin Header\n2. Referer Header\n我们可以通过拒绝一些不是本域的域名进行拒绝请求，但是很重的一个问题是：**请求头是可以伪造的，所以对于被伪造的请求头并没有什么用**\n\n### SameSite: cookie\n防止CSRF攻击的办法已经有上面的预防措施。为了从源头上解决这个问题，Google起草了一份草案来改进HTTP协议，那就是为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax，下面分别讲解：\n\n#### SameSite=strict\n只能允许页面域名一模一样的情况下才能使用cookie，其他第三方都不能使用。连子域都不支持，只能域名一模一样的。\n\n#### Samesite=Lax\n可以设置一些域名带上cookie，默认的页面跳转也可以带上cookie，相比strict会送一些，但是post提交的表单还是不行。\n\n### CSRF Token\n前面讲到CSRF的另一个特征是，攻击者无法直接窃取到用户的信息（Cookie，Header，网站内容等），仅仅是冒用Cookie中的信息。\n\n而CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，也可以防范CSRF的攻击。\n\n一些常见的例子是token，验证码，以及密码操作。\n\n#### 原理\nCSRF Token的防护策略分为三个步骤：\n\n1. 将CSRF Token输出到页面中(可以是接口返回，也可是验证码也可以是用户的密码)\n2. 页面提交的请求携带这个Token\n3. 服务器验证Token是否正确\n', 0, 'javascript', '浅析XSS与CSRF', 1, '2020-01-15 18:36:28', '2020-07-24 11:27:34', NULL, 'http://img.carrotwu.com/FtfW9mBPe7KePcNywsxLRNy7-0GM', NULL);
INSERT INTO `article` VALUES (30, '这篇文章的源码版本为16.13.1版本,在阅读这篇文章前，请确保已经阅读了源码解析的第一篇，不然怕是你很难看懂= =。', 55, '>这篇文章的源码版本为16.13.1版本,在阅读这篇文章前，请确保已经阅读了源码解析的第一篇，不然怕是你很难看懂= =。\n\n## hooks的两种调用阶段mount和update\n> hooks的源码是放在https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberHooks.js这里\n\n从源码可以看出，react把所有的hooks分成了两个阶段的hooks\n1. mount阶段对应第一次渲染初始化时候调用的hooks方法,分别对应了`mountMemo`,`mountCallback`,`mountRef`,`以及其他hooks。\n2. update阶段对应setXXX函数触发更新重新渲染的更新阶段,分别对应了`updateMemo`,`updateCallback`,`updateRef`, `updateLayoutEffect`以及其他hooks\n\n```ts\n// react-reconciler/src/ReactFiberHooks.js\n// Mount 阶段Hooks的定义\nconst HooksDispatcherOnMount: Dispatcher = {\n  useCallback: mountCallback,\n  useMemo: mountMemo,\n // 其他Hooks\n};\n\n// Update阶段Hooks的定义\nconst HooksDispatcherOnUpdate: Dispatcher = {\n  useCallback: updateCallback,\n  useMemo: updateMemo,\n  // 其他Hooks\n};\n```\nhooks在mount阶段和update阶段所调用的逻辑是不一样的，在上一篇中我们了解了hook的一些通用化操作，接下来我们将直接探究useMemo，useCallback是如何做缓存的。\n\n## useMemo\n\n### useMemo用法\nuseMemo是用来做性能优化的，只要传入的依赖内部元素没有发生变化那么返回的值或者引用不会发生变化，只要val不发生变化，那么返回的state引用还是一样的，这样子Child组件就不会重复渲染。\n\n```ts\nconst val = useState(1)\nconst state = useMemo(() => {val: 1}, [val])\nreturn (\n  <Child state={state}/>\n)\n```\n\n\n### mountMemo\n1. 跟其他hook一样，在mount阶段直接创建一个hook对象通过.next拼接在fiberNode的hook链表上\n2. mount初始化的时候直接调用传入的函数获取需要缓存的值然后直接返回，这样子我们在`const state = useMemo(() => {val: 1}, [val])`就可以拿到相应的值。\n3. 跟useState不一样的是：useState是直接保存值到hook的memoizedState属性上，useMemo保存的是一个长度为2的数组，值分别是上面调用后的值以及传入的依赖\n\n```ts\n// [react-reconciler/src/ReactFiberHooks.js](https://github.com/facebook/react/blob/be4c8b19c16a7558e2939a6665399f6f3202668e/packages/react-reconciler/src/ReactFiberHooks.js#L1389)\nfunction mountMemo<T>(\n  nextCreate: () => T,\n  deps: Array<mixed> | void | null,\n): T {\n  // 创建hook对象拼接在hook链表上\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  // 调用我们传入的函数 获取需要缓存的值\n  const nextValue = nextCreate();\n  //与useState直接保存值的不同 useMemo保存在memoizedState的是一个数组\n  // 第一个值是需要缓存的值 第二个是传入的依赖\n  hook.memoizedState = [nextValue, nextDeps];\n  return nextValue;\n}\n\n```\n\n### updateMemo\n1. 跟useState一样通过`updateWorkInProgressHook`获取更新时当前的useMemo的hook对象。\n2. 如果上一次的useMemo值(memoizedState)不为空并且这一次传入的依赖（nextDeps）不为空，那么两次依赖做浅比较。\n3. 依赖没有发生变化，那么直接返回数组第一个值即上一次渲染的值。如果依赖发生变化重新调用函数生成新的值\n\n```ts\nfunction updateMemo<T>(\n  nextCreate: () => T,\n  deps: Array<mixed> | void | null,\n): T {\n  // 第一篇已经说过 获取相对应的hook对象\n  const hook = updateWorkInProgressHook();\n  // 获取更新时的依赖\n  const nextDeps = deps === undefined ? null : deps;\n  // 获取上一次的数组值\n  const prevState = hook.memoizedState;\n  if (prevState !== null) {\n    // Assume these are defined. If they\'re not, areHookInputsEqual will warn.\n    // 如果这次传入的依赖不为空做浅比较 如果依赖没有发生变化那么直接返回上一次的值\n    if (nextDeps !== null) {\n      const prevDeps: Array<mixed> | null = prevState[1];\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        return prevState[0];\n      }\n    }\n  }\n  // 依赖发生变化 重新调用生成新的值\n  const nextValue = nextCreate();\n  hook.memoizedState = [nextValue, nextDeps];\n  return nextValue;\n}\n\n// 浅比较dep的函数\nfunction areHookInputsEqual(\n  nextDeps: Array<mixed>,\n  prevDeps: Array<mixed> | null,\n) {\n  if (prevDeps === null) {\n    return false;\n  }\n\n  // 浅比较\n  for (let i = 0; i < prevDeps.length && i < nextDeps.length; i++) {\n    if (is(nextDeps[i], prevDeps[i])) {\n      continue;\n    }\n    return false;\n  }\n  return true;\n}\n\n```\n\n### useMemo总结\n其实useMemo跟普通的hook逻辑基本一致，差异是在useState的hook对象memoizedState保存的是每次执行updateAction直接返回的值。但是useMemo保存的是一个数组分别是需要缓存的值以及依赖。在更新阶段会比对上一次以及当前的依赖做出是否直接返回上一次渲染的值。\n\n## useCallback\nuseCallback也是用来做性能优化的，只要传入的依赖内部元素没有发生变化，那么返回的函数引用相同。在下面中只要val不发生变化，那么返回的handleClick函数的引用就不会发生变化，这样子Child组件就不会重复渲染。\n\n```ts\nconst val = useState(1)\nconst handleClick = useCallback(() => console.log(val), [val])\nreturn (\n  <Child onClick={handleClick}/>\n)\n\n```\n\n### useCallback源码实现\nuseCallback源码实现跟useMemo基本上完全一模一样，不同的是useMemo会调用函数获取缓存的值，而useCallck保存的函数所以不需要调用。其余代码一模一样，这里就不做赘述了直接贴源码。\n\n```ts\n//https://github.com/facebook/react/blob/be4c8b19c16a7558e2939a6665399f6f3202668e/packages/react-reconciler/src/ReactFiberHooks.js#L1366\nfunction mountCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  //useCallback缓存的是函数 直接保存的就是函数引用\n  hook.memoizedState = [callback, nextDeps];\n  return callback;\n}\n\nfunction updateCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const prevState = hook.memoizedState;\n  if (prevState !== null) {\n    if (nextDeps !== null) {\n      const prevDeps: Array<mixed> | null = prevState[1];\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        return prevState[0];\n      }\n    }\n  }\n  hook.memoizedState = [callback, nextDeps];\n  return callback;\n}\n```\n\n## useRef\nuseRef源码也是十分简洁，本质上就是保存的是一个对象，对象内部有一个current值。每次更新的时候直接把这个对象返回出来，注意的是useRef内的值的改变不会触发react的调度更新。\n\n```ts\nfunction mountRef<T>(initialValue: T): {|current: T|} {\n  const hook = mountWorkInProgressHook();\n  const ref = {current: initialValue};\n  if (__DEV__) {\n    Object.seal(ref);\n  }\n  hook.memoizedState = ref;\n  return ref;\n}\n\nfunction updateRef<T>(initialValue: T): {|current: T|} {\n  const hook = updateWorkInProgressHook();\n  return hook.memoizedState;\n}\n```\n\n', 1, 'reactHooks,react', 'react hook源码解析2(useMemo与useCallback与useRef)', 1, '2020-03-29 18:11:50', '2020-11-06 09:54:49', NULL, 'http://img.carrotwu.com/FnFfNrtqMVJu3_JSUTMJNmnIZhMC', NULL);
INSERT INTO `article` VALUES (31, '记录一下leetcode的刷题之旅，坚持每一周整理一篇做题笔记吧，坚持刷题奥利给。', 101, '> 记录一下leetcode的刷题之旅，坚持每一周整理一篇做题笔记吧，坚持刷题奥利给。\n\n\n## 设计和实现一个LRU (最近最少使用) 缓存机制\n### 运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。\n获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。\n写入数据 put(key, value) - 如果密钥不存在，则写入（设置或插入）其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间\n>可以通过数组也可以通过es6的map来实现，注意的是每次获取值时都要把旧的值删除在栈顶重新插入值。[**链接**](https://leetcode-cn.com/problems/lru-cache/ \"Html\")\n\n```js\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n  this.capacity = capacity\n  this.map = new Map()\n};\n\n/**\n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n  if(this.map.has(key)){\n    // 如果已经存在先获取值 先删除旧的key 在栈顶添加当前元素\n    const temp = this.map.get(key)\n    this.map.delete(key)\n    this.map.set(key, temp)\n    return temp\n  }else {\n    return -1\n  }\n};\n\n/**\n * @param {number} key\n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n  if(this.map.has(key)){\n    this.map.delete(key)\n  }\n  this.map.set(key, value)\n  while(this.map.size > this.capacity){\n    const key = this.map.keys()\n    // .next是一个迭代函数\n    this.map.delete(key.next().value)\n  }\n};\n```\n\n## 全排列\n### 给定一个 没有重复 数字的序列，返回其所有可能的全排列。\n示例:\n输入: [1,2,3]\n输出:\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]\n> 回溯法：核心就是通过一个数组保存每次循环的值，当没有元素插入时就进行保存。每次循环之后把栈顶的元素删除，回到上一部操作。[**链接**](https://leetcode-cn.com/problems/permutations \"Html\")\n\n```js\n/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar permute = function(nums) {\n\n  // 回溯法\n  const result = []\n  const temp = []\n\n  function getAll(tempArray){\n    if(tempArray.length === 0){\n      // 数组没有元素说明排列完了 把当前的temp push进result\n      result.push(temp.slice())\n      // 回溯\n    }else {\n      // 还有元素 继续循环\n      for(let i = 0; i < tempArray.length; i++){\n        // 拷贝一个用于下面的 splice去除当前插入的元素\n        const curArray = tempArray.slice()\n        // 把当前元素插入到temp的中间数组中\n        temp.push(curArray[i])\n        // 在数组中删除插入的元素继续递归\n        curArray.splice(i,1)\n        getAll(curArray)\n        // 每次执行之后记得回溯temp插入的变量\n        temp.pop()\n      }\n    }\n  }\n\n  getAll(nums.slice())\n  return result\n};\n\n```\n## 子集\n### 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。\n>也是回溯法，与上面的全排列不一样的是，每当插入一个元素就需要保存数组结果吗，知道循环结束，回溯的标志就是剩余数组长度为0。[**链接**](https://leetcode-cn.com/problems/permutations \"Html\")\n\n```js\n/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar subsets = function(nums) {\n  const result = []\n  const temp = []\n\n  function getSets(array) {\n    // 不管有没有 当前temp都是一个子集直接插入\n    result.push(temp.slice())\n    if(array.length !== 0){\n      // 还有\n      for(let i =0; i< array.length; i++){\n        //  先插入当前元素\n        temp.push(array[i])\n        // 继续递归  洗一次的array拿的是当前元素之后的数组\n        getSets(array.slice(i+1, array.length))\n        // 递归完成 回溯\n        temp.pop()\n      }\n    }\n  }\n  getSets(nums)\n  return result\n};\n\n```\n\n## 有效的括号\n### 给定一个只包括 \'(\'，\')\'，\'{\'，\'}\'，\'[\'，\']\' 的字符串，判断字符串是否有效。\n有效字符串需满足：\n1. 左括号必须用相同类型的右括号闭合。\n2. 左括号必须以正确的顺序闭合。\n3. 注意空字符串可被认为是有效字符串。\n>通过一个栈来进行维护，对于左符号直接丢进栈中，循环到又符号的话取出栈顶元素是否相对称即可。最后判断栈中是否还有元素有的话那么久无法匹配。[**链接**](https://leetcode-cn.com/problems/valid-parentheses \"Html\")\n\n```js\n/**\n * @param {string} s\n * @return {boolean}\n */\nvar isValid = function(s) {\n\n  //其实就是一个栈的模拟 对于每次遇到一个又符号那么拿出栈订的元素进行匹配\n  if(s.length % 2 === 1) return false\n\n\n  const directionMap = {\n    \'(\' : \'left\',\n    \'{\' : \'left\',\n    \'[\' : \'left\',\n    \')\' : \'right\',\n    \'}\' : \'right\',\n    \']\' : \'right\',\n  }\n  const rightMap = {\n    \'(\' : \')\',\n    \'{\' : \'}\',\n    \'[\' : \']\'\n  }\n  const result = []\n  for(let i=0; i< s.length; i++){\n    if(directionMap[s[i]] === \'left\'){\n      result.push(s[i])\n    }else {\n      if(rightMap[result.pop()] !== s[i]) return false\n    }\n  }\n  // 数组还有元素没被清空那么就是没有匹配完 返回false\n  return !result.length\n};\n```\n\n## 二叉搜索树的最近公共祖先\n### 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8。输出: 6。解释: 节点 2 和节点 8 的最近公共祖先是 6。\n>如果qp都大于当前节点，说明公共祖先在父节点的右节点上；如果qp都小于于当前节点，说明公共祖先在父节点的左节点上。其余情况都认为当前节点就是公共祖先节点。[**链接**](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree \"Html\")\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {TreeNode}\n */\nvar lowestCommonAncestor = function(root, p, q) {\n  // 因为对于二叉搜索树来说 左边节点比父节点小 ，有节点比父节点大\n  // 对于pq来说 pq都比父节点小 ，那么从node.left继续查找\n  // pq都比父节点大 ，那么从node.right继续查找\n  // 查找到一个节点比当前节点大一个比当前节点小那么就是公共祖先\n\n  if(p.val > root.val && q.val > root.val){\n    // 都比root大往右边找\n    return lowestCommonAncestor(root.right, p,q)\n  }else if(p.val < root.val && q.val < root.val){\n    // 都小\n    return lowestCommonAncestor(root.left, p,q)\n  }else {\n    // 一大一小\n    return root\n  }\n};\n```\n\n## 155. 最小栈\n### 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。\n>通过一个数组来模拟栈即可，同时保存一个min变量用来保存最小元素。[**链接**](https://leetcode-cn.com/problems/min-stack \"Html\")\n\n```js\n/**\n * initialize your data structure here.\n */\nvar MinStack = function() {\n  this.stack = []\n  this.min = Infinity\n  return this\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nMinStack.prototype.push = function(x) {\n  this.stack.push(x)\n  this.min = Math.min(x, this.min)\n};\n\n/**\n * @return {void}\n */\nMinStack.prototype.pop = function() {\n  const val = this.stack.pop()\n  if(val === this.min){\n    // 删除的是最小值重新计算\n    this.min = Math.min(...this.stack)\n  }\n  return val\n};\n\n/**\n * @return {number}\n */\nMinStack.prototype.top = function() {\n  return this.stack[this.stack.length -1]\n};\n\n/**\n * @return {number}\n */\nMinStack.prototype.getMin = function() {\n  return this.min\n};\n```\n\n## 第k个排列\n### 给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。给定 n 和 k，返回第 k 个排列。\n给定3和3.按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：\n\"123\",\"132\",\"213\",\"231\",\"312\",\"321\"。即返回213\n\n> 这里给出的方法是比较笨的方法，其实可以通过阶乘数字大小来推断出当前位数以及具体数字的。[**链接**](https://leetcode-cn.com/problems/permutation-sequence \"Html\")\n\n```js\n// 比较笨的本法列出所有的排列 不太可取。可以通过阶乘知道其实位置是多少\n/**\n * @param {number} n\n * @param {number} k\n * @return {string}\n */\nvar getPermutation = function(n, k) {\n  const nArray = Array.from({length: n}).fill(0).map((item, index) => index+1)\n  const result = []\n  const temp = []\n\n  function getAll(tempArray){\n    // 长度满足了 直接退出 不然容易超时\n    if(result.length === k) return\n    if(tempArray.length === 0){\n      // 排列完了 直接丢入result\n      result.push(temp.slice())\n    }else {\n      // 还有元素\n      for(let i =0; i< tempArray.length; i++){\n        // 插入当前元素\n        temp.push(tempArray[i])\n        // 继续递归\n        const curArray = tempArray.slice()\n        curArray.splice(i,1)\n        getAll(curArray)\n        // 回溯\n        temp.pop()\n      }\n    }\n  }\n  getAll(nArray)\n  return result[k-1].join(\'\')\n};\n\n```\n', 1, 'algorithm', '每周算法汇总(0408)', 1, '2020-04-09 11:36:53', '2020-09-30 14:28:19', NULL, 'http://img.carrotwu.com/FmdOlwdj5XD5BN0UiZgOSOVvr9yd', NULL);
INSERT INTO `article` VALUES (32, '正在开发的cli工具wcli是用node+typescript编写的，在编写的过程中不免需要引用到大量的模块。大量的import utils from \'../../../../../utils\'太麻烦也太恶心了，于是开始了ts的路径别名踩坑之旅。', 37, '## 问题由来\n\n我正在开发的 cli 工具 wcli 是用`node`+`typescript`编写的，在编写的过程中不免需要引用到大量的模块。\n\n大量的`import utils from \'../../../../../utils\'`太麻烦也太恶心了，于是开始了 ts 的路径别名踩坑之旅。\n\n## ts 的路径别名设置\n\nts 的路径别名设置在社区中已经十分成熟了，官网中也有相应的文档描述。接下来的内容将直接引用官网的描述以及设置。\n\n### ts 官网的路径映射配置\n\n有时模块不是直接放在`baseUrl`下面。 比如，充分 `\"jquery\"`模块地导入，在运行时可能被解释为`node_modules/jquery/dist/jquery.slim.min.js`。 加载器使用映射配置来将模块名映射到运行时的文件，查看 `RequireJs documentation和SystemJS documentation`。\n\n`TypeScript`编译器通过使用 tsconfig.json 文件里的\"paths\"来支持这样的声明映射。 下面是一个如何指定 `jquery`的`paths`的例子。\n\n```js\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\", // This must be specified if \"paths\" is.\n    \"paths\": {\n      \"jquery\": [\"node_modules/jquery/dist/jquery\"] // 此处映射是相对于\"baseUrl\"\n    }\n  }\n}\n```\n\n请注意`paths`是相对于`\"baseUrl\"`进行解析。 如果 `baseUrl`被设置成了除\".\"外的其它值，比如 tsconfig.json 所在的目录，那么映射必须要做相应的改变。 如果你在上例中设置了 `baseUrl: ./src`，那么 jquery 应该映射到`../node_modules/jquery/dist/jquery`。\n\n### 课代表总结\n\n1. **baseUrl: 用来设置下面 path 路径的根路径**。\n2. **path: 用来设置相对应的路径映射，数组中的路径相对应 baseUrl 的路径**。\n\n```js\n\"baseUrl\": \".\",\n\"paths\": {\n  \"@srcTypes/*\": [\"src/types/*\"],\n  \"@constants/*\": [\"src/constants/*\"],\n  \"@commands/*\": [\"src/commands/*\"],\n  \"@utils/*\": [\"src/utils/*\"]\n}\n```\n\n配置完即可在项目中使用。\n\n```ts\nimport XXX from \"@utils/getPluginFile\";\nimport { xx } from \"@utils/checktype\";\nimport { xx } from \"@utils/createContext\";\n```\n\n## tsc 的坑\n\n路径映射是做好了，但是在执行 tsc 打包完之后的代码发现报错了：用 tsc 编译的后，映射的路径不会处理，将导致编译后的代码找不到模块。\n\n比如上面的 `import XXX from \'@utils/getPluginFile\'` ，如果你使用 commonjs 模式编译后应该是 `const XXX = require(\'@utils/getPluginFile\')` ，结果就是找不到这个模块。\n\n### 解决办法\n\n根据是否使用 webpack 打包，请自行选择\n\n1. 如果项目是通过 webpack 进行打包的，那么可以把路径的替换交给 webpack 的 alias 处理即可。\n\n```js\nmodule.exports = {\n  //...\n  resolve: {\n    alias: {\n      @utils: path.resolve(__dirname, \'src/utils/\')\n    }\n  }\n};\n```\n\n2. 问题是我的 wcli 不是用 webpack 打包的，纯粹就是使用 tsc 编译成 js 在 node 上执行的那怎么办呢？后面发现社区上提供了一个库-`module-alias`。在配置完 tsconfig 的基础上只需要通过简单的两步即可实现。\n   在`package.json`配置跟 webpack alias 的路径指向然后在入口文件调用引用方法即可。\n\n```js\n// Aliases\n\"_moduleAliases\": {\n  \"@root\"      : \".\", // Application\'s root\n  \"@deep\"      : \"src/some/very/deep/directory/or/file\",\n  \"@my_module\" : \"lib/some-file.js\",\n  \"something\"  : \"src/foo\", // Or without @. Actually, it could be any string\n}\n\n// 在入口文件最顶端调用即可\nrequire(\'module-alias/register\')\n```\n\n一些另外的用法可以去官网查看即可，这里是[**跳转连接**](https://www.npmjs.com/package/module-alias \"Html\")。\n\n## eslint 的坑\n\n根据上面的内容,tsc 是好使了打包出来的代码也能正常运行。不过有一个新的坑出来了：eslint 并不能识别路径别名，虽然能够正确跳转以及引用。难受啊！马飞！。\n\n![alt](http://img.carrotwu.com/FrKp2UCgWk79_TE4cZshMiD7K7Zk)\n\n最简单最暴力的方式自然是直接去掉这个插件，或者关闭相关 `ESLint rules`，但 `eslint-plugin-import` 30+ rules 集合 JS 社区 ES6 多年最佳实践，关闭这个规则实乃下下策。最终在一位大佬的博客下找到了一个完美的 eslint 插件解决这个问题-`eslint-import-resolver-typescript`。\n\n### eslint-import-resolver-typescript\n\n[**eslint-import-resolver-typescript**](https://github.com/alexgorbatchev/eslint-import-resolver-typescript \"Html\")光从名字就可以看出和这个问题极为相关。从项目 README 可以发现，这个 lib 可以在 TypeScript 项目使 eslint-plugin-import 找到正确的 .ts 和 .tsx 文件，也能识别 tsconfig.json 的 path 配置（路径别名 2），甚至 monorepo 这类一个 git 仓库多个项目的工程也支持。\n\n用法也很简单在 eslint 的`\"import/resolver\":`指向当前配置了 path 的 tsconfig 的路径即可，eslint 就会自动识别就不会报错了。\n\n```js\n{\n  \"plugins\": [\"import\"],\n  \"rules\": {\n    \"import/no-unresolved\": \"error\"\n  },\n  \"settings\": {\n    \"import/parsers\": {\n      // 使用 TypeScript parser\n      \"@typescript-eslint/parser\": [\".ts\", \".tsx\"]\n    },\n    \"import/resolver\": {\n      // 默认使用根目录 tsconfig.json\n      \"typescript\": {\n        // 从 <roo/>@types 读取类型定义\n        \"alwaysTryTypes\": true，\n      },\n\n      // 使用指定路径 tsconfig.json， <root>/path/to/folder/tsconfig.json\n      \"typescript\": {\n        \"directory\": \"./path/to/folder\"\n      },\n\n      // monorepos 这类多 tsconfig.json\n\n      // 可以用 glob 这类匹配模式\n      \"typescript\": {\n        \"directory\": \"./packages/*/tsconfig.json\"\n      },\n\n      // 或者数组\n      \"typescript\": {\n        \"directory\": [\n          \"./packages/module-a/tsconfig.json\",\n          \"./packages/module-b/tsconfig.json\"\n        ]\n      },\n\n      // 也可以混合使用\n      \"typescript\": {\n        \"directory\": [\n          \"./packages/*/tsconfig.json\",\n          \"./other-packages/*/tsconfig.json\"\n        ]\n      }\n    }\n  }\n}\n\n```\n\n## 最后\n\n贴一下我的 eslintrc 配置，可以作为参考：\n\n```js\nmodule.exports = {\n  \'parser\': \'@typescript-eslint/parser\', //定义ESLint的解析器\n  \'extends\': [\'airbnb-base\', \'plugin:@typescript-eslint/recommended\'],//定义文件继承的子规范\n  \'plugins\': [\'@typescript-eslint\'],//定义了该eslint文件所依赖的插件\n  \'env\': {                          //指定代码的运行环境\n    \'browser\': false,\n    \'node\': true\n  }\n  \'settings\': {\n    //解决路径引用ts文件报错的问题\n    \'import/resolver\': {\n      \'node\': {\n        \'extensions\': [\'.js\', \'.jsx\', \'.ts\', \'.tsx\']\n      },\n      // 解决tsconfig下的path别名导致eslint插件无法解决的bug\n      \'typescript\': {\n        \'alwaysTryTypes\': true\n      }\n    }\n  },\n}\n\n```\n\n## 参考文献\n\n[ESLint 检查 TypeScript 时报 “Unable to resolve path to module ‘xxx’” 错误](https://devrsi0n.com/articles/eslint-typescript-import-unsolve)\n', 1, 'nodeJs,typescript', 'typescript路径别名踩坑之旅', 1, '2020-04-12 13:39:48', '2020-12-09 14:36:03', NULL, 'http://img.carrotwu.com/FkejHEKN0QraD25axMXuPfUr_8iH', NULL);
INSERT INTO `article` VALUES (33, '记录一下leetcode的刷题之旅，坚持每一周整理一篇做题笔记吧，坚持刷题奥利给。', 15, '> 记录一下leetcode的刷题之旅，坚持每一周整理一篇做题笔记吧，坚持刷题奥利给。\n\n## 搜索旋转排序数组\n### 假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。\n>本质上还是需要通过二分查找法 注意的地方是左右指针的边界问题。通过nums[right] > nums[left] 判断是不是正常排序的数组，如果是正常的数组可以走正常的二分查找，极大地优化。任意找一个位置 总有一个方向是升序的 nums[mid] > nums[start] 左边有序 不然右边有序\n\n```js\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar search = function (nums, target) {\n  if (nums.length < 2) {\n    return nums[0] === target ? 0 : -1\n  }\n  let start = 0\n  let end = nums.length - 1\n\n  while (start < end) {\n    let mid = Math.floor((end - start) / 2) + start\n    //取中值\n    if (nums[mid] === target) return mid\n    if (nums[start] === target) return start\n    if (nums[end] === target) return end\n\n    // 优化\n    if (nums[start] < nums[end]) {\n      // 如果右边的比左边大那么认为数组时正确排序了的 执行正产二分法\n      if (nums[mid] > target) {\n        end = mid - 1\n      } else {\n        start = start + 1\n      }\n      continue // 继续循环\n    }\n    if (nums[mid] > nums[start]) {\n      //左边是升序\n      if (target > nums[start] && target < nums[mid]) {\n        // 只有target比左边大 比终点小才会在左边位置 不然肯定在右边\n        end = mid - 1\n      } else {\n        start = start + 1\n      }\n    } else {\n      // 右边是升序\n      if (target > nums[mid] && target < nums[end]) {\n        // 右边是升序 只有大于终点 小于右边 target才有可能在右边 不然肯定在左边\n        start = mid + 1\n      } else {\n        end = mid - 1\n      }\n    }\n  }\n\n  return -1\n}\n```\n\n## 二叉树的最近公共祖先\n### 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n\n> 这题相比于之前的搜索二叉树 我们是能够明确知道两个元素在左边还是右边。这题不可以，但是我们可以换个思路。通过递归查找到 pq节点 找到返回 直到当前root的 left right 都有qp说明当前root就是要找的节点。\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {TreeNode}\n */\nvar lowestCommonAncestor = function (root, p, q) {\n  if (root === null || root.val === q.val || root.val === p.val) {\n    //找到了 直接返回 当前节点\n    return root\n  }\n  // 递归查找左右节点\n  const left = lowestCommonAncestor(root.left, p, q)\n  const right = lowestCommonAncestor(root.right, p, q)\n  // 如果都存在的话 那么当前root就是祖先\n  if (left && right) {\n    return root\n  }\n  // 如果都没有那么直接返回null\n  if (!left && !right) {\n    return null\n  }\n\n  // 一个有一个没有\n  return left ? left : right\n\n}\n\n```\n## 只出现一次的数字\n### 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n\n>有多重办法，但是最简单的还是通过异或运算符依次搞定，确实天秀。\n\n```js\n// 创建额外空间\nvar singleNumber = function (nums) {\n  const map = {}\n\n  for (let i = 0; i < nums.length; i++) {\n    if (map[nums[i]]) {\n      delete map[nums[i]]\n    } else {\n      map[nums[i]] = 1\n    }\n  }\n\n  return Object.keys(map)[0]\n}\n\n// 利用异或运算的性质 0^n = n  n^n=0 a^b=1\n// 异步运算符合交换律 即 a^b^c^a^b = a^a^b^b^c = 0^c = c\nvar singleNumber2 = function (nums) {\n  let result = 0\n  for (let i = 0; i < nums.length; i++) {\n    result = result ^ nums[i]\n  }\n  return result\n  // return nums.reduce((prev,cur) => prev^cur)\n}\n```\n\n## 查找第k个大的元素\n\n>有多重办法，LeetCode中大部分是通过堆排序来实现，我这边采用了快排。\n\n```js\n// 查找第k个大的元素\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar findKthLargest = function (nums, k) {\n\n// 块排\n  let left = 0\n  let right = nums.length - 1\n  let tempIndex = fastSort(nums, left, right)\n  while (k - 1 !== tempIndex) {\n    //继续递归\n    if (tempIndex > k - 1) {\n      //数字更大 数字在左边\n      right = tempIndex - 1\n\n    } else {\n      //在右边\n      left = tempIndex + 1\n    }\n    tempIndex = fastSort(nums, left, right)\n  }\n\n  // 当前元素就是第k个最大的元素了\n\n  return nums[k - 1]\n\n}\n\nfunction fastSort (nums, left, right) {\n  var pivot = nums[left]\n  while (left < right) {\n    while (left < right && nums[right] <= pivot) {\n      right--\n    }\n    nums[left] = nums[right]\n\n    while (left < right && nums[left] > pivot) {\n      left++\n    }\n    nums[right] = nums[left]\n  }\n  nums[left] = pivot\n  return left\n}\n```\n', 1, 'javascript,algorithm', '每周算法汇总(0428)', 1, '2020-04-28 17:01:10', '2020-09-03 14:01:27', NULL, '', NULL);
INSERT INTO `article` VALUES (34, '在阅读极客时间《图解 Google V8》中的学习笔记，好记性不如烂笔头。', 92, '>在阅读极客时间《图解 Google V8》中的学习笔记，好记性不如烂笔头。\n\n## V8 是怎么执行 JavaScript 代码的？\nV8 并没有采用某种单一的技术，而是混合编译执行和解释执行这两种手段，我们把这种混合使用编译器和解释器的技术称为 JIT（Just In Time）技术。  \n\n两种方法都各自有各自的优缺点，解释执行的启动速度快，但是执行时的速度慢，而编译执行的启动速度慢，但是执行时的速度快。V8 采用了一种权衡策略，在启动过程中采用了解释执行的策略，但是如果某段代码的执行频率超过一个值，那么 V8 就会采用优化编译器将其编译成执行效率更加高效的机器代码。你可以参考下面完整的 V8 执行 JavaScript 的流程图：  \n\n![alt](http://img.carrotwu.com/FqU5_o385Un5P7A6VcUuo4siu1rM)\n\n### 主要流程\n1. 初始化基础环境；\n2. 解析源码生成 AST 和作用域；\n3. 依据 AST 和作用域生成字节码；\n4. 解释执行字节码；监听热点代码；\n5. 优化热点代码为二进制的机器代码；\n6. 反优化生成的二进制机器代码。\n\n注意的是JavaScript 是一门动态语言，在运行过程中，某些被优化的结构可能会被 V8 动态修改了，这会导致之前被优化的代码失效，如果某块优化之后的代码失效了，那么编译器需要执行反优化操作。一般来说一些反优化的操作集中于类似：\n\n1. 频繁修改或者删除新增类的属性（隐藏类）\n2. 函数参数的不确定性（函数重载）\n\n具体的优化措施可以见![文章][https://juejin.im/post/5dc4ccba6fb9a04a746f0ed3]\n\n\n## js中对象的那些事\n\n### 何为对象\n\njs中的对象就是一对对属性与属性值的集合，从 JavaScript 语言的角度来看，JavaScript 对象像一个字典，字符串作为键名，任意对象可以作为键值，可以通过键名读写键值。  \n\n而在 V8 实现对象存储时，并没有完全采用字典的存储方式，这主要是出于性能的考量。因为字典是非线性的数据结构，查询效率会低于线性的数据结构。\n\n### 常规属性 (properties) 和排序属性 (element)\n\njs中一直流传着这么一句话：js中对象属性的遍历并不会按顺序进行遍历。本质上就是因为js中对象的两个内置属性**常规属性 (properties) 和排序属性 (element)**\n在声明定义时，我们先执行下面这么一段代码:\n\n```js\n\nfunction Foo() {\n    this[100] = \'test-100\'\n    this[1] = \'test-1\'\n    this[\"B\"] = \'bar-B\'\n    this[50] = \'test-50\'\n    this[9] =  \'test-9\'\n    this[8] = \'test-8\'\n    this[3] = \'test-3\'\n    this[5] = \'test-5\'\n    this[\"A\"] = \'bar-A\'\n    this[\"C\"] = \'bar-C\'\n}\nvar bar = new Foo()\n\nfor(key in bar){\n    console.log(`index:${key}  value:${bar[key]}`)\n}\n/*\n\nindex:1  value:test-1\nindex:3  value:test-3\nindex:5  value:test-5\nindex:8  value:test-8\nindex:9  value:test-9\nindex:50  value:test-50\nindex:100  value:test-100\nindex:B  value:bar-B\nindex:A  value:bar-A\nindex:C  value:bar-C\n*/\n```\n\n可以看出的是对象的遍历并不会以变量添加的顺序进行遍历，但是有两点发现的是：\n1. 设置的数字属性被最先打印出来了，并且是按照数字大小的顺序打印的；\n2. 设置的字符串属性依然是按照之前的设置顺序打印的，比如我们是按照 B、A、C 的顺序设置的，打印出来依然是这个顺序。\n\n之所以出现这样的结果，是因为在 ECMAScript 规范中定义了**数字属性应该按照索引值大小升序排列，字符串属性根据创建时的顺序升序排列**。\n\n在这里我们把对象中的数字属性称为**排序属性**，在 V8 中被称为 elements，字符串属性就被称为**常规属性**，在 V8 中被称为 properties。在v8中每个对象内置了两个属性:elements保存的是排序属性；properties保存的是常规属性\n\n![alt](http://img.carrotwu.com/FgdXW_p-J66glZw8bMdmOXN2O54-)  \n\n如果执行索引操作，那么 V8 会先从 elements 属性中按照顺序读取所有的元素，然后再在 properties 属性中读取所有的元素，这样就完成一次索引操作。\n\n### 对象内属性，快属性和慢属性\n\n#### 对象内属性\n对于需要频繁的获取对象属性，那么久需要先查询对应的常规属性（properties），再在对应的对象中获取到具体的属性，这样子每次查询都需要两步操作。  \n\nV8 采取了一个权衡的策略以加快查找属性的效率，这个策略是将部分常规属性直接存储到对象本身（一般是十个之内），在获取这些属性的时候直接从对象上获取即可。**保存在对象本身上的常规属性我们称之为对象内属性**\n\n#### 快属性\n前面说的对于常规属性或者排序属性，如果这些属性是保存在线性结构中的我们就称之为快属性。因为在线性结构中我们只需要通过索引即可获取属性。\n\n#### 慢属性\n\n如果一个对象的属性过多时，就会转为话慢属性结构。慢属性的对象内部会有独立的非线性数据结构 (词典) 作为属性存储容器。所有的属性元信息不再是线性存储的，而是直接保存在属性字典中。因此对于频繁的创建或者删除元素时，慢属性的效率会比快属性高（快属性的创建或者删除都要移动相关属性的位置）\n\n![alt](http://img.carrotwu.com/FpmLPBXGPOgVtPE4fNqtMnZEju6t)\n\n## 继承的那些事\n不同的语言实现继承的方式是不同的，其中最典型的两种方式是**基于类的设计**和基于**原型继承**的设计，javascript是基于原型链的设计。要明白原型链必须先明白两个概念：\n\n1. 每个对象都有一个内置的**原型属性__proto__**,__proto__指向的是该对象的**原型属性**\n2. 每个函数都有一个原型属性**prototype**，prototype指向的是该函数的**原型对象**\n\n## 延迟解析（惰性解析）\n\nv8对js的执行分为两个阶段：\n1. 编译：V8 将 JavaScript 代码转换为字节码或者二进制机器代码的阶段\n2. 执行：执行阶段则是指解释器解释执行字节码，或者是 CPU 直接执行二进制机器代码的阶段  \n\n在编译js的过程中，v8并不会一次性的把js转为字节码或者是机器码，主要是基于下面两点。\n1. 有些js文件十分大，甚至达到10m。一次性的编译js代码会造成卡顿。增加用户的卡顿时间。\n2. 编译完成的字节码或者机器码都会存于内存之中，一次性解析会占用大量内存。  \n\n基于上面两个点，v8提出了**惰性解析**的编译方法:**解析器在解析的过程中，如果遇到函数声明，那么会跳过函数内部的代码，并不会为其生成 AST 和字节码，而仅仅生成顶层代码的 AST 和字节码。**\n\n### 闭包中惰性解析的过程\n\n在讲解前先前置化函数的三个特性：\n\n1. 可以在 JavaScript 函数内部定义新的函数；\n2. 内部函数中访问父函数中定义的变量；\n3. 因为 JavaScript 中的函数是一等公民，所以函数可以作为另外一个函数的返回值。\n\n假设有这么一段景点的闭包代码：\n```js\nfunction foo() {\n    var d = 20\n    return function inner(a, b) {\n        const c = a + b + d\n        return c\n    }\n}\nconst f = foo()\n```\n1. 当调用 foo 函数时，foo 函数会将它的内部函数 inner 返回给全局变量 f；\n2. 然后 foo 函数执行结束，执行上下文被 V8 销毁；\n3. 虽然 foo 函数的执行上下文被销毁了，但是依然存活的 inner 函数引用了 foo 函数作用域中的变量 d。\n\nfoo函数执行完成之后，foo函数的执行上下文就出栈了但是返回的inner函数内部使用到了变量d，因此这时候v8u的垃圾回收器并不能直接回收d变量。  \n\n在执行 foo 函数的阶段，虽然采取了惰性解析，不会解析和执行 foo 函数中的 inner 函数，但是 V8 还是需要判断 inner 函数是否引用了 foo 函数中的变量，负责处理这个任务的模块叫做预解析器。\n\n### 预解析器\n\n虽然v8通过使用惰性解析来优化js的解析性能，但并不代表函数内部的函数声明会直接跳过。对于函数声明会通过一个预解析器来进行语法判断等功能。  \n\n预解析器的作用：\n\n1. 语法错误的判断，如果函数内部存在语法错误那么直接抛出错误；\n2. 检查函数内部是否引用了外部变量，是的话会把当前变量存放到堆内存中。\n\n结论：函数执行完执行上下文出栈，变量的回收依托于垃圾回收；被闭包引用的变量会被存放到堆内存中，用于闭包的下一次访问。\n\n## v8属性访问的优化-隐藏类\n\n相比于js的动态类型，js的对象是可以在声明后新增或者删除属性；像c++或者java这些静态类型的语言，需要在声明时就确定好对象的结构，因此可以通过指针位置偏移量来优化直接查找属性的性能，js只能通过遍历循环属性（快慢属性）查找。\n\n\n![alt](http://img.carrotwu.com/Fudhms26s3Y9hM7q1bo9TMk-8ioP)\n\n### 隐藏类\n\n在上面的背景下，v8通过模拟静态类型语言的这种特性引入了**隐藏类**  \n\n具体地讲，V8 对每个对象做如下两点假设：\n\n1. 对象创建好了之后就不会添加新的属性；\n2. 对象创建好了之后也不会删除属性。  \n\n对象的隐藏类中记录了该对象一些基础的布局信息，包括以下两点：\n\n1. 对象中所包含的所有的属性；\n2. 每种类型相对于对象的偏移量。\n  \n有了隐藏类之后，那么当 V8 访问某个对象中的某个属性时，就会先去隐藏类中查找该属性相对于它的对象的偏移量，有了偏移量和属性类型，V8 就可以直接去内存中取出对于的属性值，而不需要经历一系列的查找过程，那么这就大大提升了 V8 查找对象的效率\n\n### 多对象共用隐藏类\n\n现在我们知道了在 V8 中，每个对象都有一个 map 属性，该属性值指向该对象的隐藏类。不过如果两个对象的形状是相同的，V8 就会为其复用同一个隐藏类，这样有两个好处：\n1. 减少隐藏类的创建次数，也间接加速了代码的执行速度；\n2. 减少了隐藏类的存储空间。\n\n那么，什么情况下两个对象的形状是相同的，要满足以下两点：\n1. 相同的属性名称；\n2. 相等的属性个数。\n\n### 重新构建隐藏类\n\n前面我们了解到，隐藏类的创建需要两个条件：\n\n1. 对象创建好了之后就不会添加新的属性；\n2. 对象创建好了之后也不会删除属性。\n\n但是js是动态语言，在声明完成之后可以重新添加删除属性，再这样子的情况下；**v8会重新创建新的隐藏类**,这是一笔额外的开销。\n\n### 最佳实践\n\n为了不频繁的创建删除隐藏类，在实际工作代码编写中应注意以下几点；\n\n1. 使用字面量初始化对象时，要保证属性的顺序是一致的。这样子能够复用同一个隐藏类；\n2. 尽量使用字面量一次性初始化完整对象属性。因为每次为对象添加属性，都会重新创建隐藏类；\n3. 尽量避免使用 delete 方法。跟2同理，删除属性也会重新创建隐藏类；\n\n', 1, 'browser,javascript', '《图解 Google V8》学习笔记', 1, '2020-05-18 14:55:55', '2020-11-06 09:56:13', NULL, 'http://img.carrotwu.com/FkZwkYcWzjQkaBgMBjnyACt5Qj5f', NULL);
INSERT INTO `article` VALUES (35, '这段时间莫名的对ssr产生了兴趣，开始捣鼓着把原来用`create-react-app`的项目用`next.js`重构成服务端渲染。下面记录一下一些要点以及踩坑之旅', 127, '\n## 引子\n这段时间莫名的对ssr产生了兴趣，开始捣鼓着把原来用`create-react-app`的项目用`next.js`重构成服务端渲染。下面记录一下一些要点以及踩坑之旅\n\n## next.js的使用\n\n因为原来的博客前端是用ts写的，nextJs也贴心的内置了typescript的支持。再原来创建的模板基础上执行两条命令即可\n\n\n```js\ntouch tsconfig.json\nyarn add --dev typescript @types/react @types/node\nyarn dev\n```\n\n## scss的引入以及支持私有样式\n\nnext.js内置已经支持了scss的支持，官网有介绍这边就不赘述了。但是使用过`create-react-app`编写过项目的人都知道。react能够自动识别`.module.scss`为组件私有样式，而`.scss`为全局样式。next.js并不支持，只允许全为模块化或者非模块化。\n\n经过一系列的查找终于发现了一个老外写的插件`@webdeb/next-styles`,已经搬我们做了处理。在`next.config.js`引入重写即可.\n\n```js\nconst withStyles = require(\'@webdeb/next-styles\')\nconst withImages = require(\'next-images\')\n// next-styles\n// 支持less和scss的next插件 老外写的\n// 这个插件支持create-react-app的样式写法支持\n// 自动识别module.(scss|sass|less)为模块化样式\n// xxx.scss为全局样式\nmodule.exports = withImages(withStyles({\n  modules: true,\n  sass: true, // use .scss files\n  cssLoaderOptions: {\n    importLoaders: 2,\n  },\n  sassLoaderOptions: {\n    sassOptions: {\n      includePaths: [\"./src\"], // @import \'variables\'; # loads (src/styles/varialbes.scss), you got it..\n    },\n  },\n  webpack (config, options) {\n    config.module.rules.push({\n      test: /\\.(svg|eot|ttf|woff|woff2)$/,\n      use: {\n        loader: \'url-loader\',\n        options: {\n          limit: 100000\n        }\n      }\n    })\n    return config\n  }\n}))\n```\n\n## 自定义server端\nnext.js通过page目录下的文件来创建配置相关路由，不过我想着还是做自定义server端更自由一点。\n\n在项目根目录下新建server文件夹，新建`index.ts tsconfig.json`等文件。原本项目根目录下的`tsconfig.json`并不适用于server端的ts文件。\n\n原因是因为src下的目录下react文件是要运行在浏览器端的。所以要使用es6的模块，而我们server下的文件是运行在node下的，所以必须编译成commonjs模块.\n\n```js\n// src tsconfig.json\n{\n  compilerOptions： {\n    \"module\": \"esnext\",\n  }\n}\n\n// server\n{\n  compilerOptions： {\n    \"module\": \"commonjs\",\n  }\n}\n```\n\n修改`package.json`的dev命令为:\n\n```js\n{\n  scripts: {\n    \"dev\": \"cross-env NODE_ENV=development TS_NODE_PROJECT=\'./server/tsconfig.json\' ts-node-dev --respawn  --transpileOnly --ignore-watch=.next --ignore-watch=node_modules --ignore-watch=src server/index.ts\",\n  }\n}\n```\n\n\n## server端支持/xx/:id的动态路由\n\nnext.js因为是通过pages目录下的文件来确定路由，所以并不支持以往的动态路由写法。因此在访问动态路由时会因为查找不到路由返会404.\n\n因为上面我们是自定义服务端，所以我们可以在服务端识别到动态路由时把他转化为`/xx?id=id`的query路由地址即可:\n\n```ts\n// config.ts\nconst routerArray: IRoute[] = [\n  {\n    name: \'首页\',\n    path: \'\',\n    key: \'index\',\n    page: \'/blog\'\n  }\n  {\n    name: \'详情\',\n    path: \'/post/:id\',\n    key: \'post\',\n    page: \'/post\'\n  }\n  {\n    name: \'分类列表\',\n    path: \'/tagList/:key\',\n    key: \'tagList\',\n    page: \'/tagList\'\n  }\n]\nimport * as KoaRouter from \'koa-router\';\nimport routerArray from \'./config\';\n\nconst router = new KoaRouter()\n\nfunction getRoute(handle: any): KoaRouter {\n  routerArray.forEach(routeObject => {\n    const { path: routePath, page } = routeObject\n    // next.js不支持 /xx/:id这样子的路由路径\n    // 只支持/xx?id=id这样子的路径\n    // 所以我们在koa服务端这边做处理\n    router.get(routePath, async ctx => {\n      const { req, res, params, path } = ctx\n      await handle(req, res, {\n        pathname: page || path,\n        query: params\n      })\n      ctx.respond = false\n    })\n  })\n  return router\n}\nexport default getRoute\n\n```\n\n## 接口代理\n\n自定义服务器使得接口代理十分简单，因为我使用的是koa 引入`koa2-proxy-middleware`这个中间件即可。\n\n```ts\nimport * as Koa2ProxyMiddleware from \"koa2-proxy-middleware\";\nconst options: Koa2ProxyMiddleware.Koa2ProxyMiddlewareConfig = {\n  targets: {\n    \'/api/(.*)\': {\n      // this is option of http-proxy-middleware\n      target: \'https://xxx\', // target host\n      changeOrigin: true\n    }\n  }\n}\n\nexport default Koa2ProxyMiddleware(options)\n\n// index.ts\nserver.use(proxyMiddleware)\n```\n\n## getInitialProps使用redux\n\n其实redux的集成其实已经有很多资料讲述了用法，我这边不在进行赘述；只是在使用redux的过程中出现可一个问题：页面中的数据是在componentDidMount中获取然后dispatch到redux中，页面获取数据是通过redux获取的，而不是在传入的props中。因此在服务端渲染的时候getInitialProps中如何获取到store然后dispatch完数据之后通过注水的方式让页面在客户端就能拿到已经填充好数据的store就是下面要解决的问题所在。\n\n### 高阶函数withReduxHoc\n\n通过一个高阶函数withReduxHoc，我们可以自定义`_app.tsx`在高阶函数初始化的时候创建一个新的reduxStore。然后获取页面page组件的getInitialProps函数，把当前的reduxStore也注入进去。\n\n```js\nexport default function withReduxHoc(AppComponent) {\n  class WithReduxApp extends React.Component {\n    constructor (props) {\n      super(props)\n      this.reduxStore = getOrCreateStore(props.initialReduxState)\n    }\n\n    render () {\n      const { Component, pageProps, ...rest } = this.props\n      return (\n        <AppComponent\n          {...rest}\n          Component={Component}\n          pageProps={pageProps}\n          reduxStore={this.reduxStore}\n        />\n      )\n    }\n  }\n\n  WithReduxApp.getInitialProps = async (ctx) => {\n    // 初始化store\n\n    let reduxStore  = getOrCreateStore()\n\n    // 注入store\n    ctx.reduxStore = reduxStore\n\n    let appProps = {}\n    //@ts-ignore\n    if (isFunction(AppComponent.getInitialProps)) {\n      //@ts-ignore\n      appProps = await AppComponent.getInitialProps(ctx)\n      // 获取页面组件的getInitialProps函数并且注入store，因此在页面组件的getInitialProps的ctx参数中就可以获取store\n    }\n\n    // 页面组件dispatch完更新store数据之后 在这里获取数据进行注水\n    return {\n      ...appProps,\n      initialReduxState: reduxStore.getState()\n    }\n  }\n  return WithReduxApp\n}\n```\n\n在页面组件的getInitialProps函数中就可以获取到传入的store，在获取完数据之后调用store的dispatch方法更新store数据。\n\n```ts\nHome.getInitialProps = async (context: GetInitialPropsContext) => {\n  const {reduxStore} = context\n  let pageNum = 1\n  let hasMore = true\n  let list: ArticleListItem[]\n  const {data} = await getArticleList({\n    pageNum,\n    pageSize: 5\n  })\n  if (data.totalPage <= pageNum) {\n    hasMore = false\n  }\n  pageNum += 1\n  list = data.list\n  reduxStore.dispatch(updArticle(list))\n  return {\n    serverSucceed: true,\n    serverPageNum: pageNum,\n    serverHasMore: hasMore,\n    serverList: list\n  }\n\n}\n\n```', 1, 'nodeJs,typescript', '博客前端的ssr重构之旅', 1, '2020-06-18 18:06:36', '2021-01-27 23:16:44', NULL, 'http://img.carrotwu.com/FkEeVbd8a7f2fJXnlpCBgvmBaY65', NULL);
INSERT INTO `article` VALUES (36, '最近公司打算自研一套类似于百度统计以及腾讯mta类似的数据上报系统，我这边负责了客户端的上报sdk部分工作。接下来记录一下开发sdk时的相关要点。', 5, '> 最近公司打算自研一套类似于百度统计以及腾讯mta类似的数据上报系统，我这边负责了客户端的上报sdk部分工作。接下来记录一下开发sdk时的相关要点。\n\n\n以下是sdk支持上报的数据功能要点\n\n## 页面浏览监控（PV/UV）\n数据上报系统必不能少的就是页面数据PV/UV的监控，对于多页面来说我们可以监听`DOMContentLoaded`事件来进行上报数据（这里不再进行赘述），麻烦的是单页面（react，vue，ng）通过模拟路由修改不刷新页面的数据上报。如今绝大部分单页面的路由都是通过history或者hash这两种方式来进行路由切换，我们可以通过改写的方式来劫持相关事件就可以在路由跳转的时候进行数据上报。\n\n### hash路由\n对于hash路由，当路由发生变化的时候触发`onhashchange`事件，因此我们只需要重写`onhashchange`事件并且重写相关的上报逻辑即可。注意的是要保留原始的hashchange方法并且在最后记得调用返回即可.\n\n```ts\nexport function rewriteOnHashChange() {\n  // 保留原有的hashchange方法\n  const originEventName = rewriteNameMap.onhashchange;\n  if (!window[originEventName]) {\n    window[originEventName] = window.onhashchange;\n  }\n  const originHashChange = isFunction(window[originEventName]) ? window[originEventName] : noop;\n  window.onhashchange = function (event: HashChangeEvent) {\n    // hash模式直接获取hash即可\n    const formatUrl = parseUrl(event.newURL);\n    const path = parseHashUrl(formatUrl.hash) || window.location.pathname;\n    dispatchCustomEvent(\'hashStateChanged\', {\n      path,\n    });\n    return originHashChange.call(this, event);\n  };\n}\n```\n\n### history路由\n跟hash路由相类似，history路由也有一个`onpopstate`事件用来监听路由修改。不过要注意以下几点:\n\n1. popstate事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮(或者在JavaScript中调用history.back()、history.forward()、history.go()方法)\n2. 调用history.pushState()或者history.replaceState()不会触发popstate事件.\n3. 对于a标签的跳转也不会触发popstate事件，对于react-router或者vue-router的单页面路由来说，它们是用过阻止a链接的默认事件手动触发相对应的pushState事件或者replaceState事件。\n4. 当网页加载时,各浏览器对popstate事件是否触发有不同的表现,Chrome 和 Safari会触发popstate事件, 而Firefox不会.\n\n因此，我们不仅仅要劫持onpopstate事件，同时也需要劫持pushState和replaceState事件。对于a标签的跳转，因为类似于vue-router的框架内部出发了pushState事件，不在需要监听a标签的事件。\n\n```ts\n/**\n * 重写statechange事件\n * 注意的是 因为history模式可能为hash 所以需要优先判断hash\n */\nexport function rewriteOnPopState() {\n  // 保留原有的state方法\n  const originEventName = rewriteNameMap.onpopstate;\n  if (!window[originEventName]) {\n    window[originEventName] = window.onpopstate;\n  }\n  const originPopState = window[originEventName];\n  window.onpopstate = function (event: PopStateEvent) {\n    // 优先获取hash的地址 不然的话在获取pathname的地址 因为有可能history模式使用的是hash模式\n    const path = parseHashUrl(window.location.hash) || window.location.pathname;\n    dispatchCustomEvent(\'historyStateChanged\', {\n      path,\n    });\n    return isFunction(originPopState) && originPopState.call(this, event);\n  };\n}\n\n/**\n * 重写history replaceState 和 pushState事件\n * @param event\n */\nexport function rewriteHistoryState(event: \'pushState\' | \'replaceState\') {\n  const originEventName = rewriteNameMap[event];\n  // @ts-ignore\n  if (!window.history[originEventName]) {\n    // @ts-ignore\n    window.history[originEventName] = window.history[event];\n  }\n  // @ts-ignore\n  const originHistoryEvent = window.history[originEventName];\n  if (isFunction(originHistoryEvent)) {\n    window.history[event] = function (...historyArguments) {\n      const { href } = window.location;\n      const [, , url] = historyArguments;\n      // 执行原来的history方法\n      const originReturns = originHistoryEvent.apply(window.history, historyArguments);\n      // 如果跳转的是原地址 或者地址不是字符串 或者跳转地址等于当前地址 那么直接返回不进行相关的上报操作\n      // 都认为是在当前页面\n      if (!url || !isString(url) || url === href) {\n        return originReturns;\n      }\n      // 格式化的url格式\n      const formatHref = parseUrl(href);\n      const formatUrl = parseUrl(url);\n\n      // 获取hash 有时候浏览器支持history模式 就算用的是hash也会以history模式为准\n      const hrefHash = parseHashUrl(formatHref.hash);\n      const urlHash = parseHashUrl(formatUrl.hash);\n      // 跳转pathName不同的时候才进行historyStateChange事件派发\n      if (formatHref.pathname !== formatUrl.pathname) {\n        dispatchCustomEvent(\'historyStateChanged\', {\n          path: formatUrl.pathname,\n        });\n      } else if (hrefHash && urlHash && hrefHash !== urlHash) {\n        // 有时候浏览器支持history模式 就算用的是hash也会以history模式为准\n        dispatchCustomEvent(\'historyStateChanged\', {\n          path: urlHash,\n        });\n      }\n      return originReturns;\n    };\n  }\n}\n```\n**需要注意的是，在vue-router中只要浏览器支持history，即使你手动设置的是hash路由，vue-router内部会使用history api来模拟实现hash路由。所以需要在改写history路由时需要判断当前路由模式使用的是hash路由**\n\n\n## 错误上报\n\n老生常谈的东西-错误上报，在论坛或者掘金上已经有非常多非常棒的文章博客详细的研究过相对应的实现方式，这里我就不再进行赘述了。在项目中，对于全局的异常或者静态资源错误可以监听**error事件即可**，注意的是要判断具体是属于哪种错误。对于没有捕获的promise异常，监听**unhandledrejection**事件即可。\n\n### CSS背景图片的错误上报(background)\n在查找资源的过程中，对于css背景图片的资源错误处理根本找不到= =。对于背景图片的加载错误根本没法通过任何事件去捕获，难道就没有办法上报背景图片的加载错误吗？答案是可行的，我发现可以通过一种比较hack的方式来监听背景图片的错误事件。\n\n大概思路如下：\n1. 在页面加载完整之后，通过遍历dom数获取**backgroundImage**属性中的**url图片地址**\n2. 手动实例化image元素，监听上面获取到的图片地址是否触发error事件即可\n\n但是上面的思路对于静态页面来说是可行的，因为dom树不会再发生变化。但是对于vue和react这种动态渲染节点的框架来说，dom节点内容是动态的，背景图片的加载并不是一开始就初始化的。所以我们需要做到能够监听某个节点元素是否发生了变化，发生变化的时候重新遍历节点树背景图片的url地址。**MutationObserver**恰好可以用来监听元素节点的变化。\n\n#### MutationObserver\n以下内容摘自mdn:\nMutationObserver接口提供了监视对DOM树所做更改的能力。它被设计为旧的Mutation Events功能的替代品，该功能是DOM3 Events规范的一部分。\n\n```js\n// 选择需要观察变动的节点\nconst targetNode = document.getElementById(\'some-id\');\n\n// 观察器的配置（需要观察什么变动）\nconst config = { attributes: true, childList: true, subtree: true };\n\n// 当观察到变动时执行的回调函数\nconst callback = function(mutationsList, observer) {\n    // Use traditional \'for loops\' for IE 11\n    for(let mutation of mutationsList) {\n        if (mutation.type === \'childList\') {\n            console.log(\'A child node has been added or removed.\');\n        }\n        else if (mutation.type === \'attributes\') {\n            console.log(\'The \' + mutation.attributeName + \' attribute was modified.\');\n        }\n    }\n};\n\n// 创建一个观察器实例并传入回调函数\nconst observer = new MutationObserver(callback);\n\n// 以上述配置开始观察目标节点\nobserver.observe(targetNode, config);\n\n// 之后，可停止观察\nobserver.disconnect();\n```\n\n#### 实现\n1. 通过MutationObserver监听根节点元素是否变化，变化的时候重新遍历收集元素的backgroundImage属性中的图片url地址\n2. 手动实例化Image实例，监听图片是否加载失败上报即可。\n\n```ts\n// 用于处理背景图片错误时无法被捕获的事件\nexport function handleBackgroundError() {\n  if (!MutationObserver) {\n    return;\n  }\n  const { rootName } = getStoreVal();\n  const cacheImageMap: { [k: string]: string } = {};\n  // 选择需要观察变动的节点\n  const targetNode = document.querySelector(rootName);\n  // 观察器的配置（需要观察什么变动）\n  const config = { childList: true, subtree: true };\n\n  // 通过mutationObserve的dom变化来重新收集backgroundImage\n  const observer = new MutationObserver(() => {\n    try {\n      const imageArray = getElementBackgroundImage(targetNode!);\n      if (Array.isArray(imageArray) && imageArray.length) {\n        imageArray.forEach((imageUrl) => {\n          if (!cacheImageMap[imageUrl]) {\n            cacheImageMap[imageUrl] = imageUrl;\n            // 创建image元素\n            const img = new Image();\n            // @ts-ignore\n            img.onerror = sendResourceError;\n            img.src = imageUrl;\n          }\n        });\n      }\n    } catch (e) {\n      console.warn(\'mutation observe error\');\n    }\n  });\n  observer.observe(targetNode!, config);\n}\n\n/**\n * 获取元素节点的背景图片地址\n * @param ele\n * @param cacheArray\n */\nexport function getCurrentElementBackgroundImage(ele: Element, cacheArray?: string[]) {\n  const backgroundImageArray: string[] = isArray(cacheArray) ? cacheArray : [];\n  const style = window.getComputedStyle(ele);\n  if (!style || !style.backgroundImage) {\n    return;\n  }\n  // 获取图片链接\n  const reURL = /url\\(([\'\"])?(.*?)\\1\\)/gi;\n  let matches = reURL.exec(style.backgroundImage);\n  while (matches !== null) {\n    const url = matches && matches[2];\n    if (url) {\n      backgroundImageArray.push(url);\n    }\n    matches = reURL.exec(style.backgroundImage);\n  }\n  return backgroundImageArray;\n}\n\nexport function getElementBackgroundImage(ele?: Element) {\n  const element = ele || document.querySelector(\'body\');\n  const imageArray = getCurrentElementBackgroundImage(element!);\n  const children = element!.querySelectorAll(\'*\');\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    getCurrentElementBackgroundImage(child, imageArray);\n  }\n  return imageArray;\n}\n```\n\n## 页面性能监控\n\n页面性能监控也是老生常谈了，网上也已经有大量的最佳实践。本质上都是原生的**PerformanceNavigationTiming** api来进行性能监控。注意的是**performance.timing**是早期第一版api，兼容性更好不过精度不高不太准，更推荐使用第二版的api**PerformanceNavigationTiming**（记得做好优雅降级哦）。具体的性能时间看下面这张图就ok啦。\n\n![alt](http://img.carrotwu.com/FuLBd2-DExvitxHMEKnIg88nxejK)\n\n具体的数据字典如下\n```ts\n// 页面性能数据字典\nexport const performanceDataMap: PerformanceDataMap = {\n  // 阶段性指标\n  dns: {\n    arg: [\'domainLookupEnd\', \'domainLookupStart\'],\n    info: \'DNS查询耗时\',\n  },\n  tcp: {\n    arg: [\'connectEnd\', \'connectStart\'],\n    info: \'TCP链接耗时\',\n  },\n  response: {\n    arg: [\'responseEnd\', \'responseStart\'],\n    info: \'数据传输耗时\',\n  },\n  ttfb: {\n    arg: [\'responseStart\', \'requestStart\'],\n    info: \'Time to First Byte（TTFB），网络请求耗时\',\n  },\n  dom: {\n    arg: [\'domInteractive\', \'responseEnd\'],\n    info: \'可交互 DOM 解析耗时\',\n  },\n  dom2: {\n    arg: [\'domContentLoadedEventStart\', \'domInteractive\'],\n    info: \'剩余 DOM 解析耗时(DOMContentLoaded 所有DOM元素都加载完毕(除了 async script))\',\n  },\n  appCache: {\n    arg: [\'domainLookupStart\', \'fetchStart\'],\n    info: \'缓存耗时\',\n  },\n  redirect: {\n    arg: [\'redirectEnd\', \'redirectStart\'],\n    info: \'重定向耗时(过多重定向影响性能)\',\n  },\n  unload: {\n    arg: [\'unloadEventEnd\', \'unloadEventStart\'],\n    info: \'前一个页面卸载耗时(前一个页面卸载时可能监听了 unload 做些数据收集，会影响页面跳转)\',\n  },\n  DCL: {\n    arg: [\'domContentLoadedEventEnd\', \'domContentLoadedEventStart\'],\n    info: \"DOMContentLoaded 事件耗时(document.addEventListener(\'DOMContentLoaded\', cb))\",\n  },\n  resources: {\n    arg: [\'loadEventStart\', \'domContentLoadedEventEnd\'],\n    info: \'资源加载耗时(完整DOM(DOMContentLoaded)到资源加载完毕(window.onLoad)时间)\',\n  },\n  onLoad: {\n    arg: [\'loadEventEnd\', \'loadEventStart\'],\n    info: \'onLoad事件耗时\',\n  },\n  firstByte: {\n    arg: [\'responseStart\', \'domainLookupStart\'],\n    info: \'首包时间\',\n  },\n  fpt: {\n    arg: [\'responseEnd\', \'fetchStart\'],\n    info: \'First Paint Time, 首次渲染时间 / 白屏时间(从请求开始到浏览器开始解析第一批 HTML 文档字节的时间差)\',\n  },\n  tti: {\n    arg: [\'domInteractive\', \'fetchStart\'],\n    info: \'Time to Interact，首次可交互时间(浏览器完成所有 HTML 解析并且完成 DOM 构建，此时浏览器开始加载资源)\',\n  },\n  ready: {\n    arg: [\'domContentLoadedEventEnd\', \'fetchStart\'],\n    info: \'HTML 加载完成时间， 即 DOM Ready 时间(如果页面有同步执行的 JS，则同步 JS 执行时间 = ready - tti)\',\n  },\n  load: {\n    arg: [\'loadEventStart\', \'fetchStart\'],\n    info: \'页面完全加载时间(load = 首次渲染时间 + DOM 解析耗时 + 同步 JS 执行 + 资源加载耗时)\',\n  },\n};\n\n```', 1, 'javascript', '如何自研编写简单的数据上报系统sdk', 1, '2020-11-06 09:53:43', '2021-01-27 14:20:15', NULL, 'http://img.carrotwu.com/FsC3gOIBpDc6DkTZs0gkx49QjmJ5', NULL);
INSERT INTO `article` VALUES (37, '此文章来源于程序员成长指北公众号《彻底搞懂 Node.js 中的 Require 机制(源码分析到手写实践)》。加入了我自己的一些理解，感谢大佬的文章。', 6, '\n# 深入浅出nodejs中require函数\n>此文章来源于程序员成长指北公众号[《彻底搞懂 Node.js 中的 Require 机制(源码分析到手写实践)》](https://mp.weixin.qq.com/s?__biz=MzUxNzk1MjQ0Ng==&mid=2247487495&idx=1&sn=ce013f9f48a9df73ce5aeb8ef208c82a&chksm=f99116d6cee69fc075aa060821786add29e588dff709553cffec79e1a71d3df5a5a0bd77c193&scene=178&cur_album_id=1529105963545313281#rd)。加入了我自己的一些理解，感谢大佬的文章。\n\n## 开篇问题\n1. require 函数是如何产生的？为什么在 module 中可以直接使用。\n2. require 加载原生模块时候如何处理的，为什么 require(\'net\') 可以直接找到\n3. Node.js 中 require 会出现循环引用问题吗？\n4. require 是同步还是异步的？为什么？\n5. exports 和 module.exports 的区别是什么？\n6. 你知道 require 加载的过程中使用了 vm 模块吗？vm 模块是做什么的？vm 模块除了 require 源码用到还有哪些应用场景。\n\n## CommonJS\n众所周知nodeJs是基于commonjs，在commonjs中每一个文件对应一个模块。在模块内部中，我们可以通过require来引入其他模块，也可以通过module.export和export来向外导出其他某块。\nCommonJS 规范规定，每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。\n\n1. require 函数是如何产生的？为什么在 module 中可以直接使用？为什么可以再模块中直接使用**exprort，require，module.exports，__dirname这些变量**。\n2. require 加载原生模块时候如何处理的，为什么 require(\'net\') 可以直接找到\n3. Node.js 中 require 会出现循环引用问题吗？\n4. Node.js 中 require 会出现循环引用问题吗？\n5. require 是同步还是异步的？为什么？\n6. exports 和 module.exports 的区别是什么？\n7. 你知道 require 加载的过程中使用了 vm 模块吗？vm 模块是做什么的？vm 模块除了 require 源码用到还有哪些应用场景。\n\n## require实现\n>一下内容大部分从[彻底搞懂 Node.js 中的 Require 机制(源码分析到手写实践)]截取而来，后续会加上一些我自己的理解\n\n### module类\n上文说过，在nodejs中一个文件对应一个module实例，接下来我们实现一个简单的module类\n```js\nfunction KoalaModule(id = \'\') {\n  this.id = id;       // 这个id其实就是我们require的路径\n  this.path = path.dirname(id);     // path是Node.js内置模块，用它来获取传入参数对应的文件夹路径\n  this.exports = {};        // 导出的东西放这里，初始化为空对象\n  this.filename = null;     // 模块对应的文件名\n  this.loaded = false;      // loaded用来标识当前模块是否已经加载\n}\n\nKoalaModule._cache = Object.create(null); //创建一个空的缓存对象\nKoalaModule._extensions = Object.create(null); // 创建一个空的扩展点名类型函数对象(后面会知道用来做什么)\n```\n值的注意的是，在module类中我们保留了**路径（path），模块导出对象(exports)，还有一个用于缓存已加载模块的空对象**\n\n### require源码\n在源码中你会找到 require 函数,在 KoalaModule 的原型链上，我们实现下。真正执行的require函数其实是在module的静态函数上。\n\n```js\nModule.prototype.require = function(id) {\n    return Module._load(id, this, /* isMain */ false);\n};\n\nKoalaModule._load = function (request) {    // request是我们传入的路劲参数\n  // 2.路径分析并定位到文件\n  const filename = KoalaModule._resolveFilename(request);\n\n  // 3.判断模块是否加载过(缓存判断)\n  const cachedModule = koalaModule._cache[filename];\n  if (cachedModule !== undefined) {\n    return cachedModule.exports;\n  }\n  // 4. 去加载 node 原生模块中\n  /*const mod = loadNativeModule(filename, request);\n   if (mod && mod.canBeRequiredByUsers) return mod.exports;*/\n   \n  // 5. 如果缓存不存在，我们需自行加载模块，new 一个 KoalaModule实例\n  // 加载完成直接返回module.exports\n  const module = new KoalaModule(filename);\n\n  // 6. load加载之前加入缓存，这也是不会造成循环引用问题的原因，但是循环引用，这个缓存里面的exports可能还没有或者不完整\n  KoalaModule._cache[filename] = module;\n  // 7. module.load 真正的去加载代码\n  module.load(filename);\n  // 8. 返回模块的module.exports \n  return module.exports;\n}\n```\n\n从上面得出，执行require函数的时候大致会执行这么个流程：\n\n1.根据传入的路径获取模块文件的模块名以及模块地址\n2. 判断模块是否已经加载过，根据上面创建的缓存空对象进行判断。有缓存的话直接返回缓存的模块，直接退出。\n3. 从node原生模块开始进行查找（path，fs等等），没有的话确定是第三方模块（一般认为node_modules模块）\n4. 先创建一个module实例，注意这时候的module实例只有路径和文件名字内部exports对象还是空的\n5. 在真正的加载对应的模块之前，先把当前空的模块实例进行缓存。这样子就解决了循环引用的问题（a引用b，a其实已经缓存了哪怕这时候b引用a直接返回缓存的a模块，不再会进行真正的模块引用）\n6. 通过module.load真正的去加载模块代码\n7. 返回当前模块（注意的是这时候返回的其实是module.exports， 所以这时候导出的其实是module.exports的引用。后面会解析module.exports和exports的区别）\n\n#### 路径分析并定位到文件\n找到源码中的 _resolveFilename 函数，这个方法是通过用户传入的require参数来解析到真正的文件地址。(源码地址：https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js#L816)\n\n这个函数源码中比较复杂，因为 require传递过来的值需要一层一层的判断，同时支持多种参数：内置模块，相对路径，绝对路径，文件夹和第三方模块等等，如果是文件夹或者第三方模块还要解析里面的 package.json 和 index.js。这里简单处理，只实现通过相对路径和绝对路径来查找文件，并支持判断文件js和json后缀名判断:\n\n```js\nKoalaModule._resolveFilename = function (request) {\n  const filename = path.resolve(request);   // 获取传入参数对应的绝对路径\n  const extname = path.extname(request);    // 获取文件后缀名\n  // 如果没有文件后缀名，判断是否可以添加.js和.json\n  if (!extname) {\n    const exts = Object.keys(KoalaModule._extensions);\n    for (let i = 0; i < exts.length; i++) {\n      const currentPath = `${filename}${exts[i]}`;\n\n      // 如果拼接后的文件存在，返回拼接的路径\n      if (fs.existsSync(currentPath)) {\n        return currentPath;\n      }\n    }\n  }\n  return filename;\n}\n```\n\n#### 判断模块是否加载过(缓存判断)\n\n判断这个找到的模块文件是否缓存过，如果缓存过，直接返回 cachedModule.exports, 这里就会想到一个问题为什么在 Node.js 中模块重复引用也不会又性能问题，因为做了缓存。(源码位置：https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js#L747)\n```js\n  const cachedModule = koalaModule._cache[filename];\n  if (cachedModule !== undefined) {\n    return cachedModule.exports;\n  }\n```\n\n#### 去加载 node 原生模块\n> 说实话我没看懂，因为涉及到c++的内容所以需要跟深入的了解可以查看原作者的文章。\n\n结论：Node.js 在启动时候直接从内存中读取内容，我们通过 require 加载 net 原生模块时，通过 NativeModule的compileForInternalLoader，最终会在 _source 中找到对应的源码字符串，然后编译成一个函数，然后去执行这个函数,执行函数的时候传递 nativeModuleRequire和internalBinding两个函数，nativeModuleRequire用于加载原生 js 模块，internalBinding用于加载纯C++ 编写的内置模块。\n\n#### 创建一个 KoalaModule 实例\n如果不是原生 node 模块，就会当作普通文件模块加载，自己创建一个 KoalaModule 实例，去完成加载。\n```js\n const module = new KoalaModule(filename);\n```\n\n#### 添加缓存\n\n我把这一小步骤单独提出的原因，想说明的是先进行缓存的添加，然后进行的模块代码的加载，这样就会出现下面的结论，Node.js 官网也有单独介绍,可以自己试一下。\n\n1. main 加载a，a 在真正加载前先去缓存中占一个位置\n2. a 在正式加载时加载了 b\n3. b 又去加载了 a，这时候缓存中已经有 a 了，所以直接返回 a.exports，这时候 exports 很有可能是不完整的内容。\n\n如果放在代码模块加载完成之后才进行缓存，那么就会出现：a加载b的时候a还没有缓存，所以这时候b又加载a就会导致又重新去加载a模块，这就导致了循环引用。\n\n总结：**缓存不仅仅用来重复加载模块的性能以及速度，同时起到了防止循环应用的问题**\n\n#### 加载模块\n\n>module实例在加载模块时对应不同的文件后缀会使用不同的加载方法，接下来将直接介绍js的加载方法.\n\n定位到加载 .js 的源码位置(https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js#L1092)\n\n```js\nKoalaModule._extensions[\'.js\'] = function (module, filename) {\n  const content = fs.readFileSync(filename, \'utf8\');\n  module._compile(content, filename);\n}\n```\nKoalaModule._extensions 中 _compile 函数的执行。找到对应的源码位置(https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js#L1037)，源码中这里还使用 proxy，我们进行一下简单实现。\n\n```js\nKoalaModule.wrapper = [\n  \'(function (exports, require, module, __filename, __dirname) { \',\n  \'\\n});\'\n];\n\nKoalaModule.wrap = function (script) {\n  return KoalaModule.wrapper[0] + script + KoalaModule.wrapper[1];\n};\n\nKoalaModule.prototype._compile = function (content, filename) {\n  const wrapper = KoalaModule.wrap(content);    // 获取包装后函数体\n\n  // vm是 Node.js 的虚拟机模块，runInThisContext方法可以接受一个字符串并将它转化为一个函数\n  // 返回值就是转化后的函数，compiledWrapper是一个函数\n  const compiledWrapper = vm.runInThisContext(wrapper, {\n    filename,\n    lineOffset: 0,\n    displayErrors: true,\n  });\n  const dirname = path.dirname(filename);\n  // 调用函数，这里一定注意传递进的内容。\n  compiledWrapper.call(this.exports, this.require, this,\n    filename, dirname);\n}\n```\n这里注意两个地方\n- 使用 vm 进行模块代码的执行，模块代码外面进行了一层包裹,以便注入一些变量。(类似于webpack的require，其实也是通过包裹成一个立即执行函数行程模块)\n\n```js\n\'(function (exports, require, module, __filename, __dirname) { \',\n  \'\\n});\'\n```\n\n- 最终执行代码的函数传递的参数\n1. this: compiledWrapper函数是通过 call 调用的，第一个参数就是里面的this，这里我们传入的是 this.exports，也就是 module.exports,也就是加载的模块对象。\n2. exports: compiledWrapper 函数正式接收的第一个参数是 exports，我们传的也是 this.exports,所以 js 文件里面的 exports 也是对module.exports 的一个引用。\n3. require: 这个方法我们传的是 this.require，其实就是KoalaModule.prototype.require 函数，也就是 KoalaModule._load。\n4. module: 我们传入的是 this，也就是当前模块的实例。\n5. __filename：文件所在的绝对路径。\n6. __dirname: 文件所在文件夹的绝对路径。\n以上两点也是我们能在 JS 模块文件里面直接使用这几个变量的原因。\n\n## 解答疑惑\n回到上面的问题就不难得出答案了：\n1. require 函数是如何产生的？为什么在 module 中可以直接使用。\nrequire 到的文件，在 vm 模块最终执行的时，对代码进行了一层包裹，并且把对应的参数传递进去执行。\n```js\n`(function (exports, require, module, __filename, __dirname) { ${script} \\n});`\n```\n在node.js中能够直接使用的比如require,exports,module.exports都是在模块加载时通过重新参数参数的变量。其中require指向的是Module类的load方法。\nexports和module.exports指向的是同一个引用。\n\n\n2. require 加载原生模块时候如何处理的，为什么 require(\'net\') 可以直接找到.\nrequire在加载模块的时候会尝试给没有后缀的路径加载后缀并且require在加载模块的时候顺序如下：\n- 是否有缓存\n- 是否原生模块（）\n- 是否当前项目模块\n- 是否第三方模块\n\n3. Node.js 中 require 会出现循环引用问题吗？\n不会，因为在真正加载模块之前，会实例化一个当前模块的module实例加入缓存中，循环引用的时候会直接返回缓存中的模块\n\n4. require 是同步还是异步的？为什么？\n\n同步的，因为require函数使用的都是sync函数\n\n5. exports 和 module.exports 的区别是什么？\n\n**exports和module.exports指向的是同一个引用。nodejs中模块最终导出的是module.exports，exports只是一个变量保存了modules.exports的引用。最终导出的内容都是modules.exports**\n```js\nexports === modules.exports // true\n// 可行\nexports.a = a\n// 没用 只是改变了当前exports变量的指针地址 最终导出的module.exports还是空对象\nexports = {a,b}\n\n// 有用 直接修改module.exports的指针\nmodule.exports = {a,b}\n\n// 有用 直接修改指针上的变量\nmodule.exports.a = a\n```', 0, 'nodeJs', '深入浅出nodejs中require函数', 1, '2020-11-12 16:50:12', '2021-01-05 18:06:06', NULL, 'http://img.carrotwu.com/Fml-7N2Z4uJEH_lPBeo0ElkYqQ1S', NULL);
INSERT INTO `article` VALUES (38, '因为工作需要，近期编写了一个能够检测react项目中render函数是否有遗留合并冲突的babel插件，这里做下相关笔记。', 40, '> 因为工作需要，近期编写了一个能够检测react项目中render函数是否有遗留合并冲突的babel插件，这里做下相关笔记。\n\n## 前言\n上个星期隔壁项目组上线的时候发现在合并代码的时候，没有处理完合并冲突直接上线导致线上页面中出现了`============`, `>>>>>>>>>>>`等遗留下来的冲突代码。虽说测试即使发现了并且及时回滚修复了。\n\n但是身为一个合格工程师应该额外思考的是如何规避这种合并冲突的情况，能不能通过某种手段来检测代码中是否存在没有解决完的合并冲突代码。\n\n## 思路\n\n问题出现的原因是在分支合并到master分支时出现的，虽说借助于idea或者一些可视化工具基本能够避免这种问题的发生，但是在gitlab上的手动合并还是十分常见。尤其是我们项目接上了自动部署，代码合并完成之后就会自动进行打包部署。严格上来说代码合并产生冲突不管怎么操作都是会有机会产生的。\n\n我的思路是能不能在项目生产打包阶段，识别出代码中存在类似于`============`, `>>>>>>>>>>>`合并冲突的代码的时候停止打包并且进行相关推送。这样子的话我们只检测生产环境的打包阶段就可以做到上述问题的解决。\n\n我们目前的项目都是基于react或者vue进行开发的，这两者的代码都需要经过babel编译成ast语法树，再经由一些变化操作最后才会生成我们最终打包出来的代码。**因此我们可以在babel编译ast语法树阶段对于ast语法树进行判断是否存在正则相关阶段的判断即可**\n\n\n### 哪些需要检测\n\n#### js代码混杂合并冲突代码\n\n以react项目为例子分析，对于js中的代码来说出现`============`, `>>>>>>>>>>>`混入这种分支合并冲突的代码必定会打包失败，因为js语法不通过，所以我们并不需要检测项目中的js逻辑代码。\n\n![alt](http://img.carrotwu.com/FkpVsZfiohRLa3V8b2LWQkx16d6e)\n\n#### 模板混杂合并冲突代码\n\n但是react或者vue模板(template以及render)中的合并冲突代码类似于下面的代码，会直接认为是html模板字符串所以打包编译是可以进行通过的。事实上上面生成出现合并冲突代码就是发生在渲染模板中。**所以本质上我们只需要检测渲染模板中的合并冲突代码即可**\n\n![alt](http://img.carrotwu.com/FhRHIjWR2Smqy-tOP5IAA9tQXq22)\n\n### 如何进行检测\n前面说了，我司的项目都是需要经过babel进行编译打包生成最终的源码，因为我们可以在babel生成ast语法树阶段。对语法树进行判断渲染模板中是否出现了类似的合并冲突代码即可。\n\n## AST语法树\n\n### AST是什么\n抽象语法树 (Abstract Syntax Tree)，简称 AST，它是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。\n\n### 使用场景\n\n1. JS 反编译，语法解析\n2. Babel 编译 ES6 语法\n3. 代码高亮\n4. 关键字匹配\n5. 作用域判断\n6. 代码压缩\n\n### AST语法树的生成\n\n社区已经有很多文章详细讲述了ast语法树的生成，这边不在进行赘述。其中注意的是有两个网站会大量使用：\n\n1. [可视化生成Ast在线网站astexplorer](https://astexplorer.net/):查看编译之后的js代码\n2. [babel代码编译在线网站](https://babeljs.io/repl):查看js代码编译成啥样的ast语法树\n\n\n## 解决方案\n\n1. 编写webpack插件监听打包阶段的钩子，手动对文件进行ast语法树的构建在进行相关的分析。（方案不可行，强行进行两次ast语法树的生成。打包阶段本身就会使用babel对代码进行一次ast语法树的构建）\n2. 编写babel插件（可行，在babel编译阶段通过一些钩子来进行判断，不用写webpack插件不用手动再次生成ast语法树）\n\n\n## babel插件编写\n\n\n首先我们应该看我们的 React 元素是怎么创建出来的：\n\n```js\nimport React from \'react\';\n\nfunction App() {\n  return <h1>Hello World</h1>;\n}\n```\nrender中jsx代码会被编译成`React.createElement`语法，具体使用方法可以看官网\n\n```js\nimport React from \'react\';\n\nfunction App() {\n  return React.createElement(\'h1\', null, \'Hello world\');\n}\n\n```\n那么这段js代码会生成什么样子的ast代码呢，我们把这段代贴到`https://astexplorer.net/`上:\n\n![alt](http://img.carrotwu.com/Fo5gHVISjAlWXwB6dVsFMrt7Zp7s)\n\n### 具体思路\n1. ast语法树中，我们可以通过visitors的`CallExpression`来访问所有的函数调用（这样子就进入了react.createElement函数）\n```ts\nexport default function ({ types }: typeof BabelCore): PluginObj {\n  return {\n    visitors: {\n      CallExpression(path) {\n          //进入所有的函数调用 这样子就进入了react,createElement的访问\n      },\n    },\n  };\n}\n```\n\n2. 接下来判断调用者对象是`React`，调用者方法是`createElement`\n```ts\nexport default function ({ types }: typeof BabelCore): PluginObj {\n  return {\n    visitors: {\n      CallExpression(path) {\n        if (\n          !(\n            isMemberExpression(callee) &&\n            // 调用者是一个对象\n            isIdentifier(callee.object) &&\n            // 调用者主题为React\n            callee.object.name === \'React\' &&\n            isIdentifier(callee.property) &&\n            // 调用方法是createElement\n            callee.property.name === \'createElement\'\n          )\n        ) {\n          return;\n        }\n      },\n    },\n  };\n}\n```\n\n3. 可以发现`children`模板是这个 CallExpression 的 arguments 属性数组的第三个元素及以上。我们只需要获取argument中的children元素，并且判断是否属于`isStringLiteral`字符串类型，是的话我们只需要判断模板字符串是否存在合并冲突类型的代码即可  \n\n```ts\nconst [, , ...childrenArray] = path.node.arguments;\nconst stringLiteralChildArray: string[] = childrenArray\n    .filter((children) => types.isStringLiteral(children))\n    // @ts-ignore\n    .map((child) => child.value);\nif (stringLiteralChildArray.some((strText) => strText.match(/(={7})|(>{7})|(<{7})/))) {\n    // 检测到合并冲突 直接抛出错误\n    throw path.buildCodeFrameError(\'检测到疑似合并冲突，请处理完之后重新提交\');\n}\n\n```\n思路已有，直接上源码：\n```ts\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport BabelCore, { PluginObj } from \'@babel/core\';\nimport { ObjectProperty } from \'@babel/types\';\n\nconst newReactToken = [\'_jsxs\', \'_jsx\'];\nexport default function ({ types }: typeof BabelCore): PluginObj {\n  const {\n    isStringLiteral,\n    isIdentifier,\n    isObjectExpression,\n    isMemberExpression,\n    isProperty,\n    isArrayExpression,\n  } = types;\n  return {\n    name: \'babel-plugin-conflict-react\',\n    visitor: {\n      CallExpression(path) {\n        const { callee } = path.node;\n        // 新版react17.0 不再使用react.createElement 会被编译成jsxs\n        if (isIdentifier(callee) && newReactToken.includes(callee.name)) {\n          const [, props] = path.node.arguments;\n          if (isObjectExpression(props)) {\n            // 遍历属性查找children的节点属性\n            const childrenProperties = props.properties.find((property) => {\n              if (isProperty(property) && isIdentifier(property.key)) {\n                return property.key.name === \'children\';\n              }\n              return false;\n            }) as ObjectProperty | undefined;\n            if (!childrenProperties) {\n              return;\n            }\n\n            // 如果统一弄成数组进行处理\n            const formatChildren = isArrayExpression(childrenProperties.value)\n              ? childrenProperties.value.elements\n              : [childrenProperties.value];\n\n            const stringLiteralChildArray: string[] = formatChildren\n              // @ts-ignore\n              .filter((children: any) => isStringLiteral(children))\n              .map((child: any) => child.value);\n            if (stringLiteralChildArray.some((strText) => strText.match(/(={7})|(>{7})|(<{7})/))) {\n              // 检测到合并冲突 直接抛出错误\n              throw path.buildCodeFrameError(\'检测到疑似合并冲突，请处理完之后重新提交\');\n            }\n          }\n        }\n\n        // 旧版react\n        if (\n          !(\n            isMemberExpression(callee) &&\n            isIdentifier(callee.object) &&\n            callee.object.name === \'React\' &&\n            isIdentifier(callee.property) &&\n            callee.property.name === \'createElement\'\n          )\n        ) {\n          return;\n        }\n        // get the component type name and it\'s extra props options\n        const [, , ...childrenArray] = path.node.arguments;\n        const stringLiteralChildArray: string[] = childrenArray\n          .filter((children) => types.isStringLiteral(children))\n          // @ts-ignore\n          .map((child) => child.value);\n        if (stringLiteralChildArray.some((strText) => strText.match(/(={7})|(>{7})|(<{7})/))) {\n          // 检测到合并冲突 直接抛出错误\n          throw path.buildCodeFrameError(\'检测到疑似合并冲突，请处理完之后重新提交\');\n        }\n      },\n    },\n  };\n}\n\n```\n\n### 兼容新版react的jsx\n注意的是在新版的react 17版本及以上默认采用的是新的jsx编译运行时，具体可以查看[官网文章](https://zh-hans.reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html)，默认使用的是新的_jsx而不是react.createElement了，所以上面的代码做了一层兼容。\n\n### 插件的使用\n在babel中引入当前编写的插件\n```js\nconst {\n  override,\n  addBabelPlugins\n} = require(\'customize-cra\');\nmodule.exports = {\n  webpack: override(\n    addBabelPlugins(\'@carrotwu/check-react-conflict-babel-plugin\')\n  )\n};\n\n```\n\n![alt](http://img.carrotwu.com/FsoEYydEaTRD4mi1afQAvNmdWbG9)\n\n\n### vue项目咋做检测\n其实思路一样，本质上都是要获取.vue文件会被编译成咋样的ast语法树，astexplorer官网能够直接查看vue文件编译成的ast语法树\n\n![alt](http://img.carrotwu.com/Fs3cY-nEPVZ1SYwBo2KC_T_mOygg)\n\n## 使用\n\n编写的库已上传到npm，有意向使用的话npm搜[@carrotwu/check-conflict-babel-plugin](https://www.npmjs.com/package/@carrotwu/check-conflict-babel-plugin)即可\n\n\n', 1, 'javascript,babel,react', '使用babel插件监控是否遗留合并冲突代码', 1, '2020-12-17 16:59:09', '2021-01-27 14:21:03', NULL, 'http://img.carrotwu.com/FsaAIrgY9Pv8sw8FcAv8KzHO61sk', NULL);
INSERT INTO `article` VALUES (39, '> 接上文的react项目的render模板合并冲突检测插件发布之后，今天这篇主要讲如何实现vue的合并冲突检测webpack插件', 24, '> 接上文的react项目的render模板合并冲突检测插件发布之后，今天这篇主要讲如何实现vue的合并冲突检测webpack插件\n\n前面react的文章实现了如何在打包模式下检测render模板中是否有遗留的合并冲突代码。vue也可以吗？  \n\n答案是肯定的！只是实现的思路以及方法从babel插件变为了webpack插件。\n\n## 为啥之前的babel插件实现不行了\n\n上偏文章说过了，react中的jsx其实最终都是会被babel编译成`react.createElement`的形式，因此我们可以通过babel插件的形式对react的渲染模板进行ast语法树的分析。\n\n那么vue呢？在[astexplore](https://astexplorer.net/)网站中我们选择编译的文件类型是vue就可以看到vue单文件编译成的ast语法树结构。\n\n![alt](http://img.carrotwu.com/FtURcAcmgB-yBQLFQG_wxudRIhgH)\n\n那么我们也可以利用这种形式来编写一个babel插件的形式来对vue中的template进行ast语法树的分析？事实上并不行，经由webpack进行打包的vue项目类似于`vue-cli`，webpack并不能识别.vue文件结尾的单文件。所以vue中的.vue单文件首先要经过`vue-loader`进行处理，在`vue-loader`中，会通过官方的`vue-template-compilre`进行编译静态分析优化等操作。其中的script代码任然会交给babel进行处理编译，**但是template渲染模板会由vue-template-compilre进行编译优化生成成最终的字符串模板**。  \n\n\n啥意思呢，就是.vue文件中的template变异之后的代码并不会再交给babel进行处理，`vue-template-compilre`已经干完了这些事情了。所以想通过babel插件的形式获取到template编译后的代码是拿不到的。\n\n## 换个思路-webpack插件\n\n既然babel插件的方式行不通那就要换个思路了: 我们知道的是**不管template中的代码怎么折腾，最终渲染模板代码都会被webpack打包成一个module模块，再交由webpack拼装组合优化等操作输出成js文件**。  \n\n所以，我们可以通过webpack插件监听特定的生命周期钩子，获取到打包时候生成的module模块。经过一些筛选比对这样子就能获取到`vue-template-compilre`编译之后的渲染模板代码。\n\n> 本文并不是来教你怎么写一个wenpack插件的，webpack插件的相关还是可以移步去webpack官网恶补一下。\n\n为了获取到被webpack生成的完整module，我们监听compilation的seal钩子即可：\n\n### 从webpack生成的modules中查找template模块\n\n```ts\nclass CheckVueConflictPlugin {\n  private readonly options: CheckVueConflictPluginOptions;\n\n  constructor(options?: CheckVueConflictPluginOptions) {\n    this.options = options || {};\n  }\n\n  apply(compiler: Compiler) {\n    const { force = false } = this.options;\n    const pluginName = this.constructor.name;\n    const { options } = compiler;\n    const { mode } = options;\n    // 非生产模式并且不需要强制执行直接退出即可\n    if (mode !== \'production\' && !force) {\n      return;\n    }\n    // 注册实例化compilation之后的钩子\n    compiler.hooks.compilation.tap(pluginName, (compilation) => {\n      compilation.hooks.seal.tap(pluginName, () => {\n        const newModule = Array.from(compilation.modules) as VueTemplateModule[];\n        // 筛选出type为template的渲染模板module\n        const templateModulesArray = newModule.filter(\n          (module) => module.resource && isVueTemplate(module.resource) && module.resource !== module.userRequest,\n        );\n      });\n    });\n  }\n}\n\n```\n\n.vue单文件经过`vue-template-compilre`编译后会被拆分成三个文件，通过type来区分：\n\n1. `source.vue?vue&type=template` 表示渲染函数模板\n2. `source.vue?vue&type=script` 表示script中的js逻辑\n3. `source.vue?vue&type=style` 表示样式文件\n\n看一下webpack打包的template渲染函数模块：\n\n![alt](http://img.carrotwu.com/Fqw9u2ic63MGSu9qDRHNOabVvGhi)  \n\n不难写出筛选出template渲染函数的代码: \n\n```ts\n// 判断是否vue模板 注意的是 mac的路径为相对路径 所以不能实例化的URL方法形式\n// 改用正则\nfunction isVueTemplate (url) {\n  if (/\\.vue\\?vue&type=template/.test(url)) {\n    return true\n  }\n}\nclass CheckVueConflictPlugin {\n  private readonly options: CheckVueConflictPluginOptions;\n\n  constructor(options?: CheckVueConflictPluginOptions) {\n    this.options = options || {};\n  }\n\n  apply(compiler: Compiler) {\n    const { force = false } = this.options;\n    const pluginName = this.constructor.name;\n    const { options } = compiler;\n    const { mode } = options;\n    // 非生产模式并且不需要强制执行直接退出即可\n    if (mode !== \'production\' && !force) {\n      return;\n    }\n    // 注册实例化compilation之后的钩子\n    compiler.hooks.compilation.tap(pluginName, (compilation) => {\n      compilation.hooks.seal.tap(pluginName, () => {\n        const newModule = Array.from(compilation.modules) as VueTemplateModule[];\n        const templateModulesArray = newModule.filter(\n          (module) => module.resource && isVueTemplate(module.resource) && module.resource !== module.userRequest,\n        );\n        // template模板有两种 一种是经过vue-loader模板处理的 template文件 这时候的request或者userRequest 引用路径其实就是vue-loader\n        // 一种是经过vue-loader编译之后导出的\n        // 我们要的是第儿2种即 经过vue-loader处理过后的 这时候的request与resource路径是不一样的\n        if (templateModulesArray.length) {\n          // 此时获取到的module模块内容就是经过vue-loader经过静态分析优化完的模板字符串内容\n          for (let i = 0; i < templateModulesArray.length; i++) {\n            if (templateModulesArray[i]._source._value) {\n              checkIsConflict(templateModulesArray[i]);\n            }\n          }\n        }\n      });\n    });\n  }\n}\n\n```\n\n### 引入babel对template渲染函数进行ast语法树分析\n\n从上面的步骤中我们获取到了经由`vue-template-compilre`编译优化过后的渲染字符串，假设原template的代码是这样子的:  \n\n```html\n<template>\n  <div id=\"app\">\n    <router-view />\n    ===============\n    <div>2131313</div>\n    <Triangle/>\n    <div>\n      <div>1</div>\n      <div>2</div>\n      <div>\n        <span>span1</span>\n        <span>span2</span>\n        <span>span3</span>\n      </div>\n    </div>\n  </div>\n</template>\n```  \n\n经过`vue-tempalte-compilre`编译优化之后就会生成如下的渲染函数字符串(为了方便理解代码做了格式化以及注释)： \n\n\n```js\n// template中最终会被编译成render函数并且导出\nvar render = function() {\n  var _vm = this;\n  var _h = _vm.$createElement;\n  var _c = _vm._self._c || _h;\n  // 对于组件或者标签 会转化为_c函数\n  return _c(\n    \"div\",\n    { attrs: { id: \"app\" } },\n    [\n      _c(\"router-view\"),\n      // html的标签内容转化为_vm._v的函数形式\n      _vm._v(\"\\n  ===============\\n  \"),\n      _c(\"div\", [_vm._v(\"2131313\")]),\n      _c(\"Triangle\"),\n      _vm._m(0)\n    ],\n    1\n  );\n};\n// 静态节点 vue中对于一些不会变化的节点会转化为静态节点，在diff的时候会跳过这些节点用于性能优化。\nvar staticRenderFns = [\n  function() {\n    var _vm = this;\n    var _h = _vm.$createElement;\n    var _c = _vm._self._c || _h;\n    return _c(\"div\", [\n      _c(\"div\", [_vm._v(\"1\")]),\n      _c(\"div\", [_vm._v(\"2\")]),\n      _c(\"div\", [\n        _c(\"span\", [_vm._v(\"span1\")]),\n        _c(\"span\", [_vm._v(\"span2\")]),\n        _c(\"span\", [_vm._v(\"span3\")])\n      ])\n    ]);\n  }\n];\n\nexport {render, staticRenderFns}\n```\n不难看出，为了检验模板中是否有遗留的合并冲突代码，我们只需要`_vm._v`中的字符串是进行正则匹配即可。我们把这段代码丢到[astexplore](https://astexplorer.net/)中。\n\n![alt](http://img.carrotwu.com/Fv1Cd1mDFOLO6t0jYNH3YQmSIcL4)  \n \n\n获取到相对应的ast语法树之后，通过babel插件把上面获取到的模板源文件转为为ast语法树，通过访问者模式判断特定的节点即可。  \n\n```ts\nimport { Compiler, Module } from \'webpack\';\nimport { parse } from \'@babel/parser\';\nimport traverse from \'@babel/traverse\';\nimport * as babelTypes from \'@babel/types\';\nimport { StringLiteral } from \'@babel/types\';\n\ninterface VueTemplateModule extends Module {\n  resource?: string;\n  _source: {\n    _value: string;\n  };\n  userRequest?: string;\n}\nconst newVueToken = [\'_vm\'];\nconst vuePropertyKey = [\'_v\'];\n\nfunction checkIsConflict(module: VueTemplateModule) {\n  const { _source, resource } = module;\n  const vueTemplateAst = parse(_source._value, {\n    sourceType: \'module\',\n  });\n  traverse(vueTemplateAst, {\n    CallExpression(path) {\n      const { callee } = path.node;\n      if (\n        !(\n          babelTypes.isMemberExpression(callee) &&\n          babelTypes.isIdentifier(callee.object) &&\n          newVueToken.includes(callee.object.name) &&\n          babelTypes.isIdentifier(callee.property) &&\n          vuePropertyKey.includes(callee.property.name)\n        )\n      ) {\n        return;\n      }\n      // get the component type name and it\'s extra props options\n      const childrenArray = path.node.arguments;\n      const stringLiteralChildArray = childrenArray.filter((children) =>\n        babelTypes.isStringLiteral(children),\n      ) as StringLiteral[];\n\n      const stringLiteralValArray = stringLiteralChildArray.map((child) => child.value);\n\n      const conflictText = stringLiteralValArray.find((strText) => strText.match(/(={7})|(>{7})|(<{7})/));\n      if (conflictText) {\n        // 检测到合并冲突 直接抛出错误\n        throw new Error(\n          `在 【${resource}】 文件中检测到疑似合并冲突，请处理完之后重新提交\n            出现合并冲突内容为${conflictText}\n          `,\n        );\n      }\n    },\n  });\n}\n```\n\n至此，一个检测vue渲染模板中是否有合并冲突代码的webpack插件就完成了，全部实现源码如下:  \n\n```ts\nimport { URL } from \'url\';\nimport { Compiler, Module } from \'webpack\';\nimport { parse } from \'@babel/parser\';\nimport traverse from \'@babel/traverse\';\nimport * as babelTypes from \'@babel/types\';\nimport { StringLiteral } from \'@babel/types\';\n\ninterface VueTemplateModule extends Module {\n  resource?: string;\n  _source: {\n    _value: string;\n  };\n  userRequest?: string;\n}\n\ninterface CheckVueConflictPluginOptions {\n  // 是否强制开启进行模板冲突检测\n  force?: boolean;\n}\nconst newVueToken = [\'_vm\'];\nconst vuePropertyKey = [\'_v\'];\n\n// 判断是否vue模板 注意的是 mac的路径为相对路径 所以不能实例化的URL方法形式\n// 改用正则\nfunction isVueTemplate (url) {\n  if (/\\.vue\\?vue&type=template/.test(url)) {\n    return true\n  }\n}\nfunction checkIsConflict(module: VueTemplateModule) {\n  const { _source, resource } = module;\n  const vueTemplateAst = parse(_source._value, {\n    sourceType: \'module\',\n  });\n  traverse(vueTemplateAst, {\n    CallExpression(path) {\n      const { callee } = path.node;\n      if (\n        !(\n          babelTypes.isMemberExpression(callee) &&\n          babelTypes.isIdentifier(callee.object) &&\n          newVueToken.includes(callee.object.name) &&\n          babelTypes.isIdentifier(callee.property) &&\n          vuePropertyKey.includes(callee.property.name)\n        )\n      ) {\n        return;\n      }\n      // get the component type name and it\'s extra props options\n      const childrenArray = path.node.arguments;\n      const stringLiteralChildArray = childrenArray.filter((children) =>\n        babelTypes.isStringLiteral(children),\n      ) as StringLiteral[];\n\n      const stringLiteralValArray = stringLiteralChildArray.map((child) => child.value);\n\n      const conflictText = stringLiteralValArray.find((strText) => strText.match(/(={7})|(>{7})|(<{7})/));\n      if (conflictText) {\n        // 检测到合并冲突 直接抛出错误\n        throw new Error(\n          `在 【${resource}】 文件中检测到疑似合并冲突，请处理完之后重新提交\n            出现合并冲突内容为${conflictText}\n          `,\n        );\n      }\n    },\n  });\n}\n\nclass CheckVueConflictPlugin {\n  private readonly options: CheckVueConflictPluginOptions;\n\n  constructor(options?: CheckVueConflictPluginOptions) {\n    this.options = options || {};\n  }\n\n  apply(compiler: Compiler) {\n    const { force = false } = this.options;\n    const pluginName = this.constructor.name;\n    const { options } = compiler;\n    const { mode } = options;\n    // 非生产模式并且不需要强制执行直接退出即可\n    if (mode !== \'production\' && !force) {\n      return;\n    }\n    // 注册实例化compilation之后的钩子\n    compiler.hooks.compilation.tap(pluginName, (compilation) => {\n      compilation.hooks.seal.tap(pluginName, () => {\n        const newModule = Array.from(compilation.modules) as VueTemplateModule[];\n        const templateModulesArray = newModule.filter(\n          (module) => module.resource && isVueTemplate(module.resource) && module.resource !== module.userRequest,\n        );\n        // template模板有两种 一种是经过vue-loader模板处理的 template文件 这时候的request或者userRequest 引用路径其实就是vue-loader\n        // 一种是经过vue-loader编译之后导出的\n        // 我们要的是第儿2种即 经过vue-loader处理过后的 这时候的request与resource路径是不一样的\n        if (templateModulesArray.length) {\n          // 此时获取到的module模块内容就是经过vue-loader经过静态分析优化完的模板字符串内容\n          for (let i = 0; i < templateModulesArray.length; i++) {\n            if (templateModulesArray[i]._source._value) {\n              checkIsConflict(templateModulesArray[i]);\n            }\n          }\n        }\n      });\n    });\n  }\n}\n\nexport default CheckVueConflictPlugin;\n\n```\n## 加餐：vue3的兼容\n\nvue3的单文件模板依然会分离成三个文件，通过type来区分（跟vue2一毛一样）\n1. `source.vue?vue&type=template` 表示渲染函数模板\n2. `source.vue?vue&type=script` 表示script中的js逻辑\n3. `source.vue?vue&type=style` 表示样式文件\n\n只是编译的渲染模板发生了变化，如下面的template模板：  \n\n```html\n<template>\n  <header class=\"header\">\n    <div class=\"logo\">\n      <i class=\"back\" />\n    </div>\n    <span>123456</span>\n    <div class=\"tabs\">\n      <div class=\"tab-item\" v-for=\"item in tabList\" :key=\"item.name\">\n        <RouterLink :to=\"item.link\">{{ item.name }}</RouterLink>\n      </div>\n    </div>\n    ==================\n    <RouterLink class=\"user\" to=\"/user\">\n      <i class=\"iconfont icon-user\" />\n      >>>>>>>>>>>>sss\n      <span>测试环境数据</span>\n    </RouterLink>\n  </header>\n</template>\n\n```  \n\n会编译优化为如下的js代码:  \n\n```js\n\nimport { createVNode as _createVNode, renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createBlock as _createBlock, toDisplayString as _toDisplayString, createTextVNode as _createTextVNode, resolveComponent as _resolveComponent, withCtx as _withCtx, withScopeId as _withScopeId, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from \"vue\"\nconst _withId = /*#__PURE__*/_withScopeId(\"data-v-77d8155b\")\n\n_pushScopeId(\"data-v-77d8155b\")\nconst _hoisted_1 = { class: \"header\" }\nconst _hoisted_2 = /*#__PURE__*/_createVNode(\"div\", { class: \"logo\" }, [\n  /*#__PURE__*/_createVNode(\"i\", { class: \"back\" })\n], -1)\nconst _hoisted_3 = /*#__PURE__*/_createVNode(\"span\", null, \"123456\", -1)\nconst _hoisted_4 = { class: \"tabs\" }\nconst _hoisted_5 = /*#__PURE__*/_createTextVNode(\" ================== \")\nconst _hoisted_6 = /*#__PURE__*/_createVNode(\"i\", { class: \"iconfont icon-user\" }, null, -1)\nconst _hoisted_7 = /*#__PURE__*/_createTextVNode(\" >>>>>>>>>>>>sss \")\nconst _hoisted_8 = /*#__PURE__*/_createVNode(\"span\", null, \"测试环境数据\", -1)\n_popScopeId()\n\nexport const render = /*#__PURE__*/_withId(function render(_ctx, _cache) {\n  const _component_RouterLink = _resolveComponent(\"RouterLink\")\n\n  return (_openBlock(), _createBlock(\"header\", _hoisted_1, [\n    _hoisted_2,\n    _hoisted_3,\n    _createVNode(\"div\", _hoisted_4, [\n      (_openBlock(true), _createBlock(_Fragment, null, _renderList(_ctx.tabList, (item) => {\n        return (_openBlock(), _createBlock(\"div\", {\n          class: \"tab-item\",\n          key: item.name\n        }, [\n          _createVNode(_component_RouterLink, {\n            to: item.link\n          }, {\n            default: _withId(() => [\n              _createTextVNode(_toDisplayString(item.name), 1 /* TEXT */)\n            ]),\n            _: 2\n          }, 1032, [\"to\"])\n        ]))\n      }), 128 /* KEYED_FRAGMENT */))\n    ]),\n    _hoisted_5,\n    _createVNode(_component_RouterLink, {\n      class: \"user\",\n      to: \"/user\"\n    }, {\n      default: _withId(() => [\n        _hoisted_6,\n        _hoisted_7,\n        _hoisted_8\n      ]),\n      _: 1\n    })\n  ]))\n})\n```  \n\n不难看出，获取静态文本的方法集中在`_createVNode`以及`_createTextVNode`这两个核心方法之中。根据相对应的ast语法树进行判断即可：  \n\n```ts\nexport function checkVue3IsConflict(module: VueTemplateModule) {\n  const { _source, resource } = module;\n  const vueTemplateAst = parse(_source._value, {\n    sourceType: \'module\',\n  });\n  traverse(vueTemplateAst, {\n    CallExpression(path) {\n      // @ts-ignore\n      const { callee } = path.node;\n      const nodeArguments = path.node.arguments;\n      const isCreateVNode =\n        babelTypes.isIdentifier(callee) &&\n        callee.name === \'_createVNode\' &&\n        babelTypes.isStringLiteral(nodeArguments[2]);\n      const isCreateTextVNode =\n        babelTypes.isIdentifier(callee) &&\n        callee.name === \'_createTextVNode\' &&\n        babelTypes.isStringLiteral(nodeArguments[0]);\n      if (!(isCreateVNode || isCreateTextVNode)) {\n        return;\n      }\n      const pendingCheckStr = nodeArguments[isCreateVNode ? 2 : 0] as StringLiteral;\n\n      const conflictText = pendingCheckStr.value.match(/(={7})|(>{7})|(<{7})/);\n      if (conflictText) {\n        // 检测到合并冲突 直接抛出错误\n        throw new Error(\n          `在 【${resource}】 文件中检测到疑似合并冲突，请处理完之后重新提交\n            出现合并冲突内容为${pendingCheckStr.value}\n          `,\n        );\n      }\n    },\n  });\n}\n\n```\n\n\n## 效果\n\n![alt](http://img.carrotwu.com/FhZWmhaYI56_U_gtF2CJSB6N8HwQ)\n\n## 使用\n\n编写的库已上传到npm，有意向使用的话npm搜[@carrotwu/check-vue-conflict-webpack-plugin](https://www.npmjs.com/package/@carrotwu/check-vue-conflict-webpack-plugin)即可', 1, 'javascript,webpack,vue', '手把手写一个检测vue单文件template是否有合并冲突的webpack插件', 1, '2021-01-11 19:47:05', '2021-02-01 13:59:29', NULL, 'http://img.carrotwu.com/FmjM5TUMCmgkrosf8eT0pG156e4T', NULL);
INSERT INTO `article` VALUES (40, '最近在通过rollup写一个promise的通用工具库，其中在配置package.json中的模块导出声明有点犯迷糊因此这里做个笔记记录一下。', 12, '>最近在通过rollup写一个promise的通用工具库，其中在配置package.json中的模块导出声明有点犯迷糊因此这里做个笔记记录一下。\n\n## 为啥要支持多模块导出\n\n我们都知道的是rollup支持对外打包出不同模块化的代码，例如cjs（commonJs），esm（esModule），AMD，UMD等等。\n\n对于不同环境的使用者来说，针对高版本的浏览器可以使用esm模块的代码，对于nodejs那么就可以使用cjs版本代码。使用哪种版本的代码应该交由使用者来选择。\n\n## main,jsnext:main,module有啥区别\n既然打包出了不同版本的代码，那么就需要在package.json配置中告诉使用者这个库提供了什么模块化的代码，所以一般在package.json中显式声明这几个变量：`main,jsnext:main,module`。例如下面这种形式：\n\n```js\n{\n  \"name\": \"xxx\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"dist/index.main.js\",\n  \"jsnext:main\": \"dist/index.esm.js\",\n  \"module\": \"dist/index.esm.js\",\n  \"browser\": \"dist/index.umd.js\",\n  \"scripts\": {\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {},\n  \"dependencies\": {}\n}\n``` \n\n1. main: main 字段指明包的入口文件位置,默认 index.js。这里的文件应该放置 commonJs(cjs)模块, 如果源码需要被编译才能使用,那么此处的文件就必须已经被编译了\n\n2. jsnext:main: 有一些工具,例如 webpack 能直接处理 import方式导入的模块。如果开发者希望自己的包交由使用者决定如何引入,那么可以将源码编译成ECMA(esm)\n\n3. module: 与 jsnext:main 意义一样。但是 jsnext:main 是社区约定的字段,并非官方。而 module 则是官方字段。但是社区包含大量的插件只认识 jsnext:main,所以推荐同时使用 jsnext:main 和 module\n\n### 最佳实践\n\n| 字段 | 描述 | 文件格式 |\n| ------ | ------ | ------ |\n| main | nodejs 默认文件入口, 支持最广泛 | cjs |\n| jsnext:main | 社区约定的 esm 文件入口, webpack, rollup 均支持该字段 | esm |\n| module | esm 官方约定入口, 支持插件较少,故推荐和 jsnext:main 同时使用 | esm |\n\n## 加餐 jsnext:main的那些事\n\n一般我们在webpack性能优化中会经常看到使用tree-shaking的技术，其中有一条就是配置`resolve.mainfields`为数组：\n\n```js\n// webpack配置\nresolve.mainfields: [\'jsnext:main\', \'module\', \'main\']\n\n```  \n\n这样子配置的理由是告诉webpack在引入这个包的时候，从左到右依次查找。按照上面的表格可以看出其实就是告诉webpack优先查找已esm模块为导出的文件。  \n\n之所以要优先查找esm模块，其实就是因为**tree-shaking只能针对esm模块的文件进行摇树优化**，本质上是因为**esm模块是基于编译时即编译的时候就能够知道模块中的依赖关系图，而cjs是基于运行时只有在运行的时候才能知道引入的模块是否有被使用**。  \n\n另外来说esm模块导出的是值的引用，cjs导出的是值的浅拷贝。\n\n具体的区别可自行查看其他大佬的文章吧。', 1, 'nodeJs,webpack,javascript', 'package.json模块导出之main,jsnext:main,module傻傻分不清', 1, '2021-01-21 15:13:51', '2021-02-04 14:14:36', NULL, 'http://img.carrotwu.com/FrmZn6Wa8GJTtxErAzu8C6TPBwNa', NULL);

-- ----------------------------
-- Table structure for tag
-- ----------------------------
DROP TABLE IF EXISTS `tag`;
CREATE TABLE `tag`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `value` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `createdStamp` datetime(0) NOT NULL,
  `updatedStamp` datetime(0) NOT NULL,
  `deletedStamp` datetime(0) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `value`(`value`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 18 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tag
-- ----------------------------
INSERT INTO `tag` VALUES (1, 'javascript', 'javascript', '2019-10-21 09:39:11', '2019-10-21 09:39:11', NULL);
INSERT INTO `tag` VALUES (2, 'nodeJs', 'nodeJs', '2019-10-21 09:39:40', '2019-10-21 09:39:40', NULL);
INSERT INTO `tag` VALUES (3, 'react', 'react', '2019-10-21 09:40:16', '2019-10-21 09:40:16', NULL);
INSERT INTO `tag` VALUES (4, 'redux', 'redux', '2019-10-21 09:40:43', '2019-10-21 09:40:43', NULL);
INSERT INTO `tag` VALUES (5, 'reactHooks', 'reactHooks', '2019-11-12 11:32:35', '2019-11-12 11:32:35', NULL);
INSERT INTO `tag` VALUES (6, 'typescript', 'typescript', '2019-11-13 17:44:17', '2019-11-13 17:44:17', NULL);
INSERT INTO `tag` VALUES (7, 'react-native', 'reacat-native', '2019-11-16 11:26:16', '2019-11-16 11:26:16', NULL);
INSERT INTO `tag` VALUES (8, 'prism.js', 'prism.js', '2019-11-18 17:56:54', '2019-11-18 17:56:54', NULL);
INSERT INTO `tag` VALUES (9, 'http', 'http', '2019-11-20 10:46:37', '2019-11-20 10:46:37', NULL);
INSERT INTO `tag` VALUES (10, 'https', 'https', '2019-11-20 10:46:41', '2019-11-20 10:46:41', NULL);
INSERT INTO `tag` VALUES (11, '浏览器', 'browser', '2019-11-28 09:28:55', '2019-11-28 09:28:55', NULL);
INSERT INTO `tag` VALUES (12, '设计模式', 'design-patterns', '2020-01-04 17:46:27', '2020-01-04 17:46:27', NULL);
INSERT INTO `tag` VALUES (13, '算法', 'algorithm', '2020-03-08 17:45:47', '2020-03-08 17:45:47', NULL);
INSERT INTO `tag` VALUES (14, 'nestJs', 'nestJs', '2020-11-13 16:45:02', '2020-11-13 16:45:02', NULL);
INSERT INTO `tag` VALUES (15, 'babel', 'babel', '2021-01-12 10:10:39', '2021-01-12 10:10:39', NULL);
INSERT INTO `tag` VALUES (16, 'webpack', 'webpack', '2021-01-12 10:11:04', '2021-01-12 10:11:04', NULL);
INSERT INTO `tag` VALUES (17, 'vue', 'vue', '2021-01-12 10:13:33', '2021-01-12 10:13:33', NULL);

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `email` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `openid` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `createdStamp` datetime(0) NOT NULL,
  `updatedStamp` datetime(0) NOT NULL,
  `deletedStamp` datetime(0) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `email`(`email`) USING BTREE,
  UNIQUE INDEX `openid`(`openid`) USING BTREE,
  UNIQUE INDEX `email_2`(`email`) USING BTREE,
  UNIQUE INDEX `openid_2`(`openid`) USING BTREE,
  UNIQUE INDEX `email_3`(`email`) USING BTREE,
  UNIQUE INDEX `openid_3`(`openid`) USING BTREE,
  UNIQUE INDEX `email_4`(`email`) USING BTREE,
  UNIQUE INDEX `openid_4`(`openid`) USING BTREE,
  UNIQUE INDEX `email_5`(`email`) USING BTREE,
  UNIQUE INDEX `openid_5`(`openid`) USING BTREE,
  UNIQUE INDEX `email_6`(`email`) USING BTREE,
  UNIQUE INDEX `openid_6`(`openid`) USING BTREE,
  UNIQUE INDEX `email_7`(`email`) USING BTREE,
  UNIQUE INDEX `openid_7`(`openid`) USING BTREE,
  UNIQUE INDEX `email_8`(`email`) USING BTREE,
  UNIQUE INDEX `openid_8`(`openid`) USING BTREE,
  UNIQUE INDEX `email_9`(`email`) USING BTREE,
  UNIQUE INDEX `openid_9`(`openid`) USING BTREE,
  UNIQUE INDEX `email_10`(`email`) USING BTREE,
  UNIQUE INDEX `openid_10`(`openid`) USING BTREE,
  UNIQUE INDEX `email_11`(`email`) USING BTREE,
  UNIQUE INDEX `openid_11`(`openid`) USING BTREE,
  UNIQUE INDEX `email_12`(`email`) USING BTREE,
  UNIQUE INDEX `openid_12`(`openid`) USING BTREE,
  UNIQUE INDEX `email_13`(`email`) USING BTREE,
  UNIQUE INDEX `openid_13`(`openid`) USING BTREE,
  UNIQUE INDEX `email_14`(`email`) USING BTREE,
  UNIQUE INDEX `openid_14`(`openid`) USING BTREE,
  UNIQUE INDEX `email_15`(`email`) USING BTREE,
  UNIQUE INDEX `openid_15`(`openid`) USING BTREE,
  UNIQUE INDEX `email_16`(`email`) USING BTREE,
  UNIQUE INDEX `openid_16`(`openid`) USING BTREE,
  UNIQUE INDEX `email_17`(`email`) USING BTREE,
  UNIQUE INDEX `openid_17`(`openid`) USING BTREE,
  UNIQUE INDEX `email_18`(`email`) USING BTREE,
  UNIQUE INDEX `openid_18`(`openid`) USING BTREE,
  UNIQUE INDEX `email_19`(`email`) USING BTREE,
  UNIQUE INDEX `openid_19`(`openid`) USING BTREE,
  UNIQUE INDEX `email_20`(`email`) USING BTREE,
  UNIQUE INDEX `openid_20`(`openid`) USING BTREE,
  UNIQUE INDEX `email_21`(`email`) USING BTREE,
  UNIQUE INDEX `openid_21`(`openid`) USING BTREE,
  UNIQUE INDEX `email_22`(`email`) USING BTREE,
  UNIQUE INDEX `openid_22`(`openid`) USING BTREE,
  UNIQUE INDEX `email_23`(`email`) USING BTREE,
  UNIQUE INDEX `openid_23`(`openid`) USING BTREE,
  UNIQUE INDEX `email_24`(`email`) USING BTREE,
  UNIQUE INDEX `openid_24`(`openid`) USING BTREE,
  UNIQUE INDEX `email_25`(`email`) USING BTREE,
  UNIQUE INDEX `openid_25`(`openid`) USING BTREE,
  UNIQUE INDEX `email_26`(`email`) USING BTREE,
  UNIQUE INDEX `openid_26`(`openid`) USING BTREE,
  UNIQUE INDEX `email_27`(`email`) USING BTREE,
  UNIQUE INDEX `openid_27`(`openid`) USING BTREE,
  UNIQUE INDEX `email_28`(`email`) USING BTREE,
  UNIQUE INDEX `openid_28`(`openid`) USING BTREE,
  UNIQUE INDEX `email_29`(`email`) USING BTREE,
  UNIQUE INDEX `openid_29`(`openid`) USING BTREE,
  UNIQUE INDEX `email_30`(`email`) USING BTREE,
  UNIQUE INDEX `openid_30`(`openid`) USING BTREE,
  UNIQUE INDEX `email_31`(`email`) USING BTREE,
  UNIQUE INDEX `openid_31`(`openid`) USING BTREE,
  UNIQUE INDEX `email_32`(`email`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES (1, 'carrotWu', '542425997@qq.com', '$2b$10$OxPYMJ2xsNcVwaTk7Pfaw.AlW/QwptJNHz6U5GaFY6B7DfNVoDE8u', NULL, '2019-10-14 16:28:22', '2019-10-14 16:28:22', NULL);

SET FOREIGN_KEY_CHECKS = 1;
