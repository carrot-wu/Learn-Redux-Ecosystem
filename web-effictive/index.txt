/*
* web高效变成读书笔记
* */

/*第一章  能用html css的就不要用js来实现*/
/*
*  1 比如简单的悬浮高亮显示样式 直接加上伪类:hover即可实现
*  2 鼠标悬浮式显示某些元素 最好的办法是相邻元素或者子元素 这样子的话对于相邻元素可以使用 .test:hover + .siblings{display:block} 来显示
* */

/*第三章 用css画一个三角形*/
/*
  普通的三角形
.box{
  width:0;
  height:0;
  border:10px solid #ccc;
  border-color:transparent transparent transparent blue;
  position:relative;
}
*/
//有边角颜色的三角形 类似于微信的聊天框的边角
简单说就是通过为元素叠加在原有三角形的顶部然后有移动即可
.box::before{
  width:0;
  height:0;
  border:10px solid #ccc;
  border-color:transparent transparent transparent yellow;
  position:absolute;
  left:-2px;
  top...
}

//第四章 尽量使用伪元素
伪元素一般常用于画图，尤其是一些作用不大的边界线，点之类的东西
什么是为元素?
为元素其实就是元素的子元素，并且是inline元素 其中after的为元素放在子元素的最后一行 before放在第一行 但是与真实的dom元素不一样的是 js是无法正确获取微元素的节点进行增删改查的操作
清除浮动
.box{
  display:table:
  content:'';
  clear:both;
}

第五章 减少前端代码耦合

1减少全局耦合 减少全局变量的使用
2减少html/css/js的耦合 比如说拒绝使用js直接修改样式 比如css（{}） 或者react的 style={} 而应该是定义多个类来进行切换 这样子以后调试的过程中十分容易查找到根源
3对于重复代码的封装 主要记住一个极端的原则 模块分的极端是拆分力度太细，一个简单的功能，明明是行代码可以搞定的事情，分要分了几个文件，每个文件三四航代码，并没有什么好处
  1其次是对于代码的复用封装 一种是通过类的方式去复用 通过实例去调用方法 这个已经很熟悉了 另外一种了使用过策略模式
  2其中策略模式可以用过对象的形式通过 map[]来获取真实的值 或者通过switch case来获取值 当然到后期 switch的形式也不行了 这时候可以使用对象函数的方式
  比如 const map = {keyA:function,keyB:function}
  3另外一个就是访问者模式 其实事件监听就是一个发布订阅模式 可以自己去做一个发布订阅者 类似于jquery的on函数
第六章 js的书写优化
1按强类型语言的写法来声明使用变量
  1声明变量的时候给一个默认值 一是可以确认变量的初始类型 而是变量具有默认值
  2 声明好的变量类型不要随意的变换 如果需要变换的话最好的办法是重新多声明一个变量
2减少作用域链的查找
  大家都知道 变量的查找都是需要经过作用域链的查找的 作用域链越深 那么耗费的时间和性能也是成倍的增加。
  1不要让代码暴露在全局作用于下 尽量把变量存储在局部作用域。这样子变量的命中会十分的快
  2不要滥用闭包，闭包释然是个好东西，能做模块分。但是闭包带来的最大坏处就是占用内存。 如果真的要经常使用一个变量就可以把当前变量通过参数传入进来类似于jquery传入的window对象、
  3使用===绝对相等取代相等
  4合并表达式
    1使用三目运算符来取代if else  ？：
    2使用短路运算符来取代if  &&

第七章去 避免页面卡顿
  失帧和帧率fps
  一般来说 良好的帧率都是60fps 也就是1/60 = 16.7ms、
  一般来说浏览器每帧也就提供10ms的时间 所以说对于一些耗时比较严重的可以通过拆分代码段来进行优化 把耗时较长的函数放进多个帧之中进行调用而不是放在同一帧中条用
  解决方法例子：
  任务队列
  class task{
    constructor(){
      this.tasks = []
    }
    //单例模式
    static getInstance(){
      if(!task.__instance){
        task.__instance = new task()
      }
      return task.__instance
    }
    //每次重绘都调用队列中的一个方法 requestAnimationFrame的方法会在浏览器每一帧渲染的过程中进行调用
    draw(){
      window.requestAnimationFrame(() =>{
        if(this.tasks.length){
          const currentTask = this.task.shift()
          currentTask && currentTask()
        }
        //渲染完成之后递归进行绑定
        window.requestAnimationFrame(()=>{
          this.draw.call(this)
        })
      })
    }
  }

第八章 加快页面打开速度
 一般来说，对于一个页面的打开速度主要衡量于两个数值，一个是domContentLoad 也就是节点渲染完毕的时间 另外一个是load也就是获取数据完全部加载完成的时间。
 因为对于需要加快页面速度可以从这两方面入手
  1减小渲染堵塞
  综合周知 js引擎是单线程的 而渲染引擎与js引擎又是相互互斥的
  一 避免head标签js堵塞 所有放在head标签中的js和css都会堵塞渲染 js都知道 但是css为什么会堵塞渲染 css的下载不会堵塞但是css的解析生成cssdom 会与html解析生成的domtree合并生成renderTree 这个才是最终的渲染节点，所以css的解析也会堵塞渲染。
    解决办法是把script标签放在body后面 另外一种就是加defer defer的作用就是等待domcontentLoad这个事件出发后才会执行js async是一旦js下载完成就自动执行
  二 减小head中的css
  另外一种就是就可以把样式内敛到html中 这样子的话见笑了一个请求
  三 优化图片
    压缩图片啊 延迟加载图片通过懒加载

第九章 增强用户体验
  1 加loading效果 可以再页面上的首次加载或者图片加载添加一个loading效果 请求完成之后进行清除。。或者对ajax请求进行loading的来增加
  2 加过渡动画效果 在一些动画的地方可以加一些过渡效果 使得动画更加平滑
  3 单击和输入 对于一些按钮的点击反馈 可以给按钮加一个button:active{paddingTop:3px; bgc:更深的颜色} 这样子的话把文字往下挤压，添加深颜色即可。
  4 记住用户习惯 比如跳转页面之后返回停留在之前阅读的位置这个可以用本地存储实现 每次跳转时都重新刷新获取值即可

第十章 用好chrome Devtools
  --------打印-------
  1 console.table 对于需要打印一些列表性的数据时用此命令代替console.log显得更加的好，数据会平铺出来。
  ------检查没有用的css/js--------
  在工具栏的Coverage点击记录俺妞，刷新页面，页面加载完成之后点击停止俺妞。就会显示占比，其中红色的为没有用到的样式或者js
  ---debugger---
  其实不用再source文件里面打断点也是可以的 可以再源码地方直接加上debugger即可再次搭上断点,尤其是对于一些hover状态的调试时如果是css的样式可以再style哪里勾选上hover样式。如果是js的话可以再悬浮功能函数里面搭上断点 这样子的话就可以调试了
  ----console.trace-----
  console.trace可以放在函数内部，在控制台则会打印出当前函数执行所处的函数调用栈

第十一章 使用h5的history改善ajax的体验

第十四章 实现前端压缩裁剪图片

第五大章--------------前端与计算机基础
第十七章 理解websocket和tcp/ip连接

 tcp/ip连接--------一次完整的http连接

 tcp的三次握手
 简单说就是建 第一次连接 客户端给服务端发送了一个tcp的包 标志位为syn告诉服务端要建立http请求
 第二次连接 服务端收到了请求 给客户端发回一个tcp包 标志位为syn和ack 告诉客户端 好的 没哦问题可以建立链接
 第三次连接 客户端收到了回复信息 给服务端又发送了一个tcp的包 标志位为传过来的ack 告诉服务端我收到回复了可以建立链接
 其实tcp的链接不一定只是三次链接 有可能5 6次 因为任意依次请求都可能丢失 客户端有可能会重复发送请求 只是说三次是确保链接成功的次数

第十八章
先提出这几个问题 为什么说https是安全的安全在哪里(我的理解 http的数据时明文在tcp中进行传输的会被截取 https对数据进行了加密)
https是使用证书保证他的安全么（不是，证书只是提供了一个公钥，建立完tcp请求后 会自动生成一个hash值这就是秘钥 用公钥对秘钥加密 秘钥来加密数据）
----https解决了什么问题----
客服端和服务器端进行数据传输的过程中都会经过一个中间人,Nepal没有别人也可以进行截取，所以明文数据是没有保密性的。
https = http + tls 其中tls是一层传输层

https具体流程
1第一步 客户端发送客服端client hello的包 包里面是支持的加密方式以及tsl版本号以及一个随机密码串（随机密码串后面会使用到）
2服务端收到了服务端发送的server hello的包 服务器会发送选中的加密方法以及一个证书 证书里面有一些域名下的集团信息 当然还有签名的算法以及公钥 其中涉及到了对称算法和非对称算法（堆成算法是使用相同的秘钥进行加密和解密）
3秘钥交换 里面有两种模式 一种是非对称加密
服务端自己有单独的秘钥 公钥加密的信息只能用秘钥来揭开 那么很简单 服务器发送了证书之后 客户端就用这个公钥来加密数据 服务器用秘钥来揭秘  同理一开始浏览器发送了一个随机密码（也就是公钥）服务器用这个公钥来加密
浏览器用自己独有的私钥揭秘。。
 总而言之 第一步 双方传输 浏览器生成秘钥 发送自己的公钥获取服务器发来的公钥（证书） 服务器发送公钥接受浏览器的公钥 之后的传输过程中 双方都是用对方给的公钥进行加密 自己的私钥进行解密
 其中最大的问题就是公钥有可能被中间人替换 所以要确保这个公钥就是服务器发送的 所以就需要证书（保证人 服务器都去保证人哪里去做委托 说这个公钥是我的 其他人不可以用）
  这种很浪费性能 所以催生了另外一种 堆成加密+非对称加密的

 第一步就是依然一模一样 最重要就是第二步 传输的过程中 浏览器把信息和秘钥用服务器的公钥假面之后 服务器解密成功 然后用里面的秘钥相互解密就好啦

 对于证书的copy 其实也没用 你哪怕kopy了证书 你没有秘钥依然是破解不了信息 而且秘钥也有很多对而且必须一一对应

第十九章 为什么0.1+0.2不等于0.3
因为 js对于浮点数的岑存储标准是按照IEEE754的标准实现的，浮点数分为单精度和双精度，其中单精度为32位，双精度为64位。
我们都知道计算机中是使用二进制存储数据的对于整数而言，用二进制十分简单。但是对于浮点数的二进制实现只能用另外一个数来接近标识 比如0.75=1*1/2^-1 + 1*2^2 有些浮点数是可以的。
所以要用节数的形式去表示。实际上浮点数都比正常自身的数值大一点

第22章 学会js与面向对象
面向对象的特点其实是一种思维，而不是代码的组织方式。
面向对象的三个特点：封装（父类），继承（子类继承父类），多态（子类能够添加相同的实例方法来“覆盖”父类方法）
--------------设计模式-----------------------
第24章 学习常用的前端算法与数据结构
-------------递归------------------
递归的意思就是自己调用自己，在函数内部自身再次调用自己。常见于重复获取ajax里面的数据如果失败的话。
接下来再讲一个常用过的场景，dom树的遍历层次以及获取最深层度 自己设计一个gelElementTree获取当前层级节点的数量
function gelElementTree(container){
  let num = container.childNodes.length
  for(let i = 0;i<container.childNodes.length;i++){
    num +=gelElementTree(container.childNodes[i])
  }
  return num
}

------------重复值处理-----------------------
即给定两个数组 找出两个数组里面相同的元素和不相同的元素
function test(arr1,arr2){
  arr1.reduce((prev,cur) =>{
    return arr2.indexOf(cur) !== -1 ? prev.push(cur) : prev
  },[])
}

第二十五章 掌握同源策略和跨域
同源策略其实就是解决跨域的问题，和为跨域 三种  1：域名不一样 2 端口号不一样 3 协议不一样
其实跨域请求是正常发出并且成功获取到请求，但是浏览器作为拦截而且
那么黑客们如何跨过跨域请求获取数据呢，其实就是csrf和xss
csrf其实就是一般在于评论或者可以填入一些信息的层次，如果黑客认为的注入一些js代码比如获取cookie什么的。

第二十九章 理解字号与行高
一般来说设置的font-size大小并不等就是字体的高度，一般会超出这个高度

第三十章 如何理解移动端的click事件
为什么移动端的click事件会有300ms的延迟 就是移动端得判断是单机还是双击 所以需要预留300ms的条件
--那对于移动端的click事件以及touch事件，到底触发顺序是什么呢？

第三十一章 学习js的一些高级技巧
如何判断一个变量是否数组 Array.isArray() Object.prototype.toString.call().slice(8,-1)
其中instanceOf也可以 不过会出现问题 就是如果当前内面内嵌入了ifame的话
